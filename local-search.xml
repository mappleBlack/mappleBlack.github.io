<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>韩顺平-反射机制</title>
    <link href="/2023/01/30/%E9%9F%A9%E9%A1%BA%E5%B9%B3-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/01/30/%E9%9F%A9%E9%A1%BA%E5%B9%B3-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#1_2">1、前言</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#2_12">2、一个需求引出反射</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#3_73">3、反射机制</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#31_Java_Reflection_74">3.1 Java Reflection</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#32__78">3.2 反射机制原理图</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#33__81">3.3 反射机制可以完成的功能</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#34__88">3.4 反射相关的主要类</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#35__148">3.5 反射优点和缺点</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#36__152">3.6 反射调用优化——关闭访问检查</a></li></ul></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#4Class_214">4、Class类</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#41__215">4.1 基本介绍</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#42_Class_225">4.2 Class类的常用方法</a></li></ul></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#5Class_282">5、获取Class类对象</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#6Class_331">6、哪些类型有Class对象</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#7_371">7、类加载</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#71__372">7.1 基本说明</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#72__377">7.2 类加载时机</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#73__383">7.3 类加载过程图</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#74__386">7.4 类加载三个阶段完成任务</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#741__389">7.4.1 加载阶段</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#742__392">7.4.2 连接阶段——验证</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#743__395">7.4.3 连接阶段——准备</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#744__418">7.4.4 连接阶段——解析</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#745_Initialization_421">7.4.5 Initialization（初始化）</a></li></ul></li></ul></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#8_471">8、通过反射获取类的结构信息</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#81_javalangClass_472">8.1 java.lang.Class类</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#82_javalangreflectField_475">8.2 java.lang.reflect.Field类</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#83_javalangreflectMethod_478">8.3 java.lang.reflect.Method类</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#84_javalangreflectConstructor_481">8.4 java.lang.reflect.Constructor类</a></li></ul></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#9_653">9、通过反射创建对象</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#10_715">10、通过反射访问类中的成员</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#101__716">10.1 访问属性</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#102__761">10.2 访问方法</a></li></ul></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#11_826">11、练习案例</a></li><li><ul><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#_827">练习一</a></li><li><a href="file:///C:/Users/hugang1/Desktop/%E6%96%B0%E6%96%87%E4%BB%B6%201.html#_869">练习二</a></li></ul></li></ul></li></ul><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>该技术博客是我根据韩顺平老师的<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">反射机制</a>教程整理的学习笔记，希望能为大家带来帮助！链接如下：</p><p><a href="https://www.bilibili.com/video/BV1g84y1F7df?share_source=copy_web">https://www.bilibili.com/video/BV1g84y1F7df?share_source&#x3D;copy_web</a></p><blockquote><p><em><strong>更多好文推荐</strong></em> ：</p><ul><li><a href="https://blog.csdn.net/weixin_46594796/article/details/113742367">Java常用类笔记</a></li><li><a href="https://blog.csdn.net/weixin_46594796/article/details/108017547">计算机底层原理——汇编语言</a></li><li><a href="https://blog.csdn.net/weixin_46594796/article/details/113442988">学习Java异常，吃透这篇足够</a></li></ul></blockquote><h2 id="2、一个需求引出反射"><a href="#2、一个需求引出反射" class="headerlink" title="2、一个需求引出反射"></a>2、一个需求引出反射</h2><p>需求如下：</p><blockquote><p>根据配置文件re.properties中的指定信息，创建Cat对象并调用方法hi<br>配置文件中代码：<code>classfullpath=com.hspedu.Cat</code>，<code>method=hi</code><br>这样的需求在学习框架时非常多，通过外部文件配置，在不修改源码情况下控制程序<br>符合设计模式的ocp原则（开闭原则：不修改源码，扩容功能）</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;招财猫&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;喵喵叫&quot;</span>);<br>    &#125;<br>&#125;<br>==============================================================================<br><span class="hljs-keyword">package</span> com.hspedu.reflection.question;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">//反射问题引入</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span> <span class="hljs-comment">//抑制警告信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionQuestion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//根据配置文件中的信息，创建Cat对象并调用hi方法</span><br>        <span class="hljs-comment">//传统方式：new Cat().hi();</span><br><br>        <span class="hljs-comment">//1.使用Properties类读写配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\re.properties&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classfullpath</span> <span class="hljs-operator">=</span> properties.get(<span class="hljs-string">&quot;classfullpath&quot;</span>).toString(); <span class="hljs-comment">//com.hspedu.Cat</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> properties.get(<span class="hljs-string">&quot;method&quot;</span>).toString(); <span class="hljs-comment">//hi</span><br>        System.out.println(<span class="hljs-string">&quot;classfullpath=&quot;</span> + classfullpath);<br>        System.out.println(<span class="hljs-string">&quot;methodName=&quot;</span> + methodName);<br><br>        <span class="hljs-comment">//2.使用传统方式创建对象行不通，需要使用 反射机制</span><br>        <span class="hljs-comment">//2.1加载类，返回Class类型的对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classfullpath);<br>        <span class="hljs-comment">//2.2通过 cls对象 得到加载的类 com.hspedu.Cat 的对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br>        <span class="hljs-comment">//2.3通过 cls对象 得到加载的类 com.hspedu.Cat 的 methodName 方法对象</span><br>        <span class="hljs-comment">//在反射机制中，可以把方法视为对象（万物皆对象）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> cls.getMethod(methodName);<br>        <span class="hljs-comment">//2.4通过 method1 调用方法：即通过方法对象实现调用方法</span><br>        method1.invoke(o); <span class="hljs-comment">//传统方法：对象.方法(); 反射机制：方法.invoke(对象)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们发现，我们只需要将re.properties中的 method&#x3D;hi 改成 method&#x3D;cry，就会调用cry()，不需要修改源码，反射机制非常强大！</p><h2 id="3、反射机制"><a href="#3、反射机制" class="headerlink" title="3、反射机制"></a>3、反射机制</h2><h3 id="3-1-Java-Reflection"><a href="#3-1-Java-Reflection" class="headerlink" title="3.1 Java Reflection"></a>3.1 Java Reflection</h3><ol><li>反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息（比如：成员变量，构造器，成员方法等），并能操作对象的属性及方法。反射在设计模式和框架的底层都会用到</li><li>加载完类之后，在堆内存中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了<strong>类的完整结构信息</strong>。通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以形象称之为：反射</li></ol><h3 id="3-2-反射机制原理图"><a href="#3-2-反射机制原理图" class="headerlink" title="3.2 反射机制原理图"></a>3.2 反射机制<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E7%90%86%E5%9B%BE&spm=1001.2101.3001.7020">原理图</a></h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527641.png" alt="在这里插入图片描述"></p><h3 id="3-3-反射机制可以完成的功能"><a href="#3-3-反射机制可以完成的功能" class="headerlink" title="3.3 反射机制可以完成的功能"></a>3.3 反射机制可以完成的功能</h3><ol><li>在运行时，判断任意一个对象所属的类</li><li>在运行时，创建任意一个类的对象</li><li>在运行时，得到任意一个类所具有的成员变量和方法</li><li>在运行时，调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h3 id="3-4-反射相关的主要类"><a href="#3-4-反射相关的主要类" class="headerlink" title="3.4 反射相关的主要类"></a>3.4 反射相关的主要类</h3><p>这些类在 java.lang.reflection包下：</p><ol><li>java.lang.Class：代表一个类，Class对象表示某个类加载后在堆内存中的对象</li><li>java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法</li><li>java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器</li></ol><p>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;招财猫&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;喵喵叫&quot;</span>);<br>    &#125;<br>&#125;<br>==========================================================================<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflection01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\re.properties&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classfullpath</span> <span class="hljs-operator">=</span> properties.get(<span class="hljs-string">&quot;classfullpath&quot;</span>).toString(); <span class="hljs-comment">//com.hspedu.Cat</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> properties.get(<span class="hljs-string">&quot;method&quot;</span>).toString(); <span class="hljs-comment">//hi</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classfullpath);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br><br>        <span class="hljs-comment">//java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量</span><br>        <span class="hljs-comment">//getField()不能得到私有的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(nameField.get(o));<br><br>        <span class="hljs-comment">//java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器</span><br>        <span class="hljs-comment">//()中可以指定构造器的参数类型，如果不传参就是无参构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> cls.getConstructor();<br>        System.out.println(constructor);<br>        <span class="hljs-comment">//参数传递String.class就是String类的Class对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor1</span> <span class="hljs-operator">=</span> cls.getConstructor(String.class);<br>        System.out.println(constructor1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-反射优点和缺点"><a href="#3-5-反射优点和缺点" class="headerlink" title="3.5 反射优点和缺点"></a>3.5 反射优点和缺点</h3><ul><li>优点：可以动态的创建和使用对象（就是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。</li><li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ul><h3 id="3-6-反射调用优化——关闭访问检查"><a href="#3-6-反射调用优化——关闭访问检查" class="headerlink" title="3.6 反射调用优化——关闭访问检查"></a>3.6 反射调用优化——关闭访问检查</h3><ol><li>Method、Field、Constructor对象都有setAccessible()方法</li><li>setAccessible()作用是启动和禁用访问安全检查开关</li><li>参数为true表示：反射的对象在使用时取消访问检查，提高反射的效率。<br>参数为false表示：反射的对象执行访问检查</li></ol><p>![在这里插入图片描述](</p><p>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.hspedu.Cat;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflection01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        m1(); <span class="hljs-comment">//m1()耗时：4</span><br>        m2(); <span class="hljs-comment">//m2()耗时：161</span><br>        m3(); <span class="hljs-comment">//m3()耗时：109</span><br>    &#125;<br><br>    <span class="hljs-comment">//传统方式调用hi()，将hi()中的输出语句注释</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            cat.hi();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;m1()耗时：&quot;</span> + (end - start));<br>    &#125;<br><br>    <span class="hljs-comment">//反射机制调用hi()，将hi()中的输出语句注释</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.hspedu.Cat&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            hi.invoke(o);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;m2()耗时：&quot;</span> + (end - start));<br>    &#125;<br><br>    <span class="hljs-comment">//反射调用优化：关闭访问检测</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.hspedu.Cat&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        <span class="hljs-comment">//在反射调用方法时，取消访问检查</span><br>        hi.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">90000000</span>; i++) &#123;<br>            hi.invoke(o);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;m3()耗时：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、Class类"><a href="#4、Class类" class="headerlink" title="4、Class类"></a>4、Class类</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527644.png" alt="在这里插入图片描述"></p><ol><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例生成</li><li>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象存放在堆内存中</li><li>类的字节码二进制数据存放在方法区中，有的地方称为类的元数据（包括：方法，变量名，方法名，访问权限等）</li></ol><h3 id="4-2-Class类的常用方法"><a href="#4-2-Class类的常用方法" class="headerlink" title="4.2 Class类的常用方法"></a>4.2 Class类的常用方法</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527645.png" alt="在这里插入图片描述"></p><p>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;宝马&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">500000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;白色&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&quot;, color=&#x27;&quot;</span> + color + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br>=======================================================================<br><span class="hljs-keyword">import</span> com.hspedu.Car;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">//演示Class类的常用方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.hspedu.Car&quot;</span>;<br>        <span class="hljs-comment">//1.获取Car类对应的Class对象</span><br>        <span class="hljs-comment">//&lt;?&gt;表示不确定的Java类型</span><br>        Class&lt;?&gt; cls = Class.forName(classAllPath);<br>        <span class="hljs-comment">//2.输出cls，显示cls对象是哪个类的Class对象</span><br>        System.out.println(cls); <span class="hljs-comment">//com.hspedu.Car</span><br>        <span class="hljs-comment">//输出cls运行类型 java.lang.Class</span><br>        System.out.println(cls.getClass());<br>        <span class="hljs-comment">//3.获取包名，com.hspedu</span><br>        System.out.println(cls.getPackage().getName());<br>        <span class="hljs-comment">//4.得到全类名，java.hspedu.Car</span><br>        System.out.println(cls.getName());<br>        <span class="hljs-comment">//5.通过cls创建对象实例</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> (Car) cls.newInstance();<br>        System.out.println(car);<br>        <span class="hljs-comment">//6.通过反射获取属性 brand</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;brand&quot;</span>);<br>        System.out.println(brand.get(car));<br>        <span class="hljs-comment">//7.通过反射给属性赋值</span><br>        brand.set(car, <span class="hljs-string">&quot;奔驰&quot;</span>);<br>        System.out.println(brand.get(car));<br>        <span class="hljs-comment">//8.获取所有的属性</span><br>        Field[] fields = cls.getFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、获取Class类对象"><a href="#5、获取Class类对象" class="headerlink" title="5、获取Class类对象"></a>5、获取Class类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.hspedu.Car;<br><br><span class="hljs-comment">//得到Class对象的6种方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetClass_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.Class.forName【编译阶段】，应用场景：通过读取配置文件获取</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">classAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.hspedu.Car&quot;</span>;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls1</span> <span class="hljs-operator">=</span> Class.forName(classAllPath);<br>        System.out.println(cls1);<br><br>        <span class="hljs-comment">//2.类名.class【Class类阶段】，应用场景：用于参数传递</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls2</span> <span class="hljs-operator">=</span> Car.class;<br>        System.out.println(cls2);<br><br>        <span class="hljs-comment">//3.对象.getClass()【运行阶段】，应用场景：有对象实例</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls3</span> <span class="hljs-operator">=</span> car.getClass();<br>        System.out.println(cls3);<br><br>        <span class="hljs-comment">//4.通过类加载器（4种）【类加载阶段】来获取类的Class对象</span><br>        <span class="hljs-comment">//4.1获取Car类的类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> car.getClass().getClassLoader();<br>        <span class="hljs-comment">//4.2通过类加载器得到Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cls4</span> <span class="hljs-operator">=</span> classLoader.loadClass(classAllPath);<br>        System.out.println(cls4);<br><br>        <span class="hljs-comment">//cls1,cls2,cls3,cls4都是同一个Class对象（一个类只有一个Class对象）</span><br>        System.out.println(cls1.hashCode());<br>        System.out.println(cls2.hashCode());<br>        System.out.println(cls3.hashCode());<br>        System.out.println(cls4.hashCode());<br><br>        <span class="hljs-comment">//5.基本数据类型按照如下方式得到Class类对象</span><br>        Class&lt;Integer&gt; integerClass = <span class="hljs-type">int</span>.class;<br>        Class&lt;Character&gt; characterClass = <span class="hljs-type">char</span>.class;<br>        Class&lt;Boolean&gt; booleanClass = <span class="hljs-type">boolean</span>.class;<br>        System.out.println(integerClass); <span class="hljs-comment">//int</span><br><br>        <span class="hljs-comment">//6.基本数据类型对应的包装类，可以通过.TYPE得到Class类对象</span><br>        Class&lt;Integer&gt; type1 = Integer.TYPE;<br>        Class&lt;Character&gt; type2 = Character.TYPE;<br>        System.out.println(type1); <span class="hljs-comment">//int</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、哪些类型有Class对象"><a href="#6、哪些类型有Class对象" class="headerlink" title="6、哪些类型有Class对象"></a>6、哪些类型有Class对象</h2><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>接口</li><li>数组</li><li>枚举</li><li>注解</li><li>基本数据类型</li><li>void</li></ol><p>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllTypeClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Class&lt;String&gt; cls1 = String.class; <span class="hljs-comment">//外部类</span><br>        Class&lt;Serializable&gt; cls2 = Serializable.class; <span class="hljs-comment">//接口</span><br>        Class&lt;Integer[]&gt; cls3 = Integer[].class; <span class="hljs-comment">//数组</span><br>        Class&lt;<span class="hljs-type">float</span>[][]&gt; cls4 = <span class="hljs-type">float</span>[][].class; <span class="hljs-comment">//二维数组</span><br>        Class&lt;Deprecated&gt; cls5 = Deprecated.class; <span class="hljs-comment">//注解</span><br>        Class&lt;Thread.State&gt; cls6 = Thread.State.class; <span class="hljs-comment">//枚举</span><br>        Class&lt;Long&gt; cls7 = <span class="hljs-type">long</span>.class; <span class="hljs-comment">//基本数据类型</span><br>        Class&lt;Void&gt; cls8 = <span class="hljs-keyword">void</span>.class; <span class="hljs-comment">//void 数据类型</span><br>        Class&lt;Class&gt; cls9 = Class.class;<br><br>        System.out.println(cls1);<br>        System.out.println(cls2);<br>        System.out.println(cls3);<br>        System.out.println(cls4);<br>        System.out.println(cls5);<br>        System.out.println(cls6);<br>        System.out.println(cls7);<br>        System.out.println(cls8);<br>        System.out.println(cls9);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、类加载"><a href="#7、类加载" class="headerlink" title="7、类加载"></a>7、<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a></h2><h3 id="7-1-基本说明"><a href="#7-1-基本说明" class="headerlink" title="7.1 基本说明"></a>7.1 基本说明</h3><p>反射机制是Java实现<strong>动态语言</strong>的关键，也就是通过反射实现类的动态加载。</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性</li></ol><h3 id="7-2-类加载时机"><a href="#7-2-类加载时机" class="headerlink" title="7.2 类加载时机"></a>7.2 类加载时机</h3><ol><li>当创建对象时（new）——静态加载</li><li>当子类被加载时，父类也加载——静态加载</li><li>调用类中的静态成员时——静态加载</li><li>通过反射——动态加载</li></ol><h3 id="7-3-类加载过程图"><a href="#7-3-类加载过程图" class="headerlink" title="7.3 类加载过程图"></a>7.3 类加载过程图</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527646.png" alt="在这里插入图片描述"></p><h3 id="7-4-类加载三个阶段完成任务"><a href="#7-4-类加载三个阶段完成任务" class="headerlink" title="7.4 类加载三个阶段完成任务"></a>7.4 类加载三个阶段完成任务</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527647.png" alt="在这里插入图片描述"></p><h4 id="7-4-1-加载阶段"><a href="#7-4-1-加载阶段" class="headerlink" title="7.4.1 加载阶段"></a>7.4.1 加载阶段</h4><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527648.png" alt="在这里插入图片描述"></p><h4 id="7-4-2-连接阶段——验证"><a href="#7-4-2-连接阶段——验证" class="headerlink" title="7.4.2 连接阶段——验证"></a>7.4.2 连接阶段——验证</h4><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527649.png" alt="在这里插入图片描述"></p><h4 id="7-4-3-连接阶段——准备"><a href="#7-4-3-连接阶段——准备" class="headerlink" title="7.4.3 连接阶段——准备"></a>7.4.3 连接阶段——准备</h4><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527650.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类加载的连接阶段——准备</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoad02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//属性（成员变量，字段）</span><br>    <span class="hljs-comment">//分析类加载的连接阶段——准备，属性是如何处理：</span><br>    <span class="hljs-comment">//1. n1是成员变量，不是静态变量，因此在准备阶段，不会分配内存</span><br>    <span class="hljs-comment">//2. n2是静态变量，分配内存，n2是默认初始化0，而不是20</span><br>    <span class="hljs-comment">//3. n3是static final常量，和静态变量不一样，因为一旦赋值就不变，n3 = 30</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-4-4-连接阶段——解析"><a href="#7-4-4-连接阶段——解析" class="headerlink" title="7.4.4 连接阶段——解析"></a>7.4.4 连接阶段——解析</h4><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h4 id="7-4-5-Initialization（初始化）"><a href="#7-4-5-Initialization（初始化）" class="headerlink" title="7.4.5 Initialization（初始化）"></a>7.4.5 Initialization（初始化）</h4><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527651.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类加载初始化阶段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoad03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.加载B类，并生成对应的Class类对象</span><br>        <span class="hljs-comment">//2.连接 num = 0;</span><br>        <span class="hljs-comment">//3.初始化阶段：依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并合并</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            clinit()&#123;</span><br><span class="hljs-comment">                System.out.println(&quot;B 静态代码块被执行&quot;);</span><br><span class="hljs-comment">                //num = 300;</span><br><span class="hljs-comment">                num = 100;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            合并：num = 100;</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">//new B(); //类加载</span><br>        <span class="hljs-comment">//System.out.println(B.num); //100，如果直接使用类的静态属性，也会导致类的加载</span><br><br>        <span class="hljs-comment">//加载类的时候，是有同步机制控制</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="hljs-comment">                //正因为有这个机制，才能保证某个类在内存中，只有一个 Class 对象</span><br><span class="hljs-comment">                synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="hljs-comment">                    //...</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 静态代码块被执行&quot;</span>);<br>        num = <span class="hljs-number">300</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 构造器被执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、通过反射获取类的结构信息"><a href="#8、通过反射获取类的结构信息" class="headerlink" title="8、通过反射获取类的结构信息"></a>8、通过反射获取类的结构信息</h2><h3 id="8-1-java-lang-Class类"><a href="#8-1-java-lang-Class类" class="headerlink" title="8.1 java.lang.Class类"></a>8.1 java.lang.Class类</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527652.png" alt="在这里插入图片描述"></p><h3 id="8-2-java-lang-reflect-Field类"><a href="#8-2-java-lang-reflect-Field类" class="headerlink" title="8.2 java.lang.reflect.Field类"></a>8.2 java.lang.reflect.Field类</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527653.png" alt="在这里插入图片描述"></p><h3 id="8-3-java-lang-reflect-Method类"><a href="#8-3-java-lang-reflect-Method类" class="headerlink" title="8.3 java.lang.reflect.Method类"></a>8.3 java.lang.reflect.Method类</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527654.png" alt="在这里插入图片描述"></p><h3 id="8-4-java-lang-reflect-Constructor类"><a href="#8-4-java-lang-reflect-Constructor类" class="headerlink" title="8.4 java.lang.reflect.Constructor类"></a>8.4 java.lang.reflect.Constructor类</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527655.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//通过反射获取类的结构信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionUtils</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api_02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//得到Class对象</span><br>        Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.Person&quot;</span>);<br>        <span class="hljs-comment">//getDeclaredFields:获取本类中所有属性</span><br>        <span class="hljs-comment">//规定 说明: 默认修饰符 是0 ， public  是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span><br>        Field[] declaredFields = personCls.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()<br>                    + <span class="hljs-string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()<br>                    + <span class="hljs-string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());<br>        &#125;<br><br>        <span class="hljs-comment">//getDeclaredMethods:获取本类中所有方法</span><br>        Method[] declaredMethods = personCls.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()<br>                    + <span class="hljs-string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()<br>                    + <span class="hljs-string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());<br><br>            <span class="hljs-comment">//输出当前这个方法的形参数组情况</span><br>            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();<br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;<br>                System.out.println(<span class="hljs-string">&quot;该方法的形参类型=&quot;</span> + parameterType);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//getDeclaredConstructors:获取本类中所有构造器</span><br>        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<br><br>            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();<br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;<br>                System.out.println(<span class="hljs-string">&quot;该构造器的形参类型=&quot;</span> + parameterType);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//第一组方法API</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">api_01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//得到Class对象</span><br>        Class&lt;?&gt; personCls = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.Person&quot;</span>);<br>        <span class="hljs-comment">//getName:获取全类名</span><br>        System.out.println(personCls.getName());<br>        <span class="hljs-comment">//getSimpleName:获取简单类名</span><br>        System.out.println(personCls.getSimpleName());<br>        <span class="hljs-comment">//getFields:获取所有public修饰的属性，包含本类以及父类的</span><br>        Field[] fields = personCls.getFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类以及父类的属性=&quot;</span> + field.getName());<br>        &#125;<br>        <span class="hljs-comment">//getDeclaredFields:获取本类中所有属性</span><br>        Field[] declaredFields = personCls.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());<br>        &#125;<br>        <span class="hljs-comment">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span><br>        Method[] methods = personCls.getMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类以及父类的方法=&quot;</span> + method.getName());<br>        &#125;<br>        <span class="hljs-comment">//getDeclaredMethods:获取本类中所有方法</span><br>        Method[] declaredMethods = personCls.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());<br>        &#125;<br>        <span class="hljs-comment">//getConstructors: 获取所有public修饰的构造器，包含本类</span><br>        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类的构造器=&quot;</span> + constructor.getName());<br>        &#125;<br>        <span class="hljs-comment">//getDeclaredConstructors:获取本类中所有构造器</span><br>        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<br>        &#125;<br>        <span class="hljs-comment">//getPackage:以Package形式返回 包信息</span><br>        System.out.println(personCls.getPackage());<br>        <span class="hljs-comment">//getSuperClass:以Class形式返回父类信息</span><br>        Class&lt;?&gt; superclass = personCls.getSuperclass();<br>        System.out.println(<span class="hljs-string">&quot;父类的class对象=&quot;</span> + superclass);<br>        <span class="hljs-comment">//getInterfaces:以Class[]形式返回接口信息</span><br>        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;<br>            System.out.println(<span class="hljs-string">&quot;接口信息=&quot;</span> + anInterface);<br>        &#125;<br>        <span class="hljs-comment">//getAnnotations:以Annotation[] 形式返回注解信息</span><br>        Annotation[] annotations = personCls.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(<span class="hljs-string">&quot;注解信息=&quot;</span> + annotation);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> String hobby;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(String name)</span> &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> &#123;<br><br>&#125;<br><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>, IB &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">// 4 + 8 = 12</span><br>    String job;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> sal;<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//私有的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">double</span> sal)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9、通过反射创建对象"><a href="#9、通过反射创建对象" class="headerlink" title="9、通过反射创建对象"></a>9、通过反射创建对象</h2><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527656.png" alt="在这里插入图片描述"></p><p>测试 1：通过反射创建某类的对象，要求该类中必须有 public 的无参构造<br>测试 2：通过调用某个特定构造器的方式，实现创建某类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-comment">//通过反射机制创建实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectCreateInstance</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 先获取到User类的Class对象</span><br>        Class&lt;?&gt; userClass = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.User&quot;</span>);<br>        <span class="hljs-comment">//2. 通过public的无参构造器创建实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> userClass.newInstance();<br>        System.out.println(o);<br>        <span class="hljs-comment">//3. 通过public的有参构造器创建实例</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            constructor 对象就是</span><br><span class="hljs-comment">            public User(String name) &#123;//public的有参构造器</span><br><span class="hljs-comment">                this.name = name;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//3.1 先得到对应构造器</span><br>        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);<br>        <span class="hljs-comment">//3.2 创建实例，并传入实参</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">hsp</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;hsp&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hsp=&quot;</span> + hsp);<br>        <span class="hljs-comment">//4. 通过非public的有参构造器创建实例</span><br>        <span class="hljs-comment">//4.1 得到private的构造器对象</span><br>        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);<br>        <span class="hljs-comment">//4.2 创建实例</span><br>        <span class="hljs-comment">//暴破【暴力破解】，使用反射可以访问private构造器/方法/属性, 反射面前，都是纸老虎</span><br>        constructor1.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> constructor1.newInstance(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;张三丰&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user2=&quot;</span> + user2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;韩顺平教育&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [age=&quot;</span> + age + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、通过反射访问类中的成员"><a href="#10、通过反射访问类中的成员" class="headerlink" title="10、通过反射访问类中的成员"></a>10、通过反射访问类中的成员</h2><h3 id="10-1-访问属性"><a href="#10-1-访问属性" class="headerlink" title="10.1 访问属性"></a>10.1 访问属性</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527657.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">//反射操作属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectAccessProperty</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 得到Student类对应的 Class对象</span><br>        Class&lt;?&gt; stuClass = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.Student&quot;</span>);<br>        <span class="hljs-comment">//2. 创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> stuClass.newInstance();<span class="hljs-comment">//o 的运行类型就是Student</span><br>        System.out.println(o.getClass());<span class="hljs-comment">//Student</span><br>        <span class="hljs-comment">//3. 使用反射得到age 属性对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> stuClass.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        age.set(o, <span class="hljs-number">88</span>);<span class="hljs-comment">//通过反射来操作属性</span><br>        System.out.println(o);<span class="hljs-comment">//</span><br>        System.out.println(age.get(o));<span class="hljs-comment">//返回age属性的值</span><br>        <span class="hljs-comment">//4. 使用反射操作name 属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stuClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//对name 进行暴破, 可以操作private 属性</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//name.set(o, &quot;老韩&quot;);</span><br>        name.set(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;老韩~&quot;</span>);<span class="hljs-comment">//因为name是static属性，因此 o 也可以写出null</span><br>        System.out.println(o);<br>        System.out.println(name.get(o)); <span class="hljs-comment">//获取属性值</span><br>        System.out.println(name.get(<span class="hljs-literal">null</span>));<span class="hljs-comment">//获取属性值, 要求name是static</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [age=&quot;</span> + age + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-访问方法"><a href="#10-2-访问方法" class="headerlink" title="10.2 访问方法"></a>10.2 访问方法</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527658.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//通过反射调用方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectAccessMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 得到Boss类对应的Class对象</span><br>        Class&lt;?&gt; bossCls = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.Boss&quot;</span>);<br>        <span class="hljs-comment">//2. 创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> bossCls.newInstance();<br>        <span class="hljs-comment">//3. 调用public的hi方法</span><br>        <span class="hljs-comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span><br>        <span class="hljs-comment">//3.1 得到hi方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> bossCls.getDeclaredMethod(<span class="hljs-string">&quot;hi&quot;</span>, String.class);<span class="hljs-comment">//OK</span><br>        <span class="hljs-comment">//3.2 调用</span><br>        hi.invoke(o, <span class="hljs-string">&quot;我是徐志斌~&quot;</span>);<br>        <span class="hljs-comment">//4. 调用private static 方法</span><br>        <span class="hljs-comment">//4.1 得到 say 方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">say</span> <span class="hljs-operator">=</span> bossCls.getDeclaredMethod(<span class="hljs-string">&quot;say&quot;</span>, <span class="hljs-type">int</span>.class, String.class, <span class="hljs-type">char</span>.class);<br>        <span class="hljs-comment">//4.2 因为say方法是private, 所以需要暴破，原理和前面讲的构造器和属性一样</span><br>        say.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(say.invoke(o, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&#x27;男&#x27;</span>));<br>        <span class="hljs-comment">//4.3 因为say方法是static的，还可以这样调用 ，可以传入null</span><br>        System.out.println(say.invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&#x27;女&#x27;</span>));<br><br>        <span class="hljs-comment">//5. 在反射中，如果方法有返回值，统一返回Object , 但是他运行类型和方法定义的返回类型一致</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">reVal</span> <span class="hljs-operator">=</span> say.invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">300</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="hljs-comment">//String</span><br><br>        <span class="hljs-comment">//在演示一个返回的案例</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> bossCls.getDeclaredMethod(<span class="hljs-string">&quot;m1&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">reVal2</span> <span class="hljs-operator">=</span> m1.invoke(o);<br>        System.out.println(<span class="hljs-string">&quot;reVal2的运行类型=&quot;</span> + reVal2.getClass());<span class="hljs-comment">//Monster</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boss</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Boss</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Monster <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monster</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">say</span><span class="hljs-params">(<span class="hljs-type">int</span> n, String s, <span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot; &quot;</span> + c;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11、练习案例"><a href="#11、练习案例" class="headerlink" title="11、练习案例"></a>11、练习案例</h2><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527659.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeWork01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 定义PrivateTest类，有私有name属性，并且属性值为hellokitty</span><br><span class="hljs-comment">         * 提供getName的公有方法</span><br><span class="hljs-comment">         * 创建PrivateTest的类，利用Class类得到私有的name属性，修改私有的name属性值，并调用getName()的方法打印name属性值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//1. 得到 PrivateTest类对应的Class对象</span><br>        Class&lt;PrivateTest&gt; privateTestClass = PrivateTest.class;<br>        <span class="hljs-comment">//2. 创建对象实例</span><br>        <span class="hljs-type">PrivateTest</span> <span class="hljs-variable">privateTestObj</span> <span class="hljs-operator">=</span> privateTestClass.newInstance();<br>        <span class="hljs-comment">//3. 得到name属性对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> privateTestClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//name属性是private</span><br>        <span class="hljs-comment">//4. 暴破name</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(privateTestObj, <span class="hljs-string">&quot;天龙八部&quot;</span>);<br>        <span class="hljs-comment">//5. 得到getName方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> privateTestClass.getMethod(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-comment">//6. 因为getName() 是public，所有直接调用</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> getName.invoke(privateTestObj);<br>        System.out.println(<span class="hljs-string">&quot;name属性值=&quot;</span> + invoke);<span class="hljs-comment">//天龙八部</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hellokitty&quot;</span>;<br><br>    <span class="hljs-comment">//默认无参构造器</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301527660.png" alt="在这里插入图片描述"><br>代码展示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeWork02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 利用Class类的forName方法得到File类的class 对象</span><br><span class="hljs-comment">         * 在控制台打印File类的所有构造器</span><br><span class="hljs-comment">         * 通过newInstance的方法创建File对象，并创建D:\mynew.txt文件</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//1. Class类的forName方法得到File类的class 对象</span><br>        Class&lt;?&gt; fileCls = Class.forName(<span class="hljs-string">&quot;java.io.File&quot;</span>);<br>        <span class="hljs-comment">//2. 得到所有的构造器</span><br>        Constructor&lt;?&gt;[] declaredConstructors = fileCls.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;File构造器=&quot;</span> + declaredConstructor);<br>        &#125;<br>        <span class="hljs-comment">//3. 指定的得到 public java.io.File(java.lang.String)</span><br>        Constructor&lt;?&gt; declaredConstructor = fileCls.getDeclaredConstructor(String.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileAllPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;d:\\mynew.txt&quot;</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance(fileAllPath);<span class="hljs-comment">//创建File对象</span><br>        <span class="hljs-comment">//4. 得到createNewFile 的方法对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">createNewFile</span> <span class="hljs-operator">=</span> fileCls.getMethod(<span class="hljs-string">&quot;createNewFile&quot;</span>);<br>        createNewFile.invoke(file);<span class="hljs-comment">//创建文件，调用的是 createNewFile</span><br>        <span class="hljs-comment">//file的运行类型就是File</span><br>        System.out.println(file.getClass());<br>        System.out.println(<span class="hljs-string">&quot;创建文件成功&quot;</span> + fileAllPath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ali-前置知识-线程局部变量</title>
    <link href="/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <url>/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><strong>是什么</strong></h1><p>一句话概括：并发编程中既然可以多线程操作共享资源，那么也会有线程之间资源隔离，每个线程只能访问自己的数据不能访问别的线程中的数据。Synchronized用于多线程间的数据共享，而ThreadLocal则用于线程间的数据隔离，通过ThreadLocal在同一线程不同组件中传递公共变量。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><strong>前置知识</strong></h1><p>Java中的4种引用类型-强软弱虚</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h2><p>JVM进行GC垃圾回收的时候针对强引用对象是不会被回收的，在Java中最常见的就是强引用，把一个对象赋值给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用对象应用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象永远都不会被用到JVM也不会回收。如果堆内存不足时那么就会出现OOM（内存溢出）。一般来说我们创建的对象都是强引用对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrongReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">//这样的定义默认就是强引用</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> obj1; <span class="hljs-comment">//obj2引用赋值</span><br>        obj1=<span class="hljs-literal">null</span>; <span class="hljs-comment">//置空</span><br>        System.gc(); <span class="hljs-comment">//触发gc</span><br>        System.out.println(obj1); <span class="hljs-comment">//obj1</span><br>        System.out.println(obj2); <span class="hljs-comment">//obj2依然还存在</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：当内存不足，JVM开始垃圾回收，对于强引用对象，就算是出现了OOM也不会对该对象进行回收，死都不收。强引用对象是我们最常见的普通的对象引用，只要还有强引用指向对象，就表明对象还活着，垃圾回收器不会碰这个对象。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h2><p>当系统内存充足的时候不会被回收，当系统内存不足的时候就会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;  m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">10</span>]);<br>        System.out.println(m.get());<br>        System.gc();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(m.get());<br>        <span class="hljs-comment">//在分配一个数组，设置JVM堆内存最大20M，做实验  -Xmx20M。那么新创建的byte[]原有空间一定装不下</span><br>        <span class="hljs-comment">//这时候系统就会垃圾回收，先回收一次，如果不够会把软引用也回收掉</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">15</span>];<br>        System.out.println(m.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：非常适合做缓存。系统资源足够的时候就从缓存中取资源，不够了时候把缓存干掉</p><h2 id="弱引用（重点）"><a href="#弱引用（重点）" class="headerlink" title="弱引用（重点）"></a><strong>弱引用（重点）</strong></h2><p>弱引用的对象，只要垃圾回收机制一运行，就会被干掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        System.out.println(weakReference.get());<br>        System.gc();<br>        System.out.println(weakReference.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有啥用？下文会跟ThreadLocal源码一起分析，也就是接下来的重点。</p><h2 id="虚引用（基本用不到）"><a href="#虚引用（基本用不到）" class="headerlink" title="虚引用（基本用不到）"></a><strong>虚引用（基本用不到）</strong></h2><p>首先说明虚引用不是本文重点，工作场景也基本没有，为了知识体系完整性才写出来。减轻大家脑力，可以不看。<br>虚引用，get不到。弱引用虽然弱，但是可以拿到。没有被回收之前，虚引用回不回收都拿不到。<br>作用：主要是操作系统内管理直接内存DirectByteBuffer。</p><h1 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a><strong>ThreadLocal是什么？</strong></h1><p>前置知识说完了，我们先通过一个场景来引出ThreadLccal。<br>假设一种场景：方法内传递全局参数，方法里面经历了好多次深层调用之后，我想拿到这个变量怎么办？</p><ul><li>方法1：把这个变量一层一层传进来</li></ul><p><strong>优点</strong>：大多数情况下确实可以解决上面的问题，比较简单<br><strong>缺点</strong>：无法解决一些特定场景，比如调用别人的类库中的方法，就传递不了了。而且多层方法都要加个参数，太累了</p><ul><li>方法2：我直接把变量定义成static，全局都可以调度。但是这种方法在多线程访问情形下是不安全的。</li><li>方法3：还有没有更加好的方法：ThreadLocal。</li></ul><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。<br>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。<br>所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p><h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a><strong>ThreadLocal原理</strong></h1><p>既然ThreadLocal则用于线程间的数据隔离，每个线程都可以独立的操作自己独立的变量副本而不会影响别的线程中的变量。先用一个简单的代码演示一下结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Person&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(tl.get());<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            tl.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yangguo&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：null<br>一个简单的ThreadLocal演示，开启两个线程t1、t2，线程t2对threadLocal进行了set，但是并没有改变线程t1本地的threadlocal变量值。明明两个线程调用的同一变量啊，为什么结果不同呢？threadLocal对线程之间进行了隔离。<br>先给个set的流程图，然后在看源码会更加清晰：<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435634.png" alt="ThreadLocal演示.png"></p><p>扒扒底层源码看看到底做了什么？进入threadLocal.set()方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <br>    <span class="hljs-comment">//根据当前线程获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);      <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) <br>        <span class="hljs-comment">//给ThreadLocalMap赋值(ThreadLocal,value)</span><br>        map.set(<span class="hljs-built_in">this</span>, value);           <br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-comment">//从当前Thread类中获取到ThreadLocalMap</span><br>    <span class="hljs-keyword">return</span> t.threadLocals;       <br>&#125;<br><br><span class="hljs-comment">//map.set源码：将map中的key, value组装成一个Entry</span><br><span class="hljs-comment">//而在Entry中继承了WeakReference弱引用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br><br><span class="hljs-comment">//Entry源码：继承了弱引用</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扒完源码之后整理一下threadLocal中set方法的过程。<br>过程：<br>1、获取到当前线程<br>2、从当前线程中获取到自己内部的ThreadLocalMap，别的线程无法访问这个map，<br>3、往ThreadLocalMap值塞值（ThreadLocal，value），塞值的过程中将key和value组装成了一个Entry，继承了弱引用。防止ThreadLocal引用的对象内存泄漏。<br>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><h1 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a><strong>能干嘛</strong></h1><p>典型例子：</p><h2 id="Spring中-Transacion注解中使用到"><a href="#Spring中-Transacion注解中使用到" class="headerlink" title="Spring中@Transacion注解中使用到"></a>Spring中@Transacion注解中使用到</h2><p>Spring的事务管理器通过AOP切入业务代码，在实际开发中使用注解把某个方法标记为支持事务，方法里面调用别的方法，想支持事务所有的这些方法必须要拿到同一个数据库连接，那么这个Connection怎么拿到呢。数据库连接池随便拿一个显然是不行的，上个方法可能拿的另外一个Connection。<br>所以Connection放到了ThreadLocal里面，每个线程都记录一份数据，只要是同一个线程可以随时拿到ThreadLocal，这样无论涉及多少方法的调用，我们都可以保证同一个Connection。<br>当然其实Spring源码中有很多的ThreadLocal，这里只是拿出一个较为由体感的。</p><h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>多层方法间调用线程数据传递。</p><h1 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a><strong>ThreadLocalMap的问题</strong></h1><h2 id="为什么ThreadLocalMap中的key是弱引用"><a href="#为什么ThreadLocalMap中的key是弱引用" class="headerlink" title="为什么ThreadLocalMap中的key是弱引用?"></a><strong>为什么ThreadLocalMap中的key是弱引用?</strong></h2><p><strong>内存泄漏的第一种场景</strong><br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435659.png" alt="ThreadLocal演示.png"><br>上图中，若是用强引用，即使t1&#x3D;null，但ThreadLocalMap的key的引用仍然指向ThreadLocal对象，GC时只会把t1给回收掉，ThreadLocal由于被引用了不会被回收，所以如果这里使用强引用的话会导致内存泄漏。无论怎么样这个key都不会被回收了。<br>所以图示上面为虚线，代表虚引用。</p><h2 id="为什么threadLocal用完必须要进行remove"><a href="#为什么threadLocal用完必须要进行remove" class="headerlink" title="**为什么threadLocal用完必须要进行remove? **"></a>**为什么threadLocal用完必须要进行remove? **</h2><p><strong>内存泄漏的第二种场景</strong><br>由于ThreadLocalMap的中key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，形成了Entry里面的元素就会出现&lt;null,value&gt;的情况。如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，就会发生内存泄露。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435689.png" alt="ThreadLocal演示2.png"><br>get和set源码虽然它们是把整个map  key为null的值全部清理掉，但是还需要remove，因为线程里面可能长期不执行get ，服务器线程一天24h都在跑。另外，假如线程从线程池来的，工作一段在回来，如果ThreadLocal没被清理掉，如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，<strong>记得调用remove方法</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;Person&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Person&gt;();<br><span class="hljs-keyword">try</span> &#123;<br>     threadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>     threadLocal.remove();   <span class="hljs-comment">//threadlocal用完必须要进行remove，不然会导致内存泄漏。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><ul><li>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal</li><li>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。</li><li>适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ali-前置知识-注解</title>
    <link href="/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3/"/>
    <url>/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做WebX的PandoraBoot升级，众所周知，SpringBoot是以注解行天下的，那么极其有必了解一下注解背后的原理、常见的使用方式，这样在面对SpringBoot众多注解时，<strong>既可以快速地了解其作用，也可以快速地找到入口，以此为切点深入了解相关知识。</strong><br>关键三点：1.注解具有继承机制 2.注解默认继承Annotation 3.注解和注解处理器配合工作</p><h1 id="重要的类和接口"><a href="#重要的类和接口" class="headerlink" title="重要的类和接口"></a>重要的类和接口</h1><h2 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h2><p>Represents an annotated element of the program currently running in this VM. This interface allows annotations to be read reflectively.<br>表示目前正在此 VM 中运行的程序的一个已注释元素。这个接口允许通过反射地方式读取注释（注解）。第二句话，明示我们可以通过反射读取任何实现了AnnotatedElement接口的类上的注释。由下图的继承关系。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402911.png" alt="注解AnnotatedElement.png"></p><p>该接口定义了如下方法：（感兴趣的同学，可以研究下各实现类的实现方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; T <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span> <br>   <span class="hljs-comment">// 如果该元素（AnnotatedElement）存在指定类型的注解，则返回这些注解，否则返回 null</span><br>Annotation[] getAnnotations()<br>Annotation[] getDeclaredAnnotations() 忽略继承的注释<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnnotationPresent</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationClass)</span><br></code></pre></td></tr></table></figure><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><p>The common interface extended by all annotation types.<br>所有注解的父亲接口.<br>为什么这么说？举个栗子。我们写个如下的注解，编译以后进行反编译一下。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402928.png" alt="注解Annotation.png"></p><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402963.png" alt="注解Annotation反编译.png"></p><p>可以看到，当我们使用@interface声明一个注解，Java编译器在帮我们编译时，自动继承了Annotation接口，所以说，Annotation是所有注解的父亲接口。所有的类都继承自Object，只不过实现方式有所不同。思考一下，为什要这么做？</p><h1 id="四种基本元注解"><a href="#四种基本元注解" class="headerlink" title="四种基本元注解"></a>四种基本元注解</h1><p>负责注释其它注解，编译器使用元注解作为基本桥梁和普通注解进行沟通。法律的法律叫宪法，注解的注释叫元注解。<br>@Documented –注解是否将包含在JavaDoc中<br>@Retention –什么时候使用该注解<br>@Target –注解用于什么地方<br>@Inherited – 是否允许子类继承该注解</p><h1 id="原理探析"><a href="#原理探析" class="headerlink" title="原理探析"></a>原理探析</h1><h2 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h2><p>a.编译器将源码编译成Class文件时，会对注解符号进行处理，并附加到class结构中<br>b.JVM规范：Class文件结构严格有序，有且仅有attribute属性可以附加信息<br>c.类、字段、方法，在Class结构中都有各自特定的表结构以及各自的attribute属性<br>d.编译器将注解信息附加到相应的类、字段、方法的attribute属性上</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402990.png" alt="注解原理探析1.png"><br>我们把上面的自定义注解添加一些注释(元注解)，然后观察下编译后的Class文件，如图中所示，由于我们使用了四种元注解注释了MyAnnotation类，所以图中红色位置，标出了该类的注解信息。尝试解读一下该信息：<br>#7() 代表 Documented; #9(#10&#x3D;[e#11.#12,e#11.#13,e#11.#14,e#11.#15]) 代表 (value&#x3D;[ElementType.FIELD,ElementType.CONSTRUCTOR,ElementType.TYPE,ElementType.LOCAL_VARIABLE])<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402018.png" alt="注解原理探析2.png"></p><h3 id="再举个爪子"><a href="#再举个爪子" class="headerlink" title="再举个爪子"></a>再举个爪子</h3><p>定义一个默认值为defaultValue的PropertyName注解<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402041.png" alt="注解原理探析3.png"><br>然后定义一个Monkey，该类的name字段上使用了PropertyName注解，看下编译后的Class文件<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402069.png" alt="注解原理探析4.png"><br>可以看到，编译器将PropertyName的注解信息包括“monkey”值附加到了name字段的RuntimeVisibleAnnotations属性中。</p><h2 id="注解获取"><a href="#注解获取" class="headerlink" title="注解获取"></a>注解获取</h2><p>Java编译器将注解信息附加到Class文件的相应RuntimeVisibleAnnotations属性中，那么JVM加载Class文件后，又如何处理？我们要怎么样才能获取到附加的信息？</p><h3 id="JVM的加载"><a href="#JVM的加载" class="headerlink" title="JVM的加载"></a>JVM的加载</h3><p>JVM加载Class文件时，会将RuntimeVisibleAnnotation属性保存到相应的类、字段、方法的Class对象中. 因此，我们可以通过相应的类、字段、方法的Class对象（Class、Method、Field等实现了AnnotatedElement接口），获取到注解对象，进而获取到注解中的属性值。本例中，我们可以通过如下代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">PropertyName</span> <span class="hljs-variable">propertyName</span>  <span class="hljs-operator">=</span> Monkey.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>).getAnnotation(PropertyName.class);<br>        System.out.println(propertyName);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背后隐藏的东西"><a href="#背后隐藏的东西" class="headerlink" title="背后隐藏的东西"></a>背后隐藏的东西</h3><p>通过上文，我们知道注解本质是一个继承了Annotation的特殊接口，而其具体实现类是Java运行时生成的动态代理类。通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法，该方法会从memberValues这个Map中索引出对应的值，memberValues的来源则是Java常量池。</p><h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><h2 id="揭开注解的面纱"><a href="#揭开注解的面纱" class="headerlink" title="揭开注解的面纱"></a>揭开注解的面纱</h2><p>尽管我们知道可以通过反射的方式获取到注解的值，也经常使用注解，但是却少有自己去开发注解。那么，如何去开发一个自己的注解呢？或者说，看到一堆注解，是谁在背后帮我们把注解的信息注入到我们所需要的地方？答案是，注解处理器。比如，Spring注解。</p><p>Spring注解比较多，以SpringBoot的ConfigurationProperties注解为例。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402090.png" alt="注解处理器1.png"></p><p>该注解上面已经给我们标识了注解处理器有哪些，建议以后大家开发注解及注解处理器时也使用这种规范。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301402120.png" alt="注解处理器2.png"></p><p>处理逻辑，显而易见，ConfigurationPropertiesBindingPostProcessor实现了postProcessBeforeInitialization方法，在Spring bean初始化之前，获取bean上的ConfigurationProperties注解的值，进行各种处理，最后将解析后的值注入到bean的属性上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ali-前置知识-反射</title>
    <link href="/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/01/30/Ali-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="功能：在运行中分析类的能力"><a href="#功能：在运行中分析类的能力" class="headerlink" title="功能：在运行中分析类的能力"></a>功能：在运行中分析类的能力</h1><p>简单说就是：只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>java运行时系统始终为所有对象维护一个被称为运行时的类型标识。这个信息跟踪每一个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p><p>保存这些信息的类称为Class。</p><h3 id="1-Class的特点"><a href="#1-Class的特点" class="headerlink" title="1.Class的特点"></a>1.Class的特点</h3><p>（1）没有公共构造方法，Class对象是加载类时由虚拟机以及调用类加载器中的defineClass方法构造的，不能显式声明。<br>（2）每种类型都有唯一一个Class对象。<br>（3）基本类型（int、long、short、float、double、char、byte、boolean）以及void也都对应一个class对象。<br>（4）相同元素类型和维数的数组拥有同一个class对象。</p><h3 id="2-获取Class对象"><a href="#2-获取Class对象" class="headerlink" title="2.获取Class对象"></a>2.获取Class对象</h3><p>（1）Object类中的getClass方法，如：Date d &#x3D; new Date(); Class c1 &#x3D; d.getClass();<br>（2）Class类中的静态方法forName，如：Class c2 &#x3D; Class.forName(“java.util.Date”);<br>（3）设T是一个java类型，则，T.class代表其对应的Class对象，如：Date.class，Double.class</p><h3 id="3-Class类的常用方法"><a href="#3-Class类的常用方法" class="headerlink" title="3.Class类的常用方法"></a>3.Class类的常用方法</h3><p>（1）getName()<br>返回Class类对应实体（类、接口、数组、基本类型、void）的名称，如：<br>java.util.Date.class.getName()返回“java.util.Date”<br>对于数组，返回的名字会比较奇怪，如：Double.class.getName()返回“[Ljava.lang.Double;”<br>int[].class.getName()返回“[I”</p><p>（2）newInstance()<br>Date.class.newInstance()会返回一个Date实例，相当于new Date()，该方法会调用类的无参构造器，如果没有无参构造器会抛出异常。</p><p>（3）getComponentType()<br>返回数组组件类型的Class。比如Double.class.getComponentType()会返回一个Double.class</p><p>（4）getSuperclass()<br>返回Class对应实体的超类的Class</p><p>（5）isArray()<br>判断Class对应的实体是不是一个数组。</p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><h3 id="1-classloader"><a href="#1-classloader" class="headerlink" title="1. classloader"></a>1. classloader</h3><p>classloader用来加载Class文件到JVM，以供程序使用的。java程序可以动态加载类定义，而这个动态加载的机制就是通过ClassLoader来实现的。</p><h4 id="（1）bootstrap（启动）-classloader（类加载器）"><a href="#（1）bootstrap（启动）-classloader（类加载器）" class="headerlink" title="（1）bootstrap（启动） classloader（类加载器）"></a>（1）bootstrap（启动） classloader（类加载器）</h4><p>既然ClassLoader是用来加载类到JVM中的，那么ClassLoader又是如何被加载呢？<br>这是因为存在一个ClassLoader不是用java语言所编写的，而是JVM实现的一部分，这个ClassLoader就是bootstrap classloader（启动类加载器）。<br>这个bootstrap classloader在JVM运行的时候加载java核心的API以满足java程序最基本的需求，其中就包括用户定义的ClassLoader（这里所谓的用户定义是指通过java程序实现的ClassLoader），一个是ExtClassLoader，一个是AppClassLoader。</p><h4 id="（2）ExtClassLoader"><a href="#（2）ExtClassLoader" class="headerlink" title="（2）ExtClassLoader"></a>（2）ExtClassLoader</h4><p>ExtClassLoader，这个ClassLoader是用来加载java的扩展API的，也就是&#x2F;lib&#x2F;ext中的类；</p><h4 id="（3）AppClassLoader"><a href="#（3）AppClassLoader" class="headerlink" title="（3）AppClassLoader"></a>（3）AppClassLoader</h4><p>AppClassLoader，这个ClassLoader是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由AppClassLoader进行加载。</p><h3 id="2-一个程序最基本的类加载流程"><a href="#2-一个程序最基本的类加载流程" class="headerlink" title="2. 一个程序最基本的类加载流程"></a>2. 一个程序最基本的类加载流程</h3><p>当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435410.png" alt="一个程序最基本的类加载流程.png"></p><h3 id="3-ClassLoader使用双亲委托模式进行类加载"><a href="#3-ClassLoader使用双亲委托模式进行类加载" class="headerlink" title="3.ClassLoader使用双亲委托模式进行类加载"></a>3.ClassLoader使用双亲委托模式进行类加载</h3><p>请额外去学习什么是双亲委托模式？<br>参考资料：<a href="http://www.iteye.com/topic/83978?spm=ata.21736010.0.0.3fcc51b6O8Nm0n">http://www.iteye.com/topic/83978</a></p><h3 id="4-补充介绍"><a href="#4-补充介绍" class="headerlink" title="4.补充介绍"></a>4.补充介绍</h3><p>Class.forName(String className) 与ClassLoader.loadClass(String className)的区别？</p><ul><li>Class.forName(String className) ：加载类，并且执行类初始化</li><li>ClassLoader.loadClass(String className)：仅仅加载类，不执行类初始化</li></ul><p>可以通过Class.forName(String name,  boolean initialize,  ClassLoader loader) 第二个参数的赋值，来选择是否初始化类。className是所需类的完全限定名</p><h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><p>在java.lang.reflect包中有三个类Field、Method、Constructor，分别用于描述类的域、方法、构造器。</p><p>Class类中的getFields、getMethods、getConstructors分别返回类的public域、方法、构造器数组，包括超类中的公有成员。getDeclaredFields、getDeclaredMethods、getDeclaredConstructors返回类的全部域、方法、构造器，包括私有和受保护成员，不包括超类成员。</p><h3 id="1-Filed中的方法"><a href="#1-Filed中的方法" class="headerlink" title="1.Filed中的方法"></a>1.Filed中的方法</h3><p>getName()返回域的名称<br>getType()返回域的类型的Class<br>getModifiers()返回public、static、final等修饰符的使用情况，用Modifier中的静态方法解析</p><h3 id="2-Method中的方法"><a href="#2-Method中的方法" class="headerlink" title="2.Method中的方法"></a>2.Method中的方法</h3><p>getName()返回方法名<br>getReturnType()返回方法返回值类型对应的Class<br>getModifiers()同上<br>getParameterTypes()返回传入参数类型对应的Class数组<br>getExceptionTypes()返回方法抛出的异常对应的Class数组</p><h3 id="3-Constructors中的方法"><a href="#3-Constructors中的方法" class="headerlink" title="3.Constructors中的方法"></a>3.Constructors中的方法</h3><p>getName()返回构造器名称<br>getModifiers()同上<br>getParameterTypes()同上<br>getExceptionTypes()同上</p><h2 id="运行时使用反射分析对象"><a href="#运行时使用反射分析对象" class="headerlink" title="运行时使用反射分析对象"></a>运行时使用反射分析对象</h2><p>这段代码演示了如何在运行时查看和修改对象某个域的值，其中setAccessible用于修改权限，因为类A中的域a是私有域，直接访问会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> A.class;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> cl.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> cl.getField(<span class="hljs-string">&quot;b&quot;</span>);<br>        System.out.println(f2.get(z));<br>        <br>        <span class="hljs-comment">// 其中setAccessible用于修改权限，因为类A中的域a是私有域，直接访问会抛出异常。</span><br>        f1.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(f1.get(z));        <br>        f1.set(z, <span class="hljs-number">3</span>);        <br>        System.out.println(f1.get(z));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用反射调用方法"><a href="#利用反射调用方法" class="headerlink" title="利用反射调用方法"></a>利用反射调用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addA</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-built_in">this</span>.a+=x;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aPlusb</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> A.class;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> cl.getMethod(<span class="hljs-string">&quot;addA&quot;</span>, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> cl.getMethod(<span class="hljs-string">&quot;aPlusb&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> Math.class.getMethod(<span class="hljs-string">&quot;sqrt&quot;</span>, <span class="hljs-type">double</span>.class);<br>        System.out.println(z.getA());<br>        f1.invoke(z, <span class="hljs-number">10</span>);<br>        System.out.println(z.getA());<br>        System.out.println(f2.invoke(z));<br>        System.out.println(f3.invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">25.0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为：<br>1<br>11<br>13<br>5.0</p><h1 id="原理：JDK反射实现"><a href="#原理：JDK反射实现" class="headerlink" title="原理：JDK反射实现"></a><strong>原理：JDK反射实现</strong></h1><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>当我们在IDE中编写代码的时候，打一个点号，IDE会自动弹出对应的属性和方法名，当我们在debug的时候，IDE会将方法运行时方法内局部变量和外部实例上属性的值都展示出来，spring中的IOC和AOP，以及一个RPC框架中，我们反序列化，consumer的代理，以及provider的调用都会用到java的反射功能，有人说使用反射会慢，那么到底慢在哪里呢？</p><h2 id="反射类图"><a href="#反射类图" class="headerlink" title="反射类图"></a>反射类图</h2><p>反射使JAVA语言有了动态编译的功能，也就是在我们编码的时候不需要知道对象的具体类型，但是在运行期可以通过Class.forName()获取一个类的class对象，在通过newInstance获取实例。<br>先看下java.lang.reflect包下的几个主要类的关系图，当然动态代理的工具类也在该包下。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435428.png" alt="反射类图.png"></p><ul><li>AnnotatedElement</li></ul><p>作为顶级接口，这个接口提供了获取注解相关的功能，我们在方法，类，属性，构造方法上都可以加注解，所以下面的Field，Method，Constructor都有实现这个接口，以下是我们经常用的两个方法，jdk8以后,接口里面可以通过default修饰方法实现了</p><ul><li>GenericDeclaration</li></ul><p>提供了获取泛型相关的功能，只有方法和构造方法上支持泛型，所以只有Method，Constructor实现了该接口</p><ul><li>Member</li></ul><p>作为一个对象内部方法和属性的声明的抽象，包含了名称，修饰符，所在的类,其中修饰符包含了 static final public private volatile 等，通过一个整数表示，每一个类型在二进制中占一个位</p><ul><li>AccessibleObject</li></ul><p>这是一个类，提供了权限管理的功能，例如是否允许在反射中在外部调用一个private方法，获取一个private属性的值，所以method，constructor,field都继承该类，下面这段代码展示了如何在反射中访问一个私有的成员变量，class对象的构造方法不允许对外</p><h2 id="反射为什么慢"><a href="#反射为什么慢" class="headerlink" title="反射为什么慢"></a>反射为什么慢</h2><p>经过JDK8优化，其实反射的效率并不慢，在某些情况下可能达到和直接调用基本相同的效率，但是在首次执行或者没有缓存的情况下还是会有性能上的开销，主要在以下方面：</p><ol><li>Class.forName(); 会调用本地方法，我们用到的method和field都会在此时加载进来，虽然会进行缓存，但是本地方法免不了有JAVA到C+&#x3D;在到JAVA得转换开销</li><li>class.getMethod()，会遍历该class所有的公用方法，如果没匹配到还会遍历父类的所有方法，并且getMethods()方法会返回结果的一份拷贝，所以该操作不仅消耗CPU还消耗堆内存，在热点代码中应该尽量避免，或者进行缓存</li><li>invoke参数是一个object数组，而object数组不支持java基础类型，而自动装箱也是很耗时的</li></ol><h2 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h2><h3 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h3><p>spring加载bean的流程基本都用到了反射机制</p><ol><li>获取类的实例 通过构造方法getInstance（静态变量初始化，属性赋值，构造方法）</li><li>如果实现了BeanNameAware接口，则用反射注入bean赋值给属性</li><li>如果实现了BeanFactoryAware接口，则设置 beanFactory</li><li>如果实现了ApplicationContextAware，则设置ApplicationContext</li><li>调用BeanPostProcesser的预先初始化方法</li><li>如果实现了InitializingBean,调用AfterPropertySet方法</li><li>调用定制的 init-method()方法 对应的直接 @PostConstruct</li><li>调用BeanPostProcesser的后置初始化完毕的方法</li></ol><h3 id="序列化fastjson"><a href="#序列化fastjson" class="headerlink" title="序列化fastjson"></a>序列化fastjson</h3><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>JDK 提供了一个工具类来动态生成一个代理，允许在执行某一个方法时进行额外的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HWInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>    <span class="hljs-comment">//目标对象</span><br>    <span class="hljs-keyword">private</span> Object target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HWInvocationHandler</span><span class="hljs-params">(Object target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;------插入前置通知代码-------------&quot;</span>);<br>        <span class="hljs-comment">//执行相应的目标方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> method.invoke(target,args);<br>        System.out.println(<span class="hljs-string">&quot;------插入后置处理代码-------------&quot;</span>);<br>        <span class="hljs-keyword">return</span> rs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们分析下这个方法的实现，首先生成的代理对象，需要实现参数里面声明的所有接口，接口的实现应给委托给 **InvocationHandler **进行处理，InvocationHandler 里面可以根据 method 声明判断是否需要做增强，所以所生成的代理类里面必须能够获取到 InvocationHandler，在我们无法知道代理类的具体类型的时候，我们可以通过反射从构造方法里将InvocationHandler传给代理类的实例</p><p>所以总的来说生成代理对象需要两步</p><ol><li>获取代理类的class对象</li><li>通过class对象获取构造方法，通过反射生成代理类的实例，并将InvocationHandler传人</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span><br>    <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>    <br>    Objects.requireNonNull(h);<br><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Look up or generate the designated proxy class.</span><br><span class="hljs-comment">     * 生成代理类</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Invoke its constructor with the designated invocation handler.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取代理类的构造方法</span><br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;<br>        <br>        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    cons.setAccessible(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//获取代理类的实例,并且将invocationhandler传人</span><br>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);<br>        <br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;<br>       ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们在看下 getProxyClass0 如何获取代理类的class对象，这里idk通过WeakCache来缓存已经生成的class对象，因为生成该class通过字节码生成还是很耗时，同时为了解决之前由于动态代理生成太多class对象导致内存不足，所以这里通过弱引用WeakReference来缓存所生成的代理对象class，当发生GC的时候如果该class对象没有其他的强引用将会被直接回收</p><p>生成代理类的class在ProxyGenerator的generateProxyClass方法内实现，该方法返回一个byte[]数组，最后通过一个本地方法加载到虚拟机，所以可以看出生成该对象还是非常耗时的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成字节码数组</span><br><span class="hljs-type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<br>    proxyName, interfaces, accessFlags);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//加载进虚拟机</span><br>    <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,<br>                        proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);<br>&#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A ClassFormatError here means that (barring bugs in the</span><br><span class="hljs-comment">     * proxy class generation code) there was some other</span><br><span class="hljs-comment">     * invalid aspect of the arguments supplied to the proxy</span><br><span class="hljs-comment">     * class creation (such as virtual machine limitations</span><br><span class="hljs-comment">     * exceeded).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e.toString());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] generateClassFile() &#123;<br>    <span class="hljs-built_in">this</span>.addProxyMethod(hashCodeMethod, Object.class);<br>    <span class="hljs-built_in">this</span>.addProxyMethod(equalsMethod, Object.class);<br>    <span class="hljs-built_in">this</span>.addProxyMethod(toStringMethod, Object.class);<br>    Class[] var1 = <span class="hljs-built_in">this</span>.interfaces;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> var1.length;<br><br>    <span class="hljs-type">int</span> var3;<br>    Class var4;<br>    <span class="hljs-keyword">for</span>(var3 = <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>        var4 = var1[var3];<br>        Method[] var5 = var4.getMethods();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> var5.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var7</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var7 &lt; var6; ++var7) &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> var5[var7];<br>            <span class="hljs-built_in">this</span>.addProxyMethod(var8, var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.methods.add(<span class="hljs-built_in">this</span>.generateConstructor());<br>...<br> &#125;<br> <span class="hljs-comment">//生成一个带invocationhandler参数的构造方法</span><br><span class="hljs-keyword">private</span> ProxyGenerator.MethodInfo <span class="hljs-title function_">generateConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    ProxyGenerator.<span class="hljs-type">MethodInfo</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyGenerator</span>.MethodInfo(<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(var1.code);<br>    <span class="hljs-built_in">this</span>.code_aload(<span class="hljs-number">0</span>, var2);<br>    <span class="hljs-built_in">this</span>.code_aload(<span class="hljs-number">1</span>, var2);<br>    var2.writeByte(<span class="hljs-number">183</span>);<br>    var2.writeShort(<span class="hljs-built_in">this</span>.cp.getMethodRef(<span class="hljs-string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>));<br>    var2.writeByte(<span class="hljs-number">177</span>);<br>    var1.maxStack = <span class="hljs-number">10</span>;<br>    var1.maxLocals = <span class="hljs-number">2</span>;<br>    var1.declaredExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">short</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> var1;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的流程可以简单归纳为</p><ol><li>增加hashcode、equals、toString方法</li><li>增加所有接口中声明的未实现方法</li><li>增加一个方法参数为java&#x2F;lang&#x2F;reflect&#x2F;InvocationHandler的构造方法</li><li>其他静态初始化数据</li></ol><h2 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h2><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>Spring AOP 默认基于jdk动态代理来实现，我们来看下下面这个经典的面试问题：<br><em>一个类里面，两个方法A和方法B，方法B上有加注解做事务增强，那么A调用this.B为什么没有事务效果？</em><br>因为 Spring AOP 默认基于jdk的动态代理实现，最终执行是通过生成的代理对象的，而代理对象执行A方法和B方法其实是调用的InvocationHandler里面的增强后的方法；<br>其中B方法是经过InvocationHandler做增强，在方法前后增加了事务开启和提交的代码，而真正执行代码是通过methodB.invoke(原始对象)；<br>    而A方法的实现内部虽然包含了this.B方法，但其实是调用了methodA.invoke(原始对象)，而这一句代码相当于调用的是原始对象的methodA方法，而这里面的this.B()方法其实是调用的原始对象的B方法，没有进行过事物增强，而如果是通过cglib做字节码增强，生成这个类的子类，这种调用this.B方法是有事务效果的。<br><img src="https://gitee.com/mapple333/obsidian_server/raw/master/202301301435468.png" alt="动态代理1.png"></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>有过RMI开发经验的人可能会很熟悉，为什么在对外export RMI服务的时候会分别在client和server生成两个stub文件，其中client的文件其实就是用动态代理生成了一个代理类<br>    这个代理类实现了所要对外提供服务的所有接口，每个方法的实现其实就是将接口信息、方法声明、参数、返回值信息通过网络发给服务端，而服务端收到请求后通过找到对应的实现，然后用反射method.invoke 进行调用，然后将结果返回给客户端；<br>其实其他的RPC框架的实现方式大致和这个类似，只是客户端的代理类，可能不仅要将方法声明通过网络传输给服务提供方，也可以做一下服务路由、负载均衡、以及传输一些额外的attachment数据给provider</p>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ali-数据结构与算法</title>
    <link href="/2023/01/29/Ali-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2023/01/29/Ali-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组（Array）是有限个<strong>相同类型</strong>的变量所组成的<strong>有序集合</strong>，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。<br>数组下标从零开始(Why)<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291308037.png"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>数组用一组连续的内存空间来存储一组具有相同类型的数据<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291309267.png"></p><p>(模拟内存存储)</p><p>灰色格子：被使用的内存</p><p>橙色格子：空闲的内存</p><p>红色格子：数组占用的内存</p><p>数组可以根据下标随机访问数据</p><p>比如一个整型数据 int[] 长度为5<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291319298.png"></p><p>假设首地址是：1000</p><p>int是4字节（32位）,实际内存存储是位</p><p>随机元素寻址：a[i]_address&#x3D;a[0]_address+i*4</p><p>该公式解释了三个方面</p><ul><li><strong>连续性分配</strong></li><li><strong>相同的类型</strong></li><li><strong>下标从0开始</strong></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>读取元素<br>根据下标读取元素的方式叫作随机读取<br>int n&#x3D;nums[2]</p><p>更新元素<br>nums[3]&#x3D; 10;</p><p>注意不要数组越界<br>读取和更新都可以随机访问，时间复杂度为O(1)</p><p>插入元素<br>有三种情况：<br>尾部插入<br>在数据的实际元素数量小于数组长度的情况下：<br>直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291318331.png"></p><p>a[6]&#x3D;10</p><p>中间插入<br>在数据的实际元素数量小于数组长度的情况下：<br>由于数组的每一个元素都有其固定下标，所以首先把插入位置及后面的元素向后移动，腾出地方，<br>再把要插入的元素放到对应的数组位置上。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291319973.png"></p><p>超范围插入<br>假如现在有一个数组，已经装满了元素，这时还想插入一个新元素，或者插入位置是越界的<br>这时就要对原数组进行扩容：可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素统统复制过去，这样就实现了数组的扩容。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291320296.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numsNew=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length*<span class="hljs-number">2</span>];<br>System.arraycopy(nums,<span class="hljs-number">0</span>,numsNew,<span class="hljs-number">0</span>,nums.length);<br><span class="hljs-comment">// 原数组就丢掉了，资源浪费</span><br>nums=numsNew;<br></code></pre></td></tr></table></figure><p>删除元素<br>数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动1位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p;i&lt;nums.length;i++)&#123;<br>nums[i-<span class="hljs-number">1</span>]=nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo1</span> &#123;<br><span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDemo1</span><span class="hljs-params">()</span> &#123;<br>nums[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>nums[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>nums[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>nums[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>nums[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;<br>nums[<span class="hljs-number">5</span>] = <span class="hljs-number">9</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-keyword">return</span> nums[i];<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    nums[i] = n;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertTail</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>nums[<span class="hljs-number">6</span>] = n;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>; i &gt;= p-<span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-comment">//能取得值</span><br><span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>nums[i+<span class="hljs-number">1</span>]=nums[i];<br>&#125;<br>&#125;<br>nums[p-<span class="hljs-number">1</span>]=n;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 旧数组复制到新数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span>[] numsNew=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length*<span class="hljs-number">2</span>];<br>System.arraycopy(nums,<span class="hljs-number">0</span>,numsNew,<span class="hljs-number">0</span>,nums.length);<br>nums=numsNew;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertOutOfBounds</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-comment">//数组扩容</span><br>resize();<br>nums[p-<span class="hljs-number">1</span>]=n;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p;i&lt;nums.length;i++)&#123;<br>nums[i-<span class="hljs-number">1</span>]=nums[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>System.out.println(n);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>System.out.println(nums[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ArrayDemo1</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDemo1</span>();<br>demo1.deleteMiddle(<span class="hljs-number">3</span>);<br>    demo1.display();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>读取和更新都是随机访问，所以是O(1)<br>插入数组扩容的时间复杂度是O(n)，插入并移动元素的时间复杂度也是O(n)，综合起来插入操作的时间复杂度是O(n)。<br>删除操作，只涉及元素的移动，时间复杂度也是O(n)</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素<br>缺点：<br>插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。 (ArrayList LinkedList )<br>申请的空间必须是连续的，也就是说即使有空间也可能因为没有足够的连续空间而创建失败<br>如果超出范围，需要重新申请内存进行存储，原空间就浪费了</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>数组是基础的数据结构，应用太广泛了，ArrayList、Redis、消息队列等等。<br>数据结构和算法的可视化网站：</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈和队列都属于线性数据的逻辑存储结构<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291327683.png"></p><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>栈（stack）是一种线性数据结构，栈中的元素只能先入后出（First In Last Out，简称FILO）。<br>最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶 （top）。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291331138.png"></p><h2 id="存储原理-1"><a href="#存储原理-1" class="headerlink" title="存储原理"></a>存储原理</h2><p>栈既可以用数组来实现，也可以用链表来实现<br>栈的数组实现如下：<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291333062.png"><br>数组实现的栈也叫顺序栈或静态栈<br>栈的链表实现如下：<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291333786.png"><br>链表实现的栈也叫做链式栈或动态栈</p><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="入栈（压栈）"><a href="#入栈（压栈）" class="headerlink" title="入栈（压栈）"></a>入栈（压栈）</h3><p>入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291334598.png"></p><h3 id="出栈（弹栈）"><a href="#出栈（弹栈）" class="headerlink" title="出栈（弹栈）"></a>出栈（弹栈）</h3><p>出栈操作（pop）就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301291335120.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 数组实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums; <span class="hljs-comment">// 数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 栈中元素个数</span><br><span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-built_in">this</span>.nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 入栈操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。 没有扩容</span><br><span class="hljs-comment">// nums.len*2 arraycopy</span><br><span class="hljs-keyword">if</span> (count &gt;= nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span><br>nums[count] = n;<br>count++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 出栈操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 栈为空，则直接返回0</span><br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums[count-<span class="hljs-number">1</span>];<br>count--;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>ArrayStack as=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStack</span>(<span class="hljs-number">8</span>);<br>as.push(<span class="hljs-number">3</span>);<br>as.push(<span class="hljs-number">5</span>);<br>as.push(<span class="hljs-number">1</span>);<br>as.push(<span class="hljs-number">4</span>);<br>System.out.println(as.pop());<br>System.out.println(as.pop());<br>System.out.println(as.pop());<br>System.out.println(as.pop());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 链表节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> value;<br>Node next;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-built_in">this</span>.value = value;<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 链表实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinedStack</span> &#123;<br><span class="hljs-type">int</span> size;<br>Node head; <span class="hljs-comment">//头节点</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 初始化</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinedStack</span><span class="hljs-params">()</span> &#123;<br>head = <span class="hljs-literal">null</span>;<br>size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 入栈</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//head</span><br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>head = node;<br>&#125;<br><span class="hljs-comment">//非head</span><br><span class="hljs-keyword">else</span> &#123;<br>node.next = head;<br>head = node;<br>&#125;<br>size++;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 出栈</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> Node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">oldHead</span> <span class="hljs-operator">=</span> head;<br>head = head.next;<br>size--;<br><span class="hljs-keyword">return</span> oldHead;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Node n1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>Node n2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>Node n3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>Node n4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>LinedStack ls=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinedStack</span>();<br>ls.push(n1);<br>ls.push(n2);<br>ls.push(n3);<br>ls.push(n4);<br>System.out.println(ls.pop().value);<br>System.out.println(ls.pop().value);<br>System.out.println(ls.pop().value);<br>System.out.println(ls.pop().value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>入栈和出栈的时间复杂度都是O(1)<br>支持动态扩容的顺序栈<br>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组，通过前面学过的知识，可以得知入栈的时间复杂度是O(n)</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>每进入一个函数，就会将临时变量作为一个栈入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈</p><h3 id="浏览器的后退功能"><a href="#浏览器的后退功能" class="headerlink" title="浏览器的后退功能"></a>浏览器的后退功能</h3><p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。<br>链表中数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。（百度百科）<br>常见的链表包括：单链表、双向链表、循环链表</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单向链表的每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300910099.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表的每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920958.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node next;<br>    Node prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>链表的尾节点指向头节点形成一个环，称为循环链表<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920929.png"></p><h2 id="存储原理-2"><a href="#存储原理-2" class="headerlink" title="存储原理"></a>存储原理</h2><p>数组在内存中的存储方式是顺序存储（连续存储），链表在内存中的存储方式则是随机存储（链式存储）。<br>链表的每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920052.png"></p><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><p>在查找元素时，链表只能从头节点开始向后一个一个节点逐一查找。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920026.png"></p><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>找到要更新的节点，然后把旧数据替换成新数据<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920559.png"></p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><h4 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h4><p>把最后一个节点的next指针指向新插入的节点即可<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920456.png"></p><h4 id="头部插入"><a href="#头部插入" class="headerlink" title="头部插入"></a>头部插入</h4><p>第1步，把新节点的next指针指向原先的头节点<br>第2步，把新节点变为链表的头节点<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300921739.png"></p><h4 id="中间插入"><a href="#中间插入" class="headerlink" title="中间插入"></a>中间插入</h4><p>第1步，新节点的next指针，指向插入位置的节点<br>第2步，插入位置前置节点的next指针，指向新节点<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300921898.png"><br>只要内存空间允许，能够插入链表的元素是无限的，不需要像数组那样考虑扩容的问题</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><h4 id="尾部删除"><a href="#尾部删除" class="headerlink" title="尾部删除"></a>尾部删除</h4><p>把倒数第2个节点的next指针指向空即可<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300921270.png"></p><h4 id="头部删除"><a href="#头部删除" class="headerlink" title="头部删除"></a>头部删除</h4><p>把链表的头节点设为原先头节点的next指针即可<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300922051.png"></p><h4 id="中间删除"><a href="#中间删除" class="headerlink" title="中间删除"></a>中间删除</h4><p>把要删除节点的前置节点的next指针，指向要删除元素的下一个节点即可<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300920979.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 单链表</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> &#123;<br><span class="hljs-comment">//初始化头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加节点：从头插入</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//从头插入</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//到尾节点</span><br><span class="hljs-keyword">if</span> (tmp.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//后移一个节点</span><br>tmp = tmp.next;<br>&#125;<br>tmp.next = node;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addByIdOrder</span><span class="hljs-params">(Node node)</span>&#123;<br><span class="hljs-comment">//从头插入</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//到尾节点</span><br><span class="hljs-keyword">if</span> (tmp.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//节点存在</span><br><span class="hljs-keyword">if</span> (tmp.next.id == node.id) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (tmp.next.id &gt; node.id) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>tmp = tmp.next;<br>&#125;<br><span class="hljs-comment">//交换位置</span><br>node.next = tmp.next;<br>tmp.next = node;<br>&#125;<br><span class="hljs-comment">//遍历链表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showList</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//空链表</span><br><span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.println(temp);<br><span class="hljs-comment">//指针下移</span><br>temp = temp.next;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Node n1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张飞&quot;</span>);<br>Node n2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;关羽&quot;</span>);<br>Node n3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;赵云&quot;</span>);<br>Node n4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;黄忠&quot;</span>);<br>Node n5=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;马超&quot;</span>);<br>SingleLinkedList sll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleLinkedList</span>();<br>sll.addByIdOrder(n4);<br>sll.addByIdOrder(n5);<br>sll.addByIdOrder(n1);<br>sll.addByIdOrder(n2);<br>sll.addByIdOrder(n3);<br>sll.showList();<br>&#125;<br>&#125;<br><span class="hljs-keyword">package</span> com.lagou.line.linkedlist;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> id;<br>String name;<br><span class="hljs-comment">//下一个节点</span><br>Node next;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br><span class="hljs-string">&quot;id=&quot;</span> + id +<br><span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">package</span> com.lagou.line.linkedlist;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node2</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>String name;<br><span class="hljs-comment">//下一个节点</span><br>Node2 next;<br><span class="hljs-comment">//上一个节点</span><br>Node2 prev;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node2</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br><span class="hljs-string">&quot;id=&quot;</span> + id +<br><span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>查找节点 ： O(n)<br>插入节点：O(1)<br>更新节点：O(1)<br>删除节点：O(1)</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优势<br>插入、删除、更新效率高<br>省空间<br>劣势<br>查询效率较低，不能随机访问</p><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><p>链表的应用也非常广泛，比如树、图、Redis的列表、LRU算法实现、消息队列等</p><h2 id="数组和链表对比"><a href="#数组和链表对比" class="headerlink" title="数组和链表对比"></a>数组和链表对比</h2><p>数据结构没有绝对的好与坏，数组和链表各有千秋。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300924618.png"><br><strong>数组的优势在于能够快速定位元素，对于读操作多、写操作少的场景来说，用数组更合适一些</strong><br><strong>链表的优势在于能够灵活地进行插入和删除操作，如果需要在尾部频繁插入、删除元素，用链表更合适一些</strong><br><strong>数组和链表是线性数据存储的物理存储结构：即顺序存储和链式存储。</strong></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>队列（queue）是一种线性数据结构，队列中的元素只能<strong>先入先出</strong>（First In First Out，简称 FIFO）。<br>区别于栈：栈（stack）是一种线性数据结构，栈中的元素只能<strong>先入后出</strong>（First In Last Out，简称FILO）。<br>队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300924743.png"><br>像一个单向阀！！！</p><h2 id="存储原理-3"><a href="#存储原理-3" class="headerlink" title="存储原理"></a>存储原理</h2><p>队列这种数据结构既可以用数组来实现，也可以用链表来实现</p><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><p><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300922296.png"><br>用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的下一个位置<br>用数组实现的队列叫作顺序队列</p><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><p><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300922005.png"><br>用链表实现的队列叫作链式队列</p><h2 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h2><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300924661.png"></p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>出队操作（dequeue）就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。<br><img src="https://raw.githubusercontent.com/mappleBlack/picture/main/image202301300912489.png"></p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="数组实现-2"><a href="#数组实现-2" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用数组实现的队列</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br><span class="hljs-comment">// 数组：items，数组大小：n</span><br><span class="hljs-type">int</span>[] nums;<br><span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br><span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 申请一个大小为capacity的数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>&#125;<br><span class="hljs-comment">// 入队</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span><br><span class="hljs-keyword">if</span> (tail == nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>nums[tail] = n;<br>++tail;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 出队</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 如果head == tail 表示队列为空</span><br><span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> nums[head];<br>++head;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>ArrayQueue aq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayQueue</span>(<span class="hljs-number">8</span>);<br>aq.enqueue(<span class="hljs-number">3</span>);<br>aq.enqueue(<span class="hljs-number">5</span>);<br>aq.enqueue(<span class="hljs-number">1</span>);<br>aq.enqueue(<span class="hljs-number">4</span>);<br>System.out.println(aq.dequeue());<br>System.out.println(aq.dequeue());<br>System.out.println(aq.dequeue());<br>System.out.println(aq.dequeue());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表实现-2"><a href="#链表实现-2" class="headerlink" title="链表实现"></a>链表实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.lagou.line.queue.Node;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 链表实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span> &#123;<br>Node head;<br>Node tail;<br><span class="hljs-type">int</span> size;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node node)</span>&#123;<br><span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">null</span>)&#123;<br>head = node;<br>tail=node;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>tail.next = node;<br>tail = node;<br>&#125;<br>size++;<br>    &#125;<br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">dequeue</span> <span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-comment">//将拉取的节点的下一个节点变成新的表头</span><br>head = head.next;<br><span class="hljs-comment">//把旧的表头的下一个节点指向设置为null，让gc回收</span><br>h.next = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//队列为空</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)<br>tail = <span class="hljs-literal">null</span>;<br>size--;<br><span class="hljs-keyword">return</span> h;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Node n1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>Node n2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>Node n3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>Node n4=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>LinkedQueue lq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedQueue</span>();<br>lq.enqueue(n1);<br>lq.enqueue(n2);<br>lq.enqueue(n3);<br>lq.enqueue(n4);<br>System.out.println(lq.dequeue().value);<br>System.out.println(lq.dequeue().value);<br>System.out.println(lq.dequeue().value);<br>System.out.println(lq.dequeue().value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>入队和出队都是O(1)</p><h2 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h2><p>资源池、消息队列、命令队列等等</p>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 用户手册</title>
    <link href="/2023/01/12/Hexo-Fluid-%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/"/>
    <url>/2023/01/12/Hexo-Fluid-%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>主题教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈数字化转型及软件定义汽车</title>
    <link href="/2023/01/12/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%B1%BD%E8%BD%A6/"/>
    <url>/2023/01/12/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%B1%BD%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="浅谈数字化转型及软件定义汽车"><a href="#浅谈数字化转型及软件定义汽车" class="headerlink" title="浅谈数字化转型及软件定义汽车"></a>浅谈数字化转型及软件定义汽车</h3><p>​数字化转型培训上半场即将结束，在经历了宁波中软的java基础培训及java进阶培训后，来到杭州阿里进行进一步学习。在宁波阶段，我们更像是在修炼武功招式，到了阿里，我们更多要进行内功心法的修炼。</p><p>​在宁波阶段，我们学习了java基础以及前后端很多的框架以及中间件，基本达到了可以应用的水平。但是对于底层的概念、逻辑理解还是很欠缺，急需建立自己的第二大脑，将零散的知识点网格化。</p><p>​在阿里阶段，近一个月的时间，好比是各门派小弟子，来到了光明顶，看阿里的“武林高手”精彩过招。得到了因为相信，所以看见的理念；学习了数字化经济时代的用户营销、汽车企业数字化转型、达摩院高精尖技术、软件定义汽车等等先进概念。</p><p>​半年前，我们带着集团数字化转型的使命而来；希望半年后，我们能带着丰硕的转型结果凯旋而归。</p><p>​随着新一代信息技术发展势头强劲，已经深入了社会的方方面面。数据已经作为新的生产要素，作用日益显著。产业数字化成为必然选择，企业抓住这个机会窗口，实现数字化转型，将对企业发挥重大作用，不仅仅是创新能力加强、生产效率提升、产品质量改进、成本降低、能效提升等，更重要的是能够通过对客户提供更优质的服务实现企业的可持续发展。</p><p>​数字化转型和管理变革最优先的任务有两个：流程重构“业务流程化”和业务在线“流程数字化”，把企业搬到线上。不是简单的复制而是从业务需求出发，融合流程和IT，再造业务流程、优化组织、建设IT。</p><p>​数字化转型并不是单一的企业信息数字化，而是让IT使能管理、生产、销售、人员各个环节都能起到重要作用，而且必须是长期主义。</p><h4 id="数字化转型的3个关键点"><a href="#数字化转型的3个关键点" class="headerlink" title="数字化转型的3个关键点"></a>数字化转型的3个关键点</h4><p>​1 建立数字化转型中枢组织</p><p>​构建最高级别的顶层架构是推动转型的基础。制定内部计划，加快数字化组织的打造和转型。</p><p>​2 聚焦主航道</p><p>​要破除发展路上核心遇到的问题，遇山开山，遇水渡船。只要把主航道经营好，需要具备哪些能力，完成哪些工作，就要针对性的对症下药。不断积累经验，完善自己的版图。</p><p>​3 瞄准业务场景作战</p><p>​场景是开辟战场的利器。不断的选择好的场景就相当于增加了新的市场，它往往带来了新的增量。也是数字化转型中，很重要的一部分，无论流程渠道、数据驱动、智能驱动，都离不开场景。</p><h4 id="关于软件定义汽车的理解"><a href="#关于软件定义汽车的理解" class="headerlink" title="关于软件定义汽车的理解"></a>关于软件定义汽车的理解</h4><p>​在阿里老师讲到软件第一汽车这一课，先提出了一个问题：车企的核心是什么？</p><p>​虽然特斯拉在制造质量等细节方面落后于老牌车企，但这些问题都是可以解决的，该公司在软件、电池和自动驾驶领域的领先地位都是持久的优势，特斯拉可以利用软件来提高车辆的实用性并提升盈利潜力。</p><p>​追赶（特斯拉）的难点不在于电动化，而在于特斯拉在自动驾驶和软件方面领先于全球所有车企。</p><p>​车企之间要比的是如何让自己的产品适合市场的需求，比的是企业的一把手对底层技术逻辑的判断和对市场的判断，以及对消费者真正需求的判断。如今我们不用猜测用户在想什么事情，有什么消费习惯，只需要从大数据中找到答案即可</p><p>​特斯拉“用软件定义汽车”的slogan表明了深耕汽车智能化领域的决心，其产品的核心竞争力也在智能化上深度呈现。特斯拉在软件领域的优势极为明显。凯捷咨询公司的Rainer Mehl称特斯拉汽车是套着汽车外壳的“内部软件和应用程序”。</p><h5 id="更好的舒适性、安全性"><a href="#更好的舒适性、安全性" class="headerlink" title="更好的舒适性、安全性"></a>更好的舒适性、安全性</h5><p>​大量软件的使用，使车辆变得更加智能，智能座舱的出现使驾乘体验更加舒适。车辆传感器、摄像头的大量使用，使车辆更加“聪明”，随着软件技术的发展，自动驾驶会越来越接近L5，彻底解放劳动力，让人们把时间花在更有意义的事情上。同时，自动驾驶提高由于人为因素带来的驾驶安全性。</p><p>​当与行驶相关的场景被完善到一定程度后, 车内场景将向更加丰富、更加生活化的方向延伸——从基本的定位&#x2F;导航&#x2F;影音娱乐, 扩展到出行前后的消费性体验, 例如行程规划、预约、订餐、支付等功能。而针对这些新需求, 未来的智能座舱将需要更多的传感器、更多样的车载软件、云平台的介入、以及更强大的连网与运算能力。</p><p>​但眼下，如何让驾驶人员逐渐放开双手, 把时间“腾出来”，是目前智能座舱需要克服的问题。毕竟，在自动驾驶尚未到达L4&#x2F;L5级的情况下, 一辆汽车无论如何都还是要有一位驾驶者的，“他的时间，会随着自动驾驶技术的成熟，逐渐成为全新的未开发地带。”</p><h5 id="商业模式的变化"><a href="#商业模式的变化" class="headerlink" title="商业模式的变化"></a>商业模式的变化</h5><p>​在原来的模式中，卖车是“卖硬件挣钱的一锤子买卖”。车企的盈利主要靠卖硬件获得。软件定义汽车后，汽车成了另外一个生态，卖车不再使一锤子买卖，越来越多的OTA技术，使汽车功能更改丰富，性能更加稳定。一辆车卖出去之后才是开始盈利的起点，软件为用户提供更多的定制化服务。</p><h5 id="第三智能生态"><a href="#第三智能生态" class="headerlink" title="第三智能生态"></a>第三智能生态</h5><p>​车机功能的丰富以及使用的体验提高，使汽车成为了除了PC、手机外的第三智能生态。未来消费者可以基于车辆位置信息，实现信息、娱乐、订餐、互联等功能的融合，这与智能手机的进化路线有着惊人的一致。</p><p>​参与数智化转型培训半年，可能以后的人生轨迹和职业规划都会发生翻天覆地的变化。对于我个人，这是一次新的起跑。感谢集团提供如此宝贵的机会，能够在而立之年再次重新出发。每个人为转型都舍弃了很多，也得到了很多。希望每个人都能尽最大努力坚持。学习完成后，学有所成，为集团的数字化转型工作贡献自己的力量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>思想感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记整理-20230111</title>
    <link href="/2023/01/11/java%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86-20230111/"/>
    <url>/2023/01/11/java%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86-20230111/</url>
    
    <content type="html"><![CDATA[<h1 id="Java笔记整理"><a href="#Java笔记整理" class="headerlink" title="Java笔记整理"></a>Java笔记整理</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li><strong>Java 语言有哪些特点</strong></li></ul><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系 统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程 支持）；</li><li>支持网络编程并且很方便</li><li>编译与解释并存；</li></ol><ul><li><p><strong>面向对象和面向过程的区别</strong></p><p><strong>面向过程 ：</strong></p><p> <strong>优点：</strong> 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗 资源;比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发，性能是最重要的因素。</p><p> <strong>缺点：</strong> 没有面向对象易维护、易复用、易扩展</p><p><strong>面向对象 ：</strong></p><p> <strong>优点：</strong> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特 性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p> <strong>缺点：</strong> 性能比面向过程低</p></li><li><p><strong>字符型常量和字符串常量的区别</strong></p><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的 若干个字符</p><p>含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式，运算字符串常量代表一个地址值(该字符串在内存中存放位置)</p><p>占内存大小：字符常量只占 2 个字节（char 在 Java 中占两个字节）， 字符串常量占若干个字节</p></li><li><p><strong>构造器 Constructor 是否可被 override</strong></p><p>父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）</p></li><li><p><strong>&#x3D;&#x3D;重载和重写的区别&#x3D;&#x3D;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> **重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序 不同，方法返回值和访问修饰符可以不同，发生在编译时。 </span><br><span class="line"> </span><br><span class="line"> **重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父 类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 </span><br><span class="line">123</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么要使用封装？</strong></p><p> 隐藏对象内部的复杂性，确保数据安全 ， 防止误操作，只对外公开简单的接口，便于外界使用</p></li><li><p><strong>java为什么类不支持多继承，接口可以？</strong></p><p> Java中的接口支持多继承（接口与接口之间为继承关系），因为接口不提供具体实现方式，只是一种规范，所以支持；&#x3D;&#x3D;Java的类不支持多继承的原因是Java是强类型语言，多继承会导致调用的不确定性，编译器无法确定要调用哪个类方法，甚至在调用哪个类方法时也无法确定优先级。&#x3D;&#x3D;</p></li><li><p><strong>接口和抽象类的区别是什么</strong></p></li></ul><ol><li>接口的方法默认是 public，&#x3D;&#x3D;所有方法在接口中不能有实现&#x3D;&#x3D;(Java 8 开始 接口方法可以有默认实现），抽象类可以有非抽象的方法</li><li>接口中不能包含变量，所有的变量都是常量，默认为public static final类型的，而抽象类中则不一定</li><li>接口可以多继承，抽象类只能单一集成</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>&#x3D;&#x3D;接口是没有构造器的，不能用 new 实例化&#x3D;&#x3D;，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，&#x3D;&#x3D;抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><ul><li><strong>成员变量与局部变量的区别有那些</strong></li></ul><ol><li>从语法形式上，看&#x3D;&#x3D;成员变量是属于类的&#x3D;&#x3D;，而局部变量是在方法中定义的变量或是方法的参数，成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是成员变量和局部变量都能被 final 所修饰；</li><li>从变量在内存中的存储方式来看，&#x3D;&#x3D;成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存&#x3D;&#x3D;</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>&#x3D;&#x3D;成员变量如果没有被赋初值，则会自动以类型的默认值而赋值&#x3D;&#x3D;（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部&#x3D;&#x3D;变量则不会自动赋值。&#x3D;&#x3D;</li></ol><ul><li><strong>对象的相等与指向他们的引用相等，两者有什么不同？</strong></li></ul><p> &#x3D;&#x3D;【nice】对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><ul><li><strong>Java 中的异常处理</strong></li></ul><p> 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 &#x3D;&#x3D;Throwable 类&#x3D;&#x3D;。</p><p> Throwable： 有两个重要的子类：&#x3D;&#x3D;Exception（异常）&#x3D;&#x3D; 和 &#x3D;&#x3D;Error（错 误）&#x3D;&#x3D; ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p> <strong>Error（错误）</strong>:是程序无法处理的错误，表示运行应用程序中较严重问题。大 多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟 机）出现的问题。</p><p> *<em>Exception（异常）😗</em>是程序本身可以处理的异常。</p><p> <strong>注：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</strong></p><ul><li><p><strong>在以下 4 种特殊情况下，finally 块不会被执行</strong></p><ol><li>在 finally 语句块中发生了异常。、</li><li>在前面的代码中用了 &#x3D;&#x3D;System.exit()退出程序&#x3D;&#x3D;。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol></li><li><p><strong>获取用键盘输入常用的的两种方法</strong></p><p>方法 1：通过 Scanner</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p> &#x3D;&#x3D;方法 2：通过 BufferedReader&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h1 id="一、集合框架"><a href="#一、集合框架" class="headerlink" title="一、集合框架"></a>一、集合框架</h1><p>#集合<br>![](imagePasted image 20230110102817.png)</p><h2 id="大纲："><a href="#大纲：" class="headerlink" title="大纲："></a>大纲：</h2><blockquote><p>Java集合可以分为Collection和Map两种体系：</p><p>Collection接口：</p><p>&#x3D;&#x3D;List：元素有序，可重复的集合&#x3D;&#x3D;</p><pre><code>    ArrayList： 底层数组实现,有利于随机访问get    LinkedList：底层是链表，有利于频繁的插入、删除操作(ArrayList删除和插入要扩容，浪费性能)    Vector：古老的实现类，线程安全的，性能较差，效率低于ArrayList，不建议使用</code></pre><p>&#x3D;&#x3D;Set：元素无序、不可重复的集合&#x3D;&#x3D;</p><pre><code>    LinkedHashSet：使用链表维护了一个添加进集合中的顺序。</code></pre><p>注：&#x3D;&#x3D;要求添加进Set元素所在的类，一定要重写equals()和hashCode()方法&#x3D;&#x3D;</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol><li><h5 id="List集合实现类ArrayList底层采用数组实现，学习ArrayList源码前先了解数组的扩容机制"><a href="#List集合实现类ArrayList底层采用数组实现，学习ArrayList源码前先了解数组的扩容机制" class="headerlink" title="List集合实现类ArrayList底层采用数组实现，学习ArrayList源码前先了解数组的扩容机制"></a>List集合实现类ArrayList底层采用数组实现，学习ArrayList源码前先了解数组的扩容机制</h5><blockquote><p>数组的两种扩容方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 数组扩容，用Arrays.copyOf方法</span></span><br><span class="line"><span class="comment">  * 底层用的也是System.arraycopy</span></span><br><span class="line"><span class="comment">  * System.arraycopy(原数组, 0, 需要扩容的新数组, 0, Math.min(original.length,newLength));</span></span><br><span class="line"><span class="comment">  * 参数Math.min()：返回最小数,即需要扩容的内容数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Object[] newObjects = Arrays.copyOf(objects, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(newObjects));</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * System.arraycopy:底层数组copy技术,该方法用native修饰</span></span><br><span class="line"><span class="comment">  * 参数：src：原数组</span></span><br><span class="line"><span class="comment">  *      srcPos：原数组的起始位置；即从原数组的起始位置开始复制</span></span><br><span class="line"><span class="comment">  *      dest：目标数组</span></span><br><span class="line"><span class="comment">  *      destPos：目标数组起始位置；即从目标组的起始位置往里复制</span></span><br><span class="line"><span class="comment">  *      length：复制长度；即需要从原数组复制到目标数组的个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span>[] fun = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">System.arraycopy(fun, <span class="number">3</span>, fun, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(Arrays.toString(fun));</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure></li><li><h5 id="JDK1-7以后，ArrayList数组默认初始化大小放在add方法内-无参构造方法默认为一个空数组-有参构造方法可以指定其数组长度"><a href="#JDK1-7以后，ArrayList数组默认初始化大小放在add方法内-无参构造方法默认为一个空数组-有参构造方法可以指定其数组长度" class="headerlink" title="JDK1.7以后，ArrayList数组默认初始化大小放在add方法内,无参构造方法默认为一个空数组,有参构造方法可以指定其数组长度"></a>JDK1.7以后，ArrayList数组默认初始化大小放在add方法内,无参构造方法默认为一个空数组,有参构造方法可以指定其数组长度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化时默认为空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elementData：ArrayList存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法默认为一个空数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定长度的有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure></li><li><h5 id="ArrayList数组默认初始化大小为10"><a href="#ArrayList数组默认初始化大小为10" class="headerlink" title="ArrayList数组默认初始化大小为10"></a>ArrayList数组默认初始化大小为10</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><h5 id="ArrayList中可以存放null"><a href="#ArrayList中可以存放null" class="headerlink" title="ArrayList中可以存放null"></a>ArrayList中可以存放null</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList中需要存放的元素为泛型，故可以存放null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">//扩容方法  </span></span><br><span class="line">    elementData[size++] = e;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><h5 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList中元素的具体个数，数组长度不等于元素个数</span></span><br><span class="line"><span class="comment">//扩容需要用到该属性，当size == elementData.length时，触发扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></li><li><h5 id="ArrayList中elementData为什么被transient修饰？"><a href="#ArrayList中elementData为什么被transient修饰？" class="headerlink" title="ArrayList中elementData为什么被transient修饰？"></a>ArrayList中elementData为什么被transient修饰？</h5><blockquote><p><strong>一、transient修饰符基本概念：</strong></p><p>transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。</p><p>transient用于修饰不需要序列化的字段，如果一个引用类型被transient修饰，则其反序列化的值为null，如果一个基本类型被transient修饰，则其反序列化的值为0，如果字段的引用类型是不可序列化的类，则也应该使用transient修饰，它在序列化时会被直接跳过。</p><p><strong>二、elementData用transient修饰：</strong></p><p>ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。</p><p><strong>三、为什么不直接用elementData来序列化，而采用上述的方式来实现序列化呢？</strong></p><p>原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上述的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</p></blockquote></li><li><h5 id="序列化性能比较"><a href="#序列化性能比较" class="headerlink" title="序列化性能比较"></a>序列化性能比较</h5></li><li><h5 id="ArrayList中modCount的作用"><a href="#ArrayList中modCount的作用" class="headerlink" title="ArrayList中modCount的作用"></a>ArrayList中modCount的作用</h5><p> <a href="https://www.cnblogs.com/zuochengsi-9/p/7050351.html">modCount作用讲解</a></p></li><li><h5 id="ArrayList底层每次数组扩容为原数组长度的1-5倍"><a href="#ArrayList底层每次数组扩容为原数组长度的1-5倍" class="headerlink" title="ArrayList底层每次数组扩容为原数组长度的1.5倍"></a>ArrayList底层每次数组扩容为原数组长度的1.5倍</h5><blockquote><p>当扩容时，原长度为1，最小扩容量则为2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为最小扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == elementData.length)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//当size等于数组的长度时，需要扩容</span></span><br><span class="line">        <span class="comment">// 新扩容容量为原来大小的1.5倍，此处采用位运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//当长度为1时，新容量通过位运算的结果还是为1，当新容量小于最小扩容量时，用最小扩容量</span></span><br><span class="line">        <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol><li><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>LinkedList：是双向链表实现的List，有序可重复的集合。</p><p> 基于链表（存在上下节点），所以保证了有序性</p><p> 可重复：链表中每个节点内容（Data）都是一个Object对象，所以可重复</p><p>双向链表：元素中有上一个节点（preNode）与下一个节点（NextNode），节点内容(Data)</p><p>LinkedList：是非线程安全的</p><p>LinkedList：元素允许为null，允许重复元素</p><p>LinkedList：是基于链表实现的，因此插入删除效率高（只需要改变前后两个节点指针指向即可）</p><p>LinkedList：查找效率低，默认从头结点遍历查找，不能根据索引随机访问，时间复杂度为O(n)</p><p>LinkedList：是基于链表实现的，因此不存在容量不足的问题，所以没有扩容的方法</p></li><li><h5 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//LinkedList的长度，具体存放的元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//头结点，设计头结点得目的是为了查询，从first开始遍历</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//尾结点，作为添加开始的节点，新元素在last后添加</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">//如果链表中只有一个节点（Node），那么first，last都指向Node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure></li><li><h5 id="LinkedList中存放元素为Node对象"><a href="#LinkedList中存放元素为Node对象" class="headerlink" title="LinkedList中存放元素为Node对象"></a>LinkedList中存放元素为Node对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//元素，集合中具体的值</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">//指向后一个元素的指针</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//指向前一个元素的指针</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure></li><li><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//将尾结点赋值给临时节点l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//根据需要添加的元素创建一个新的node节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将新node节点置为尾结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果之前的尾结点为空，则表示e为添加的第一个元素，则首节点也指向newNode</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)&#123; </span><br><span class="line">        first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//如果之前的尾结点不为空，则将l的下一个节点next指向newNode</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素个数自增1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改统计自增1</span></span><br><span class="line">    modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure></li><li><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="comment">//验证下标的方法</span></span><br><span class="line">checkElementIndex(index);</span><br><span class="line"><span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据下标循环遍历，此方法根据长度进行了折半查找，故时间复杂度为O(n/2)</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素分为两半查找，如果index在前一半中，则从0顺序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果index在后一半中，则从最后一个元素开始，反向遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure></li><li><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//验证下标方法</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//根据node方法，用下标index找到该node对象，用unlink方法删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点时，需要改变上一个节点的next，以及下一个节点的prev</span></span><br><span class="line"><span class="comment">//例如删除B元素   </span></span><br><span class="line"><span class="comment">//    删除前     A → B → C     删除后  A → c</span></span><br><span class="line"><span class="comment">//              A ← B ← C     删除后  A ← c</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//item为当前node节点的元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">//next为当前node节点指向的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">//prev为当前node节点指向的上一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上一个节点为空，表示当前删除的是首节点</span></span><br><span class="line">    <span class="comment">//当前节点被删除，需要将当前节点的next置位首节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果上一个节点不为空，则将上一个节点的next指向 当前节点x的下一个节点next</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//当前删除节点的上节点置位null，当前节点X中的元素一步步置位null，是为了方便对象回收</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下一个节点为空，表示当前删除的是尾节点</span></span><br><span class="line">    <span class="comment">//当前节点被删除，需要将当前节点的上一个节点置位尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果下一个节点不为空，则将x的下一个节点next的prev指向 当前节点x的上一个节点prev</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>一、 三种集合的使用场景</strong></p><ol><li><p>Vector很少用,有其他线程安全的List集合</p></li><li><p>&#x3D;&#x3D;如果需要大量的添加和删除则可以选择LinkedList&#x3D;&#x3D;</p><p>原因：插入和删除的时候无需移动节点，只需要修改上下节点即可</p></li><li><p>&#x3D;&#x3D;如果需要大量的查询和修改则可以选择ArrayList&#x3D;&#x3D;</p><p>原因：底层为数组，查询与修改的时候根据下标来操作</p></li></ol><p><strong>二、使用线程安全的List集合,有什么办法?</strong></p><p>1.可以使用Vector</p><p>2.自己重写类似于ArrayList的但是线程安全的集合</p><p>3.&#x3D;&#x3D;可以使用<strong>Collections.synchronizedList()</strong>; 将ArrayList变成一个线程安全的集合</p><p>4.可以使用java.util.concurrent包下的CopyOnWriteArrayList,它是线程安全的</p><p><strong>三、CopyOnWriteArrayList是怎么实现线程安全的</strong></p><p>他的设计思想是:<strong>读写分离</strong>,<strong>最终一致,写时复制</strong></p><p><strong>缺点</strong>：1.底层是数组,删除插入的效率不高,写的时候需要复制,占用内存,浪费空间,</p><p>如果集合足够大的时候容易触发GC</p><p> 2.数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p><p>当执行add或remove操作没完成时，get获取的仍然是旧数组的元素</p><p> 3.CopyOnWriteArrayList读取时不加锁只是写入和删除时加锁</p><p><strong>四、CopyOnWriteArrayList和Collections.synchronizedList区别</strong></p><p> CopyOnWriteArrayList 读操作性能较好,写操作性能较差,因为读操作没有加锁</p><p> Collections.synchronizedList 写操作性能比CopyOnWriteArrayList在多线程操作的情况下要好。</p><p>而读操作因为是采用了synchronized关键字的方式，性能并不如CopyOnWriteArrayList。</p><blockquote><p>CopyOnWriteArrayList采用lock锁，每次写操作时都需要进行数组扩容，<br>而Collections.synchronizedList用synchronized锁add方法，只有达到阈值才会扩容<br>故CopyOnWriteArrayList写操作性能差</p></blockquote><p><a href="https://www.cnblogs.com/yjc1605961523/p/12493581.html">查看集合性能详情</a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>#数组 #链表 #红黑树</p><p><strong>前提：HashMap在jdk1.8中用数组+链表+红黑树来存放数据</strong></p><p> 数组通过index用来存放map元素key-value，index用map中key的hash值与该数组的长度进行与运算得到</p><p> 不同的key经过计算得到的index会存在相同，因此就产生hash碰撞，为了解决这一问题，就采用了链表的形式挂载到数组中。即多个map中key值不同，但index相同，该数组下标index下存放一个链表。</p><p> 当hash碰撞频率越高，链表就越长，查询效率就越低，为了解决这个问题，当链表长度大于阈值（默认为8）时，就将链表转换为红黑树</p><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NrGTamRJ-1631955925717)(C:\Users\admin\Desktop\笔记\img\结构图.png)]</p><h5 id="第一部分，基础入门"><a href="#第一部分，基础入门" class="headerlink" title="第一部分，基础入门"></a>第一部分，基础入门</h5><p> &#x3D;&#x3D;1.数组的优势&#x2F;劣势&#x3D;&#x3D;</p><p> 适合随机访问与修改，查询效率高，但数组须固定长度，且内存分配空间必须是连续的</p><p> 2.链表的优势&#x2F;劣势</p><p> 适合添加与删除，不用指定长度，可散列分配空间，但查询效率低，遍历性能差</p><p> 3.有没有一种方式整合两种数据结构的优势？</p><p> 散列表</p><p> 4.什么是哈希？</p><p> 核心理论：&#x3D;&#x3D;Hash也称散列、哈希，对应的英文都是Hash&#x3D;&#x3D;。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。</p><p> 这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。</p><p> 5.Hash的特点：</p><p> 从hash值不可以反向推导出原始的数据</p><p> 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值</p><p> 哈希算法的执行效率高效，长的文本也能快速地计算出哈希值</p><p> hash算法的冲突概率小</p><p><strong>第二部分，HashMap原理讲解：</strong></p><h5 id="1-Node数据结构分析"><a href="#1-Node数据结构分析" class="headerlink" title="1.Node数据结构分析"></a>1.Node数据结构分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashMap用内部类Node对象来存放数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//存放map中Key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="comment">//存放map中Key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//存放map中value值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//存放下一个元素的Node对象(单向链表)</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h5 id="2-hashMap全局参数"><a href="#2-hashMap全局参数" class="headerlink" title="2.hashMap全局参数"></a>2.hashMap全局参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缺省数组大小，默认为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//table数组最大的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//缺省的负载因子，默认为0.75（扩容时用到）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//树化阈值，当链表的元素个数大于8时，转化为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树降级为链表的阈值，红黑树内数量&lt;6时，则将红黑树转换成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//树化的另一个参数，当数组的长度&gt;=64时，才会进行树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//当前哈希表中元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//当前hash表结构修改次数，每次元素进行添加或删除时，自增1</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">//扩容阈值，当哈希表中的元素超过阈值时，触发扩容。默认是(数组长度 x loadFactor)</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><h5 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashMap提供了4个构造方法，第4个构造方法不常用省略</span></span><br><span class="line"><span class="comment">//1、无参构造只初始化了负载因子为 0.75，哈希表初始化时用了懒加载，在put时才会初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、 initialCapacity为数组的长度，loadFactor为负载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//数组的长度不能超过int的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//tableSizeFor方法通过位运算，不管指定的长度是多少，其结果只会为16的倍数，</span></span><br><span class="line">    <span class="comment">//无参构造threshold为缺省，有参构造时，该参数与数组的长度一致，扩容时用到</span></span><br><span class="line">    <span class="comment">//当哈希表中元素个数&gt;threshold时，触发扩容</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><h5 id="4-hash算法"><a href="#4-hash算法" class="headerlink" title="4.hash算法"></a>4.hash算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或：相同则返回0，不同则返回1</span></span><br><span class="line"><span class="comment">//将key的hash值再次进行异或运算，是为了让key的hash值高16位也参与路由寻址运算，</span></span><br><span class="line"><span class="comment">//如果一个hash值低位一样，高位不参与运算，会发生hash碰撞，如果高位参加运算，会使散列更加均匀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;    </span><br><span class="line">    <span class="type">int</span> h;    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h5 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5.put方法"></a>5.put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onlyIfAbsent:如果为true，则不更改现有值，只做新增</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//tab：当前hashMap的散列表</span></span><br><span class="line">    <span class="comment">//p：表示散列表中当前的元素</span></span><br><span class="line">    <span class="comment">//n：表示散列表数组的length</span></span><br><span class="line">    <span class="comment">//i：散列表中数组的index</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//当前散列表懒加载，当table为null时，调用resize方法进行输出，并将table数组的长度给n</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最简单的一种情况，当前插入的元素，根据下标index刚好为null，则直接将node放入散列表中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//e：临时的node元素</span></span><br><span class="line">        <span class="comment">//如果e不为null，表示找到了一个与当前要插入的key-value中key为</span></span><br><span class="line">        <span class="comment">//k：临时的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果当前散列表中，数组已存在的第一个元素刚好与当前要插入的元素key一致，则将p赋值给临时e</span></span><br><span class="line">        <span class="comment">//用来进行后续替换value值的操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果p是红黑树，则单独处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果与当前散列表中的头元素key不一致，则往下遍历，依次对比key</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//循环从0开始，但实际上是从链表中第二个元素开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果链表当前元素的下一个节点是空的，则表示是新增，插在当前链表末尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果新增的key-value大于8时，讲该链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环链表的某个元素，key与当前要插入节点的key一致，表示需要替换，循环break</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历时，没有找到一致的key，将当前遍历的e赋值给p，用来继续往下找next节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e不等于null时，表示需要用来替换</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增时modCount自增，替换元素不纳入统计，在上面步骤中已经return了</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果当前散列表中的元素个数大于扩容阈值时，触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172</span></span><br></pre></td></tr></table></figure><h5 id="6-扩容方法resize"><a href="#6-扩容方法resize" class="headerlink" title="6.扩容方法resize"></a>6.扩容方法resize</h5><blockquote><p>为什么需要扩容？</p><p>为了解决哈希冲突导致的链化，影响查询效率。扩容会用空间换时间，缓解该问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//oldTab：表示扩容前老的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap：表示扩容前老的哈希表数组的length</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr：扩容前老的扩容阈值，触发本次扩容的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap：扩容之后新的table数组长度</span></span><br><span class="line">    <span class="comment">//newCap：扩容之后新的扩容阈值，用来下次进行扩容的条件</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//oldCap&gt;0表示table已经被初始化，且有元素，这是一次正常的扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//扩容之前，table数组大小已经达到最大阈值，则不进行扩容，扩容条件设置为int最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容后，新table数组的大小在最大阈值范围内，且老的数组length&gt;=16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//正常扩容后，新的扩容阈值为原来的1倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的判断条件均为老的table为空进行</span></span><br><span class="line">    <span class="comment">//当老的table为空，且老的扩容阈值 &gt; 0 ,表示第一次初始化，初始化长度为老的扩容阈值</span></span><br><span class="line">    <span class="comment">//同时表示初始化时，调用的为有参构造方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//老的table与老的扩容阈值都为空，则表示无参构造初始化，赋默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新的扩容阈值为0，则表示老的table或老的扩容阈值已经达到最大范围</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的扩容阈值赋值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//根据新的扩容长度，new一个新的table数组，并将新的newTab赋值table</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//oldTab != null 表示扩容之前，老的table有值，需要将老table的值移到新newTab中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历老的table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">//e：临时node节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将老table中的数组元素置为null，方便垃圾回收整个老的table</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果老table数组中，该下标j的元素只有一个，从未发生过碰撞，直接将该元素丢到新的table</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//重新根据新的数组长度，求下标index，此处为重新计算index的公式</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果e为红黑树，单独处理</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">//如果老的table数组中，下标为j的元素为链表，则循环将链表的每个元素丢到新table中</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//低链位表：存放在扩容之后的数组的下标位置，与当前数组的下标位置一致</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//高链位表：存放在扩容之后的数组的下标位置为 当前数组的下标位置 + 扩容之前数组的长度</span></span><br><span class="line">                    <span class="comment">//假如原来组数的长度为16，且元素index为15，扩容后存放在新table中index为31的位置</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//等于0表示原来的key的哈希值为低位，扩容后index不变</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);<span class="comment">//next为空时，表示已经遍历完</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将最后一个元素的next节点置为null，表示loTail为最后一个元素</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将最后一个元素的next节点置为null，表示hiTail为最后一个元素</span></span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将扩容后的新table返回</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105</span></span><br></pre></td></tr></table></figure><h5 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7.get方法"></a>7.get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//通过key计算hash值，在table中遍历查找</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">//tab：引用当前hashMap的散列表</span></span><br><span class="line">    <span class="comment">//first：散列表数组中的头元素</span></span><br><span class="line">    <span class="comment">//e：临时node节点</span></span><br><span class="line">    <span class="comment">//n：table数组的length</span></span><br><span class="line">    <span class="comment">//k：临时key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//表示table数组中的头元素不为空，如果该头元素与查找key一致，则表示找到了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//头元素key不一致，继续遍历该链表</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果node节点是红黑树，则用二叉树查找法查询</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//遍历时，链表中的某个元素key与当前查找key一致，表示找到了，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null表示table中没有找到该key的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure><h5 id="8-remove方法"><a href="#8-remove方法" class="headerlink" title="8.remove方法"></a>8.remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//调用removeNode方法</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">//tab：引用当前hashMap的散列表</span></span><br><span class="line">    <span class="comment">//p：当前链表的元素</span></span><br><span class="line">    <span class="comment">//n：table数组的length</span></span><br><span class="line">    <span class="comment">//index：根据key计算得到的存放与哈希表数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//表示根据index找到了元素，且不为空，赋值给p</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//node：表示找到了需要删除的node元素</span></span><br><span class="line">        <span class="comment">//e：临时node节点</span></span><br><span class="line">        <span class="comment">//k：临时node节点的key</span></span><br><span class="line">    <span class="comment">//v：临时node节点的value值</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//当前找到的node元素p与要删除的元素一致</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">//如果当前node节点不一致，则遍历找next节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//p的next节点不为空，且p为红黑树，调用红黑树的查找方法</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//遍历链表时，链表中的某个元素与要删除的key一致，表示找到了</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//没找到，将临时节点置位p，继续找next节点遍历</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node不为空的情况下，表示根据key找到了需要删除的node元素</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//第一种情况：node为红黑树，调用红黑树的删除方法</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//第二种情况：node与p相等，表示数组中的首元素就是要删除的对象，</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">//将node元素的next置位首元素,即只删除首元素，将第二个元素置位首元素</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//第三种情况，将当前要删除的node元素的next，指向node上一个元素的next，node删除</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">//删除后，修改统计自增1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//删除后，元素个数自减1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">//将要删除的node元素返回</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970</span></span><br></pre></td></tr></table></figure><p>9.replace方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//replace有两个，一个根剧key替换value，另一个根剧key与老的value替换新的value，此方法为第一种</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//调用getNode方法，通过key找到node元素，getNode方法与在7.中一致</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将找到的node元素value值替换成新value值，老的value值返回</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><h5 id="一、hashMap是否线程安全？与HashTable之间的区别"><a href="#一、hashMap是否线程安全？与HashTable之间的区别" class="headerlink" title="一、hashMap是否线程安全？与HashTable之间的区别"></a>一、hashMap是否线程安全？与HashTable之间的区别</h5><p> &#x3D;&#x3D;HashMap非线程安全，HashTable是线程安全的</p><h5 id="二、hashMap是否可以存放key为空的对象？hashMap中put方法如何实现？"><a href="#二、hashMap是否可以存放key为空的对象？hashMap中put方法如何实现？" class="headerlink" title="二、hashMap是否可以存放key为空的对象？hashMap中put方法如何实现？"></a>二、hashMap是否可以存放key为空的对象？hashMap中put方法如何实现？</h5><p> 可以，因为元素node对象的key是一个泛型，可以为空，也可以是一个自定义对象</p><p> put方法的实现，根据当前key计算hash值，再使用hash值获取index位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放map中Key</span></span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line"><span class="comment">//当key为空时，hash值取0,  用0与数组长度进行逻辑与运算，结果也为0，所以key为空时，存放在数组第一个位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"> <span class="type">int</span> h;</span><br><span class="line"> <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取值 逻辑与运算：二进制数同时为1时 则为1</span></span><br><span class="line">tab[(n - <span class="number">1</span>) &amp; hash])</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h5 id="三、hashMap如何减少index下标冲突问题"><a href="#三、hashMap如何减少index下标冲突问题" class="headerlink" title="三、hashMap如何减少index下标冲突问题"></a>三、hashMap如何减少index下标冲突问题</h5><p> &#x3D;&#x3D;扩容，用空间来换时间。</p><h5 id="四、hashMap负载因子为什么是0-75f，而不是其他的呢？"><a href="#四、hashMap负载因子为什么是0-75f，而不是其他的呢？" class="headerlink" title="四、hashMap负载因子为什么是0.75f，而不是其他的呢？"></a>四、hashMap负载因子为什么是0.75f，而不是其他的呢？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载因子越小，扩容阈值就越小，hashMap底层扩容就越频繁，index发生冲突的概率越小</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> 加载因子越大，扩容阈值就越大，hashMap底层扩容会不频繁，index发生冲突的概率越大</p><p> index冲突越大，链表越长，即空间利用率越高，查询越慢</p><p> index冲突越小，链表不会很长，数组会越来越大，即空间利用率越低，查询很快</p><p> 因此，必须在空间与时间之间平衡与折中，经过平衡测试，选择了 0.75f</p><h5 id="五、hashMap是如何解决hashCode冲突的？index冲突会导致什么问题？"><a href="#五、hashMap是如何解决hashCode冲突的？index冲突会导致什么问题？" class="headerlink" title="五、hashMap是如何解决hashCode冲突的？index冲突会导致什么问题？"></a>五、hashMap是如何解决hashCode冲突的？index冲突会导致什么问题？</h5><p> hashCode冲突会导致index冲突，当两者冲突时用链表存储解决，链表越长，查询效率越低。时间复杂度为O(N)。当链表长度超过8时，转换为红黑树来解决查询效率低的问题</p><h5 id="六、hashMap中index冲突与hash冲突存在哪些区别？"><a href="#六、hashMap中index冲突与hash冲突存在哪些区别？" class="headerlink" title="六、hashMap中index冲突与hash冲突存在哪些区别？"></a>六、hashMap中index冲突与hash冲突存在哪些区别？</h5><p> index冲突：是因为底层做二进制运算产生相同的index，对象不同，index可能会相同</p><p> hash冲突：Node元素key不同，但是key经过hashcode运算时可能会产生相同的值，在hashMap中为了确保相同的key，使用equals方法比较</p><h5 id="七、jdk7中的hashMap存在哪些问题？"><a href="#七、jdk7中的hashMap存在哪些问题？" class="headerlink" title="七、jdk7中的hashMap存在哪些问题？"></a>七、jdk7中的hashMap存在哪些问题？</h5><p> 链表过长效率低问题，hashMap线程不安全，在多线程环境下，底层扩容的时候可能会出现死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//该行代码容易出现死循环</span></span><br><span class="line">                <span class="comment">//当一个线程把扩容的元素放入新的newTable中，新newTable的链表是反转的，</span></span><br><span class="line">                <span class="comment">//此时另外一个线程去取newTable[i]容易发生死循环</span></span><br><span class="line">                <span class="comment">//例如原来链表有两个元素AB, A的next为B</span></span><br><span class="line">                <span class="comment">//但是在新的newTable中A是先插入的，即B的next为A</span></span><br><span class="line">                <span class="comment">//多线程下就导致A的next为B  B的next为A，while就变成死循环了</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure><h5 id="八、-HashMap和Hashtable的区别"><a href="#八、-HashMap和Hashtable的区别" class="headerlink" title="八、 HashMap和Hashtable的区别"></a>八、 HashMap和Hashtable的区别</h5><p> 1、两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全。Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步</p><p> 2、HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key。</p><p> 3、HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p><p> 4、HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1 即:capacity * 2 + 1</p><p> 5、两者计算hash的方法不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸：</p><h2 id="x3D-x3D-时间复杂度"><a href="#x3D-x3D-时间复杂度" class="headerlink" title="&#x3D;&#x3D;时间复杂度"></a>&#x3D;&#x3D;时间复杂度</h2><h3 id="O-1-："><a href="#O-1-：" class="headerlink" title="O(1)："></a>O(1)：</h3><blockquote><p> 容量增大也不会影响到查询效率，如ArrayList直接通过下标访问</p></blockquote><h3 id="O-N-："><a href="#O-N-：" class="headerlink" title="O(N)："></a>O(N)：</h3><blockquote><p> 容量增大几倍，耗时也增大几倍,如linkedList，HashMap中链表；每次查找都需要依次遍历。</p><p> linkedList在遍历查找时，进行了折中查找，其时间复杂度也可以说是O(N&#x2F;2)</p></blockquote><h3 id="O-logN-："><a href="#O-logN-：" class="headerlink" title="O(logN)："></a>O(logN)：</h3><blockquote><p> 当数据增大n倍时，耗时增大logN倍，如数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度，二分查找就是O(logN)的算法，如HashMap中的红黑树</p></blockquote><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h1 id="二、字符串操作"><a href="#二、字符串操作" class="headerlink" title="二、字符串操作"></a>二、字符串操作</h1><h3 id="一、Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#一、Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="一、Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>一、Java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p><strong>不可变的类都是线程安全的！！！</strong></p><ul><li><p>&#x3D;&#x3D;String、StringBuffer、StringBuilder&#x3D;&#x3D;</p></li><li><p>String : &#x3D;&#x3D;final修饰，是不可变的，所以线程安全，String类的方法都是返回new String&#x3D;&#x3D;。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类是final修饰，底层是用char数组来存储，也是用final修饰，不可变的类都是线程安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">//存放数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><p>&#x3D;&#x3D;StringBuffer：线程安全的，对字符串的操作的方法都加了synchronized，保证线程安全&#x3D;&#x3D;</p></li><li><p>StringBuilder ：线程不安全</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer与StringBuilder都继承AbstractStringBuilder,底层也是用char数组存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence &#123;</span><br><span class="line">    <span class="comment">//默认数组长度16</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果调用有参构造，长度则为16 + 字符串长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//StringBuilder与StringBuffer在appen时都调用父类的append方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//StringBuffer类中，所有的方法都加了synchronized，所以线程安全</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        toStringCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer与StringBuilder的父类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">//用char数组来存放数据，没有用final修饰，所以可变</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="comment">//字符串具体的长度，  char数组的长度!=字符串长度</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//char数组的长度调用capacity方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.length;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//每次调用append时，都产生一个新的char数组，并两次进行数组copy</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="comment">//数组扩容,每次复制一个新的数组</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        <span class="comment">//将要添加的字符串复制到新数组中</span></span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970</span></span><br></pre></td></tr></table></figure><h3 id="二、StringBuffer与StringBuilder底层扩容机制"><a href="#二、StringBuffer与StringBuilder底层扩容机制" class="headerlink" title="二、StringBuffer与StringBuilder底层扩容机制"></a>二、StringBuffer与StringBuilder底层扩容机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">//底层扩容，调用数组copyOf方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果append时，最小长度大于当前数组的长度，出发扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//扩容后新数组的长度 = 老数组的长度2倍 + 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不超过int最大范围</span></span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><h3 id="三、string类为什么是final的？"><a href="#三、string类为什么是final的？" class="headerlink" title="三、string类为什么是final的？"></a>三、string类为什么是final的？</h3><ul><li><p>&#x3D;&#x3D;主要是为了“效率” 和 “安全性” 的缘故。&#x3D;&#x3D;</p><p>1、 由于String类不能被继承，所以就不会没修改，这就避免了因为继承引起的安全隐患</p><p>2、若 String允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以String被定义成final。</p></li><li><p>String存放数据的char数组value用final修饰，表示该数组引用地址不可变，数组中内容可以通过反射来修改</p></li></ul><hr><p>20220110</p><h1 id="三、Spring"><a href="#三、Spring" class="headerlink" title="三、Spring"></a>三、Spring</h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p><strong>什么是 Spring 框架？Spring 框架有哪些主要模块？</strong><br>&#x3D;&#x3D;Spring 是一种开源轻量级框架，是为了解决企业应用程序开发复杂性而创建的</p><p> Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框<br>架，不必担心 Spring 是如何在后台进行工作的。</p><p> Spring 框架至今已集成了20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问&#x2F;集<br>成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p></li><li><p><strong>Spring容器中Bean默认为单例，通过@Scope方法指定 (bean的作用域)</strong></p></li></ul><blockquote><p>prototype：多实例，IOC容器启动的时候，并不会去调用方法创建对象，而是每次获取的时候才会调用方法去创建</p><p>singleton：单实例，IOC容器容器启动的时候就会调用方法创建对象放入到IOC容器中，以后每次获取直接从容器中拿同一个bean（大Map.get()拿）</p><p>request：主要针对web应用，递交一次请求，创建一个对象</p><p>session：同一个session创建一个实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scope属性指定多例，缺省默认单例</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li><strong>@Lazy 懒加载</strong></li></ul><blockquote><p>主要针对单实例bean，单实例bean默认在容器启动时创建，加上@Lazy注解表示容器启动时不创建对向，仅当第一次获取时才创建初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒加载机制</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li><strong>useDefaultFilters &#x3D; true注解</strong></li></ul><blockquote><p>当在@ComponentScan注解中添加扫包路径时，可以指定过滤信息，过滤掉某些注解，如果用了useDefaultFilters &#x3D; true属性，表示使用默认的过滤，即默认添加@Component注解信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//此Filters注解表示扫包时，默认只包含@Controller的注解的bean，但useDefaultFilters = true时，将其他的注解如@Service也包含进去了，因为@Controller与@Service等相关注解都属于@Component子注解</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.shadow&quot;, includeFilters = &#123;</span></span><br><span class="line"><span class="meta">@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;,</span></span><br><span class="line"><span class="meta">useDefaultFilters = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Controller也属于Component</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassPathBeanDefinitionScanner类 165行</span></span><br><span class="line"><span class="comment">//源码部分,如果useDefaultFilters为true，则调用registerDefaultFilters方法添加Component信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry,</span></span><br><span class="line"><span class="params">                                      <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">        registerDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure><ul><li><strong>什么是控制反转(IOC)？什么是依赖注入？</strong></li></ul><p>IOC：把bean的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p><p>依然注入有以下三种实现方式： 1. 构造器注入 2. Setter 方法注入 3. 接口注入</p><ul><li><strong>BeanFactory 和 FactoryBean 有什么区别？</strong></li><li><strong>@Conditional条件注册bean</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Conditional注解条件注册bean，该注解value值必须为Condition类型</span></span><br><span class="line"><span class="meta">@Conditional(WindCondition.class)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述Conditional注解配置的条件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试条件注册bean，如果当前操作系统为windows则注入bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line"><span class="comment">//获取ioc容器的beanFactory</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line"><span class="comment">//获取当前环境信息</span></span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line"><span class="comment">//environment获取当前操作系统</span></span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(property.contains(<span class="string">&quot;Windows&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true则注入bean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure><ul><li><strong>@Import注册bean</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.shadow&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//用Import注解注册bean，可放入多个class，指定的class需要提供无参构造方法，bean的id默认为全类名</span></span><br><span class="line"><span class="meta">@Import(&#123;Person.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以通过ImportBeanDefinitionRegistrar自定义注册,向容器中注册bean;</span></span><br><span class="line"><span class="comment">//新建一个类CustomImportBeanDefinitionRegistrar实现该接口,通过Import注解导入</span></span><br><span class="line"><span class="meta">@Import(&#123;Person.class, CustomImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomImportBeanDefinitionRegistrar</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//在容器中注册自定义bean</span></span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(Order.class);</span><br><span class="line">registry.registerBeanDefinition(<span class="string">&quot;order&quot;</span>, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>在 Spring 中如何配置 Bean ?</strong></p><p>1.通过@ComponentScan方式进行扫包，一般针对我们自己写的类，如controller，service</p><p>2.@Bean 的配置方式</p><p>3.@Import注解方式：快速给容器导入一个组件，结合@Import注解可以实现两个接口自定义注册</p><p> ImportSelector 与 ImportBeanDefinitionRegistrar</p><p>4.使用spring提供的FactoryBean(工厂bean)</p><p> 源码细节：通过FactoryBean创建的bean在容器获取的时候，会调用实现了FactoryBean接口的类中，重写的getObject方法，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现FactoryBean注册bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Cat&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过FactoryBean向容器中注册bean时，调用getObject方法创建实例</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Cat <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//是否为单例</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.shadow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"> <span class="comment">//将具体FactoryBean当做bean注册到容器</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> CustomFactoryBean <span class="title function_">customFactoryBean</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomFactoryBean</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">           <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">       </span><br><span class="line"> System.out.println(<span class="string">&quot;ioc容器初始化完成&quot;</span>);</span><br><span class="line"> <span class="comment">//customFactoryBean在容器中也是一个bean</span></span><br><span class="line"> <span class="comment">//根据id在调用getBean时在源码中约定，如果bean的id是&amp;开头，则取工厂自身的bean</span></span><br><span class="line"> <span class="comment">//如果不是&amp;开头，则取类中实现了getObject()方法的bean</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;customFactoryBean&quot;</span>);</span><br><span class="line"> System.out.println(object.getClass());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFactoryDereference</span><span class="params">(<span class="meta">@Nullable</span> String name)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> (name != <span class="literal">null</span> &amp;&amp; name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果bean的name是&amp;开头的，则直接取容器中的bean</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"> <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是，当前factory是单列且在容器中</span></span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">   <span class="comment">//调用doGetObjectFromFactoryBean方法获取具体的实例</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用factory对象中getObject获取具体的实例</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263</span></span><br></pre></td></tr></table></figure></li><li><p><strong>BeanFactory 和 ApplicationContext 有什么区别？</strong></p></li><li><p><strong>Spring 有几种配置方式？</strong></p><ol><li>基于 XML 的配置</li><li>基于注解的配置</li><li>基于 Java 的配置</li></ol></li><li><p><strong>请解释 Spring Bean 的生命周期？</strong></p><blockquote><p>spring的生命周期只针对单实例bean</p></blockquote><p>bean的生命周期：指 bean创建—–初始化—-销毁 的过程</p><p>bean的生命周期是由容器进行管理的</p><p>我们可以自定义 bean初始化和销毁方法，容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法</p><blockquote><p>实现BeanPostProcessor 接口,重写该接口中的两个方法，也可以对bean的生命周期进行管理</p><p>执行顺序： -&gt; 调用构造方法创建实例对象bean -&gt; 底层调用populateBean方法对bean进行属性复制 -&gt; 调用BeanPostProcessor实现类中的方法前置处理器postProcessBeforeInitialization() &gt; 执行bean的初始化 init-method 方法 -&gt; 调用BeanPostProcessor实现类中postProcessAfterInitialization()后置处理器，在init-method 之后进行后置处理工作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试声明周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bean对象创建！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bean对象初始化！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bean对象销毁！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.shadow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器启动时，调用构造方法创建bean，并调用init方法对bean初始化，当容器close时，调用bean的销毁方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring 框架中的单例 Beans 是线程安全的么？</strong></p><p>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要</p><p>开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类 和 DAO 类)，所以</p><p>在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状 态的话，就需要自行保证线程</p><p>安全。 最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p></li><li><p><strong>如何开启基于注解的自动装配？</strong></p><p>要使用 <code>@Autowired</code>，需要注册 <code>AutowiredAnnotationBeanPostProcessor</code>，有两种方式来实现：</p><blockquote><ol><li>在配置文件中添加bean配置</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br><span class="line">123</span><br></pre></td></tr></table></figure><blockquote><ol><li>配置文件中直接引入 AutowiredAnnotationBeanPostProcessor</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotati</span></span></span><br><span class="line"><span class="string"><span class="tag">onBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure></li><li><p><strong>Spring 框架中都用到了哪些设计模式？</strong></p><ol><li>代理模式—在 AOP 和 remoting 中被用的比较多。</li><li>单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTempl ate。</li><li>工厂模式—BeanFactory 用来创建对象的实例</li><li>责任链模式：在 AOP切面拦截的方法具体执行中</li></ol></li><li><p><strong>Spring AOP与IOC原理</strong></p></li><li><p><strong>Spring中循环依赖问题如何解决</strong></p></li><li><p><strong>IOC 容器对 Bean 的生命周期</strong></p><ol><li>通过构造器或工厂方法创建 Bean 实例</li><li>为 Bean 的属性设置值和对其他 Bean 的引用</li><li>将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessBeforeInitialization 方 法</li><li>调用 Bean 的初始化方法(init-method)</li><li>将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessAfterInitialization 方法</li><li>Bean 可以使用了</li><li>当容器关闭时, 调用 Bean 的销毁方法(destroy-method)</li></ol></li></ul><h1 id="四、SpringMVC"><a href="#四、SpringMVC" class="headerlink" title="四、SpringMVC"></a>四、SpringMVC</h1><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>什么是 SpringMvc？</strong></p><p>SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。</p></li><li><p><strong>SpringMVC 工作原理</strong></p><ol><li>客户端发送请求到 DispatcherServlet</li><li>DispatcherServlet 查询 handlerMapping 找到处理请求的 Controlle</li><li>Controller 调用业务逻辑后，返回 ModelAndView</li><li>DispatcherServlet 查询 ModelAndView，找到指定视图</li><li>视图将结果返回到客户端</li></ol></li><li><p><strong>SpringMVC 流程？</strong></p><ol><li>用户发送请求至前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li><li>处理器映射器找到具体的处理器,生成处理器对象 及处理器拦截器一并返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller 执行完成返回 ModelAndView</li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li><li>ViewReslover 解析后返回具体 View</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol></li><li><p><strong>SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？</strong></p><ol><li>是单例模式,所以在多线程访问的时候有线程安全问题</li><li>不要用同步,会影响性能的,解决方案是在控制器里面不能写成员变量。 或者设置为多例模式</li></ol></li><li><p><strong>如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？</strong></p><p> 可以在@RequestMapping 注解里面加上 method&#x3D;RequestMethod.GET</p></li><li><p><strong>怎么样在方法里面得到 Request,或者 Session</strong>？</p><p> 直接在方法的形参中声明 request,SpringMvc 就自动把 request 对象传入</p></li><li><p><strong>SpringMvc 用什么对象从后台向前台传递数据的？</strong></p><p> 通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以通 过 el 表达式拿到。</p></li><li><p><strong>SpringMvc 里面拦截器是怎么写的？</strong></p><p> 有两种写法,一种是实现接口,另外一种是继承适配器类,然后在 SpringMvc 的配置文件中 配置拦截器即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 SpringMvc 的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置一个拦截器的 Bean 就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.et.action.MyHandlerInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.et.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure></li><li><p><strong>讲下 SpringMvc 的执行流程</strong></p><p> 系统启动的时候根据配置文件创建 spring 的容器, 首先是发送 http 请求到核心控制器 disPatherServlet，spring 容器通过映射器去寻找业务控制器，使用适配器找到相应的业务 类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用 ModelAndView 进行视图转发，数据放在 ModelMap 中传递数据，进行页面显示。</p></li><li><p><strong>session与cookie</strong></p><p>1.cookie在客户端，session在服务端，cookie的产生是在服务端产生的。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。 当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p><p>2.每个用户访问服务器都会建立一个session，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。每次请求 cookie都把SessionId 自动附加在HTTP头信息中，带到服务器，当服务器处理完后，将结果返回给SessionId所对应的用户</p><p>3.session和cookie的存储都存在时效性，这是很有必要的</p><p>4.单个cookie保存的数据不能超过4kb，很多浏览器都限制了一个站点最多保存20个cookie</p><p>5.不管是cookie还是session，都是建立在安全性的大前提下，session中不仅仅有cookie的信息，同时会有该用户的相关重要且安全的信息存储，所以session是在服务器的，而cookie只是服务器将一些不重要的信息拿出来丢给客户的存在，以备以后快速匹配校验用。</p></li><li><p><strong>拦截器与过滤器</strong></p><ol><li>Filter需要在web.xml中配置，依赖于Servlet；</li><li>Interceptor需要在SpringMVC中配置，依赖于 SpringMVC 框架；</li><li>Filter的执行顺序在Interceptor之前</li><li>两者的本质区别：拦截器（Interceptor）是基于Java的反射机制（动态代理），而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验，太细的话，还是建议用interceptor；</li><li>拦截器不依赖servlet容器，过滤器需要依赖于servlet容器。</li><li>在action生命周期中，拦截器可以调用多次，过滤器只在容器初始化的时候调用一次。</li></ol></li></ul><h1 id="五、SpringBoot"><a href="#五、SpringBoot" class="headerlink" title="五、SpringBoot"></a>五、SpringBoot</h1><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="SpringBoot启动原理"><a href="#SpringBoot启动原理" class="headerlink" title="SpringBoot启动原理"></a>SpringBoot启动原理</h4><p> <strong>启动流程</strong>：主要分为三个部分 ，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心</p><p> <strong>启动：</strong>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，</p><p> 1.首先进入run方法 ，run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SzjvkYSw-1631955925719)(C:\Users\admin\Desktop\笔记\img\Boot初始化.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-svN6bIVp-1631955925720)(C:\Users\admin\Desktop\笔记\img\boot初始化2.png)]</p><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D7JxrnTq-1631955925722)(C:\Users\admin\Desktop\笔记\img\boot初始化3.png)]</p><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>该方法中采用SPI机制，去读取 META-INF&#x2F;spring.factories 目录的配置文件内容， 把配置文件中的类加载到 spring 容器中</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)</p><p>创建 springboot 的上下文对象</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JD6Rd4gT-1631955925723)(C:\Users\admin\Desktop\笔记\img\boot初始化4.png)]</p><p>在这个上下文对象构造函数中把 ConfigurationClassPostProcessor变成 beanDefinition 对象。</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联 ：</p><p>6.接下来的refreshContext(context)方法，实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，Spring容器及bean的实例化等核心工作。</p><p>7.内置 tomcat 的启动和部署，Tomcat 的启动在 onRefresh()中：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XaAiIwlB-1631955925724)(C:\Users\admin\Desktop\笔记\img\boot初始化5.png)]</p><p>springboot 的启动就是核心就是完成了两件事， 一个是 spring容器的启动调用了 refresh 核心方法， 一个是 tomcat 的启动， new 出了一个内置的 tomcat。 配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成</p><h4 id="SpringBoot-自动配置源码"><a href="#SpringBoot-自动配置源码" class="headerlink" title="SpringBoot 自动配置源码"></a>SpringBoot 自动配置源码</h4><p>自动配置功能开启， 我们看看启动类：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-he8qnlva-1631955925724)(C:\Users\admin\Desktop\笔记\img\boot自动装配1.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DmbzvoHj-1631955925725)(C:\Users\admin\Desktop\笔记\img\boot自动装配2.png)]</p><p>我们看看这个类</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ylpZzpdY-1631955925725)(C:\Users\admin\Desktop\笔记\img\boot自动装配3.png)]</p><p>实现了 DeferredImportSelector 接口。这个类的核心功能是通过 SPI 机制收集 EnableAutoConfiguration 为 key 的所有类， 然后通过 ConfigurationClassPostProcessor 这个类调用到该类中的方法，把收集到的类变成beanDefinition 对象最终实例化加入到 spring 容器</p><p>EnableAutoConfiguration 为 key 的所有类： 该配置文件在spring-boot-autoconfigure jar 包中。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-u6Pg0CEF-1631955925726)(C:\Users\admin\Desktop\笔记\img\boot自动装配5.png)]</p><p>该类AutoConfigurationImportSelector 中两个方法会被ConfigurationClassPostProcessor 调到：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UMI6tSaV-1631955925726)(C:\Users\admin\Desktop\笔记\img\boot自动装配6.png)]</p><p>在这两个方法中完成了 SPI 类的收集。ConfigurationClassPostProcessor 类只是把收集到的类变成 beanDefinition并加入到 spring 容器。</p><p>ConfigurationClassPostProcessor 类调用的地方</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ftOudwRp-1631955925727)(C:\Users\admin\Desktop\笔记\img\boot自动装配7.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RS5kPwCb-1631955925727)(C:\Users\admin\Desktop\笔记\img\boot自动装配8.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r53c631j-1631955925728)(C:\Users\admin\Desktop\笔记\img\boot自动装配9.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XjT6gs3n-1631955925729)(C:\Users\admin\Desktop\笔记\img\boot自动装配10.png)]</p><p>这就是这两个方法的调用地方。上述就是 EnableAutoConfiguration 为 key 自动配置类的收集过程。 有自动配置<br>类的收集并加入到 spring 容器， 其中有 aop， 事务， 缓存， mvc 功能等，就已经导入到 springboot 工程了。</p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>什么是 Spring Boot？</strong></p><p>Spring Boot 已经建立在现有 spring 框架之上。使用 spring 启动，避免了之前我们必须做的所有样板代码和配置。因此，SpringBoot 可以帮助我们以最少的工作量，更加健壮地使用现有的 Spring 功能。</p></li><li><p><strong>Spring Boot 有哪些优点？</strong></p></li></ul><ol><li>减少开发成本，提高效率。</li><li>使用 JavaConfig 有助于避免使用 XML。</li><li>避免大量的 Maven 导入和各种版本冲突。</li><li>提供意见发展方法。 通过提供默认值快速开始开发。 没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomca。</li><li>减少配置，因为没有 web.xml 文件。</li></ol><ul><li><p><strong>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</strong></p><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p></li></ul><ol><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能</li><li>@ComponentScan：Spring组件扫描。</li></ol><ul><li><p><strong>Spring Boot 自动配置原理是什么？</strong></p><p>SpringBoot的自动配置注解是@EnableAutoConfiguration，点进去发现 @Import的类 中有执行自动加载配置的代码，其中 loadFactoryNames 方法会加载类路径及所有jar包下META-INF&#x2F;spring.factories配置中映射的自动配置的类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>; </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</strong></li></ul><ol><li>使用springloaded配置pom.xml文件 (生产环境推荐)</li><li>使用devtool工具包 (开发环境推荐)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><ul><li><strong>Spring Boot 如何定义多套不同环境配置</strong></li></ul><p>假如有开发、测试、生产三个不同的环境，需要定义三个不同环境下的配置。</p><ol><li>applcation.properties</li><li>application-dev.properties</li><li>application-test.properties</li><li>application-prod.properties</li></ol><p>需要指定环境时，在applcation.properties文件中指定当前的环境spring.profiles.active&#x3D;dev，用dev环境</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br><span class="line"><span class="attr">123</span></span><br></pre></td></tr></table></figure><ul><li><strong>springboot实现热部署的原理</strong></li></ul><p> 深层原理是使用了两个ClassLoader，一个ClassLoader加载那些不会改变的类(第三方jar包)，另一个ClassLoader加载会更改的类，称为restartClassLoader ，这样在有代码更改的时候，原来的restartClassLoader被丢弃，重新建一个restartClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间</p><ul><li><strong>如何在自定义端口上运行 Spring Boot 应用程序？</strong></li></ul><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在 application.properties 中指定端 口。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span> = <span class="string">8090</span></span><br><span class="line"><span class="attr">1</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>如何实现 Spring Boot 应用程序的安全性？</strong></p><p>使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展 WebSecurityConfigurerAdapter 并覆 盖其方法。</p></li><li><p><strong>什么是 Swagger？你用 Spring Boot 实现了它吗？</strong></p><p>Swagger 广泛用于可视化 API。Swagger 是 用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以 与服务器相同的速度更新。</p></li><li><p><strong>如何使用 Spring Boot 实现异常处理</strong></p><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p></li></ul><h1 id="六、Spring-Cloud"><a href="#六、Spring-Cloud" class="headerlink" title="六、Spring Cloud"></a>六、Spring Cloud</h1><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>什么是Spring Cloud？</strong></p><p>Spring cloud 应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p></li><li><p><strong>Spring Cloud和Dubbo的区别</strong></p><ol><li>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。</li><li>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</li></ol></li><li><p><strong>REST和RPC的区别</strong></p></li></ul><ol><li>REST风格的系统交互更方便，RPC调用服务提供方和调用方之间依赖太强。</li><li>REST调用系统性能较低，RPC调用效率比REST高。</li><li>REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。</li><li>REST可以和Swagger等工具整合，自动输出接口API文档。</li></ol><ul><li><strong>SpringCloud如何实现服务的注册和发现</strong></li></ul><ol><li>服务在发布时，指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</li><li>这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。</li><li>调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</li></ol><ul><li><strong>什么是服务熔断和服务降级？</strong></li></ul><p> <strong>熔断机制</strong>：是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。<br> <strong>服务降级</strong>：一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。</p><p> <strong>Hystrix相关注解：</strong></p><ul><li>@EnableHystrix：开启熔断</li><li>@HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li><li><strong>项目中zuul常用的功能</strong><ul><li>提供动态路由</li><li>提供安全、鉴权处理</li><li>跨域处理</li><li>全局动态路由的hystrix(熔断、降级、限流)处理</li></ul></li><li><strong>服务网关的作用</strong></li><li>简化客户端调用复杂度，统一处理外部请求。</li><li>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。</li><li>多渠道支持，针对不同的客户端提供不同的网关支持。</li><li>遗留系统的微服务化改造，可以作为新老系统的中转组件。</li><li>统一处理调用过程中的安全、权限问题。</li><li>Spring Cloud中的网关有：Zuul和Spring Cloud Gateway，最新版本中推荐使用后者。</li><li><strong>ribbon和feign区别</strong></li></ul><p> Ribbon添加maven依赖 spring-starter-ribbon</p><p>使用@RibbonClient(value&#x3D;“服务名称”) ，使用RestTemplate调用远程服务对应的方法。</p><p> feign添加maven依赖 spring-starter-feign</p><p>服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”)</p><ol><li>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。</li><li>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li><li>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</li></ol><ul><li><p><strong>ribbon的负载均衡策略</strong></p><ol><li>RoundRobinRule: 轮询策略</li><li>RandomRule: 随机策略</li><li>BestAvailableRule: 最大可用策略，即先过滤出故障服务器后，选择一个当前并发请求数最小的;</li><li>WeightedResponseTimeRule: 带有加权的轮询策略，对各个服务器响应时间进行加权处理，然后在采用轮询的方式来获取相应的服务器;</li></ol></li><li><p><strong>简述什么是CAP,并说明Eureka包含CAP中的哪些?</strong></p><p><strong>CAP理论：</strong>一个分布式系统不可能同时满足C (一致性),A(可用性),P(分区容错性).由于分区容错性P在分布式系统中是必须要保证的,因此我们只能从A和C中进行权衡.</p><p><strong>Eureka 遵守 AP</strong>：</p></li></ul><ol><li>Eureka各个节点都是平等的,几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。</li><li>而Eureka的客户端在向某个Eureka 注册或查询时，如果发现连接失败,则会自动切换至其他节点，只要有一台Eureka还在,就能保证注册服务可用(保证可用性),只不过查的信息可能不最新的<strong>不保证强一致性</strong>。</li></ol><ul><li><strong>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</strong></li></ul><p> Zookeeper保证了CP（C：一致性，P：分区容错性）</p><p> Eureka保证了AP（A：高可用）</p><ul><li><strong>链路跟踪Sleuth</strong></li></ul><p> 当我们项目中引入Spring Cloud Sleuth后，每次链路请求都会添加一串追踪信息，格式是[server-name, main-traceId,sub-spanId,boolean]：</p><ul><li>server-name：服务结点名称。</li><li>main-traceId：一条链路唯一的ID，为TraceID。</li><li>sub-spanId：链路中每一环的ID，为SpanID。</li><li>boolean：是否将信息输出到Zipkin等服务收集和展示。</li></ul><h1 id="七、Mybatis"><a href="#七、Mybatis" class="headerlink" title="七、Mybatis"></a>七、Mybatis</h1><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>什么是 MyBatis？</strong></p><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p></li><li><p><strong>讲下 MyBatis 的缓存</strong></p><p>MyBatis 的缓存分为一级缓存和二级缓存</p></li></ul><p><strong>一级缓存</strong>放在 session 里面,默认就有,</p><p><strong>二级缓存</strong>放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现 Serializable 序列化接口,可在它的映射文件中配置</p><ul><li><p><strong>Mybatis 是如何进行分页的？分页插件的原理是什么？</strong></p><p>Mybatis 使用 RowBounds 对象进行分页，可直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</p></li></ul><p> 分页插件的原理：实现 Mybatis 提供的接口()，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步:引入mybatis的 pagehelper 分页插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二步：在mybatis的全局配置文件中配置PageHelper分页插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自4.0.0版本以后实现这个接口了 com.github.pagehelper.PageInterceptor  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 自4.0.0以后的版本已经可以自动识别数据库了，所以不需要我们再去指定数据库 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;dialect&quot; value=&quot;Mysql&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">举例：select * from student，拦截 sql 后重写为：select t.* from （select * from student）t</span><br><span class="line">limit 0，10</span><br><span class="line"></span><br><span class="line">具体参考：</span><br><span class="line">https://www.cnblogs.com/helf/p/11098105.html</span><br><span class="line">1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure><ul><li><p><strong>简述 Mybatis 的插件运行原理，以及如何编写一个插件？</strong></p><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、 Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实 现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定 要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p></li><li><p><strong>#{}和${}的区别是什么？</strong></p></li></ul><ol><li>#{}是预编译处理，${}是字符串替换。</li><li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法 来赋值；</li><li>Mybatis 在处理时 ， 就 是 把 {}时，就是把时，就是把{}替换成变量的值。</li><li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li></ol><ul><li><p><strong>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否 启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方 法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单 独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的 对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p></li><li><p><strong>MyBatis 的好处是什么？</strong></p></li></ul><ol><li>MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的 维护带来了很大便利。</li><li>MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象， 大大简化了 Java 数据库编程的重复工作。</li><li>因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活 控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查询效率，能够完成复 杂查询。</li></ol><ul><li><strong>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</strong></li></ul><p> Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，标签会被解析为 ParameterMap 对象，其每个子元素会 被解析为 ParameterMapping 对象。标签会被解析为 ResultMap 对象，其每个子 元素会被解析为 ResultMapping 对象。每一个 select 、 insert 、 update 、 delete 标签 均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</p><ul><li><p><strong>接口绑定有几种实现方式,分别是怎么实现的?</strong></p><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL 来绑 定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名.</p></li><li><p><strong>模糊查询 like 语句该怎么写</strong></p></li></ul><ol><li>在 java 中拼接通配符，通过#{}赋值</li><li>在 Sql 语句中拼接通配符 （不安全 会引起 Sql 注入）</li></ol><ul><li><p><strong>Mybatis 中如何执行批处理？</strong></p><p>使用 BatchExecutor 完成批处理。</p></li><li><p>**Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？ **</p><p>Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、 BatchExecutor。</p></li></ul><ol><li>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对 象，用完立刻关闭 Statement 对象。</li><li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象， 而是放置于 Map</li><li>BatchExecutor：完成批处理。</li></ol><ul><li><p><strong>如何获取自动生成的(主)键值</strong></p><p> 配置文件设置 usegeneratedkeys 为 true</p></li></ul><h1 id="八、Redis"><a href="#八、Redis" class="headerlink" title="八、Redis"></a>八、Redis</h1><h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>什么是 Redis？简述它的优缺点？</strong></p><p>Redis 本质上是一个 Key-Value 类型的内存数据库，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p><strong>优点：</strong>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构。</p><p><strong>缺点：</strong>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上</p></li><li><p><strong>Redis 与 memcached 相比有哪些优势？</strong></p></li></ul><ol><li>memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</li><li>redis 的速度比 memcached 快很多</li><li>redis 可以持久化其数据 redis 可以持久化其数据</li></ol><ul><li><p><strong>Redis 支持哪几种数据类型？</strong></p><p>字符串 String、 哈希Hash、列表List、集合 Set、有序集合 ZSet。如果是高级用户，还需要加上下面几种数据结构 HyperLogLog、 Geo、Pub&#x2F;Sub。</p></li><li><p><strong>Redis 有哪几种数据淘汰策略？</strong><br>\1. noeviction: 不删除数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误。<br>\2. allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>\3. volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>\4. allkeys-random: 回收随机的键使得新添加的数据有空间存放。<br>\5. volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>\6. volatile-ttl: 回收过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p></li><li><p><strong>一个字符串类型的值能存储最大容量是多少？</strong></p><p>512M</p></li><li><p><strong>为什么 Redis 需要把所有数据放到内存中？</strong></p><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。 所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 redis 的 性能。</p></li><li><p><strong>Redis 集群方案应该怎么做？都有哪些方案？</strong></p></li><li><p>Twemproxy</p></li><li><p>codis</p></li><li><p>Redis-cluster（本身提供了自动将数据分散到 Redis Cluster 不同节点的能力，整个数据集 合的某个数据子集存储在哪个节点对于用户来说是透明的）</p><p>redis-cluster 分片原理：Cluster 中有一个 16384 长度的槽(虚拟槽)，编号分别为 0-16383。 每个 Master 节点都会负责一部分的槽，当有某个 key 被映射到某个 Master 负责的槽，那 么这个 Master 负责为这个 key 提供服务，至于哪个 Master 节点负责哪个槽，可以由用户 指定，也可以在初始化的时候自动生成，只有 Master 才拥有槽的所有权。Master 节点维 护着一个 16384&#x2F;8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比 如对于编号为 1 的槽，Master 只要判断序列的第二位（索引从 0 开始）是不是为 1 即可。 这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D, 我需要从节点 A、B、 C 中得部分槽到 D 上。</p></li><li><p><strong>Redis 集群方案什么情况下会导致整个集群不可用？</strong></p><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p></li><li><p><strong>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</strong></p><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p></li><li><p><strong>说说 Redis 哈希槽的概念？</strong></p><p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通 过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p></li><li><p><strong>Redis 集群的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型, 每个节点都会有 N-1 个复制品.</p></li><li><p><strong>Redis 集群会有写操作丢失吗？为什么？</strong></p><p>Redis 并不能保证数据的强一致性，这意味在实际中集群在特定的条件下可能会丢失写操作。</p></li><li><p><strong>Redis 集群最大节点个数是多少？</strong></p><p>16384 个</p></li><li><p><strong>怎么理解 Redis 事务？</strong></p></li></ul><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行</p><ul><li><p><strong>Redis 事务相关的命令有哪几个？</strong></p><p>MULTI、EXEC、DISCARD、WATCH</p></li><li><p><strong>Redis key 的过期时间和永久有效分别怎么设置？</strong></p><p>EXPIRE 和 PERSIST 命令</p></li><li><p><strong>Redis 如何做内存优化？</strong></p><p>尽可能使用散列表（hashes），散列表使用的内存非常小</p></li><li><p><strong>Redis 回收进程如何工作的？</strong></p><p>一个客户端运行了新的命令，添加了新的数据。 Redis检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</p></li><li><p><strong>使用过 Redis 分布式锁么，它是怎么实现的</strong></p><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。 如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？ set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！</p></li><li><p><strong>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</strong></p><p><strong>缓存穿透：</strong> 一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就会去DB查找。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p><strong>如何避免：</strong></p><ol><li>对查询结果为空的情况进行缓存，缓存时间设置短一点，或该 key 对应的数据 insert 了之后清理缓存。</li><li>对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。</li></ol><p><strong>缓存雪崩：</strong>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p></li></ul><p><strong>如何避免：</strong></p><ol><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li><li>做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为 短期，A2 设置为长期</li><li>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ol><ul><li><p><strong>redis 主从复制如何实现的？redis 的 key 是如何寻址的？</strong></p><p>主从复制实现：主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于 mysql 的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。</p><p>寻址计算：</p><ol><li><p><strong>hash 算法：</strong>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库。</p></li><li><p><strong>一致性hash算法：</strong>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p></li></ol></li><li><p><strong>缓存与数据库不一致怎么办？</strong></p><p> <strong>描述：</strong>假设采用的主存分离，读写分离的数据库， 如果一个线程 A 先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同步没有完成，线程 B 从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓存，这个时候，缓存当中的就是旧的数据。 发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时间被拉长了</p><p> <strong>处理思路：</strong>在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。</p></li><li><p><strong>主从数据库不一致如何解决</strong></p><p><strong>场景描述：</strong>对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</p><p><strong>解决思路：</strong></p><ol><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的 key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ol></li><li><p><strong>怎么发现热key，如何防止</strong></p><p>发现：</p><ol><li>凭借业务经验，进行预估哪些是热key</li><li>在客户端进行收集</li><li><code>redis-faina</code> 工具， 但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</li><li>hotkeys参数</li><li><em>自己抓包评估</em></li></ol><p>防止：</p><ol><li>利用二级缓存</li><li>备份热key，在多个redis上都存一份不就好了</li></ol></li></ul><h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h1 id="十、JUC"><a href="#十、JUC" class="headerlink" title="十、JUC"></a>十、JUC</h1><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><p><strong>CPU核心数和线程数的关系</strong></p><p>CPU核心数与线程数1:1</p><p>使用了超线程技术后为—&gt; 1:2</p><p><strong>区别：</strong></p><p>CPU的核心数是指硬件上的真实对象。</p><p>CPU线程数只是一个逻辑概念，不是一个真正的对象，只是为了更好地描述CPU的运行能力。</p></li><li><p><strong>CPU时间片轮转机制（RR调度）</strong></p><p> 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一时间段，称作它的时间片，即该进程允许运行的时间。</p><p> 系统会维护一张就绪进程列表，其实就是一个先进先出的队列，新来的进程就会被加到队列的末尾，然后每次执行进程调度的时候，都会选择队列的队首进程，让它在CPU上运行一个时间片的时间，不过如果分配的时间片已经消耗光了而进程还在运行，调度程序就会停止该进程的运行，同时把它移到队列的末尾，CPU会被剥夺并分配给队首进程，而如果进程在时间片结束前阻塞或者结束了，则CPU就会进行切换。</p></li><li><p><strong>什么是进程和线程</strong></p><p>进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源</p><p>线程：CPU调度的最小单位，必须依赖进程而存在。</p></li><li><p><strong>并行和并发</strong></p><p><strong>并行（parallel）：</strong>同一时刻，可以同时处理事情的能力,有多条指令在多个处理器上同时执行。互不干扰</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yD0JIfEL-1631955925730)(C:\Users\admin\Desktop\笔记\img\并行.png)]</p><p><strong>并发（concurrency）：</strong>与单位时间相关，在时间段内可以处理事情的能力</p><p>同一时刻只能够执行一条指令，但是多条指令被快速的进行切换，给人造成了它们同时执行的感觉。但在微观来说，并不同时进行的，只是划分时间段，分别进行执行。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lVFybI6Q-1631955925730)(C:\Users\admin\Desktop\笔记\img\并发.png)]</p></li><li><p><strong>高并发编程的意义、好处和注意事项</strong></p><p><strong>好处：</strong>充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化</p><p><strong>问题：</strong> 线程共享资源，存在冲突；</p><p> 容易导致死锁；</p><p> 启用太多的线程，就有搞垮机器的可能</p></li></ul><h3 id="Java里的线程"><a href="#Java里的线程" class="headerlink" title="Java里的线程"></a>Java里的线程</h3><h4 id="一、启动线程的方式"><a href="#一、启动线程的方式" class="headerlink" title="一、启动线程的方式"></a>一、启动线程的方式</h4><p>三种：类Thread、接口Runnable、接口Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> &#123;</span><br><span class="line"><span class="comment">/*第一种：扩展自Thread类*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I am extends Thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*第二种：实现Runnable接口*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I am implements Runnable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*第三种：实现Callable接口，允许有返回值*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I am implements Callable&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;CallResult&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">UseThread</span>().start();</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="type">UseRun</span> <span class="variable">useRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseRun</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(useRun).start();</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="type">UseCall</span> <span class="variable">useCall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCall</span>();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(useCall);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure><h4 id="二、线程安全停止"><a href="#二、线程安全停止" class="headerlink" title="二、线程安全停止"></a>二、线程安全停止</h4><ol><li><p>线程自然终止：自然执行完或抛出未处理异常</p></li><li><p>stop()，resume()与suspend()搭配， 已不建议使用，</p><p>stop()： 会立即释放CPU资源和释放锁。但不安全，会导致线程不会正确释放资源</p><p>resume()： 恢复线程的执行</p><p>suspend()：线程挂起，不会释放资源，容易导致死锁</p><p>参考： <a href="https://blog.csdn.net/Mrs_Yu/article/details/107550821">https://blog.csdn.net/Mrs_Yu/article/details/107550821</a></p></li><li><p>interrupt()、 isInterrupted() 、static方法interrupted() 中止</p></li><li><p>java线程是协作式，而非抢占式</p><p>调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。</p><p>isInterrupted() 判定当前线程是否处于中断状态。</p><p>static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()。</p><p>方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()。</p></li></ol><h4 id="三、线程常用方法和线程的状态"><a href="#三、线程常用方法和线程的状态" class="headerlink" title="三、线程常用方法和线程的状态"></a>三、线程常用方法和线程的状态</h4><p> 线程只有5种状态。整个生命周期就是这几种状态的切换</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ruNEDa3T-1631955925731)(C:\Users\admin\Desktop\笔记\img\线程状态.png)]</p><h4 id="四、守护线程"><a href="#四、守护线程" class="headerlink" title="四、守护线程"></a>四、守护线程</h4><p> 和主线程共死，finally不能保证一定执行</p><h4 id="五、run-和start"><a href="#五、run-和start" class="headerlink" title="五、run()和start()"></a>五、run()和start()</h4><p> run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。</p><h4 id="六、yield"><a href="#六、yield" class="headerlink" title="六、yield()"></a>六、yield()</h4><p>让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。</p><h4 id="七、等待和通知"><a href="#七、等待和通知" class="headerlink" title="七、等待和通知"></a>七、等待和通知</h4><p>wait() 与 notify()&#x2F;notifyAll() 对象上的方法</p><p><strong>标准范式：</strong></p><p>等待方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 获取对象的锁；</span><br><span class="line">2. 循环里判断条件是否满足，不满足调用wait方法</span><br><span class="line">3. 条件满足执行业务逻辑</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>通知方来说：</p><ol><li>获取对象的锁；</li><li>改变条件</li><li>通知所有等待在对象的线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Express</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CITY</span> <span class="operator">=</span> <span class="string">&quot;ShangHai&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> km;<span class="comment">/*快递运输里程数*/</span></span><br><span class="line">    <span class="keyword">private</span> String site;<span class="comment">/*快递到达地点*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Express</span><span class="params">(<span class="type">int</span> km, String site)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.km = km;</span><br><span class="line">        <span class="built_in">this</span>.site = site;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">changeKm</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.km = <span class="number">101</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">changeSite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.site = <span class="string">&quot;BeiJing&quot;</span>;</span><br><span class="line">    notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitKm</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.km&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">System.out.println(<span class="string">&quot;km thread[&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;the km is&quot;</span>+<span class="built_in">this</span>.km+<span class="string">&quot;,I will change db.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitSite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(CITY.equals(<span class="built_in">this</span>.site)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">System.out.println(<span class="string">&quot;site thread[&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;the site is&quot;</span>+<span class="built_in">this</span>.site+<span class="string">&quot;,I will call user.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWN</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Express</span> <span class="variable">express</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Express</span>(<span class="number">0</span>,Express.CITY);</span><br><span class="line">    <span class="comment">/*检查里程数变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckKm</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        express.waitKm();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查地点变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckSite</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        express.waitSite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试唤醒通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//三个线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CheckSite</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//里程数的变化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CheckKm</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//延迟一秒，让所有的线程创建并启动</span></span><br><span class="line">        express.changeKm();<span class="comment">//快递地点变化</span></span><br><span class="line">        express.changeSite();<span class="comment">//快递地点变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475</span></span><br></pre></td></tr></table></figure><h4 id="八、notify和notifyAll应该用谁？"><a href="#八、notify和notifyAll应该用谁？" class="headerlink" title="八、notify和notifyAll应该用谁？"></a>八、notify和notifyAll应该用谁？</h4><p> 应该尽量使用notifyAll，使用notify因为有可能发生信号丢失的的情况</p><h4 id="九、join方法"><a href="#九、join方法" class="headerlink" title="九、join方法"></a>九、join方法</h4><p> 线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseJoin</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JumpQueue</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;<span class="comment">//用来插队的线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JumpQueue</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currentName</span> <span class="operator">=</span> Thread.currentThread().getName()</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot; join before &quot;</span> +currentName);</span><br><span class="line">thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; terminted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">previous</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//现在是主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//i=0,previous 是主线程，i=1;previous是i=0这个线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">JumpQueue</span>(previous), String.valueOf(i));</span><br><span class="line">            System.out.println(previous.getName()+<span class="string">&quot; jump a queue the thread:&quot;</span></span><br><span class="line">                    +thread.getName());</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        SleepTools.second(<span class="number">2</span>);<span class="comment">//让主线程休眠2秒</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; terminate....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure><h4 id="十、调用yield-、sleep-、wait-、notify-等方法对锁有何影响？"><a href="#十、调用yield-、sleep-、wait-、notify-等方法对锁有何影响？" class="headerlink" title="十、调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？"></a>十、调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？</h4><ol><li>线程在执行yield()以后，持有的锁是不释放的</li><li>sleep()方法被调用以后，持有的锁是不释放的</li><li>调动wait()方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，当wait方法返回(唤醒)的时候，线程会重新持有锁</li><li>调动notify()方法之前，必须要持有锁，调用notify()方法本身不会释放锁，只有notify()所在的整个代码块跑完了才释放锁</li></ol><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p> 对象锁，锁的是类的对象实例。</p><p> 类锁 ，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynClzAndInst</span> &#123;</span><br><span class="line"><span class="comment">//使用类锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynClass</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SynClzAndInst synClzAndInst;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SynClass</span><span class="params">(SynClzAndInst synClzAndInst)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.synClzAndInst = synClzAndInst;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TestClass is running...&quot;</span> + synClzAndInst);</span><br><span class="line">            synClass(synClzAndInst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//使用对象锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceSyn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SynClzAndInst synClzAndInst;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InstanceSyn</span><span class="params">(SynClzAndInst synClzAndInst)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.synClzAndInst = synClzAndInst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TestInstance is running...&quot;</span> + synClzAndInst);</span><br><span class="line">            synClzAndInst.instance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//使用对象锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Instance2Syn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SynClzAndInst synClzAndInst;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Instance2Syn</span><span class="params">(SynClzAndInst synClzAndInst)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.synClzAndInst = synClzAndInst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TestInstance2 is running...&quot;</span> + synClzAndInst);</span><br><span class="line">            synClzAndInst.instance2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">()</span>&#123;</span><br><span class="line">        SleepTools.second(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synInstance is going...&quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">        SleepTools.second(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synInstance ended &quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instance2</span><span class="params">()</span>&#123;</span><br><span class="line">        SleepTools.second(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synInstance2 is going...&quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">        SleepTools.second(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synInstance2 ended &quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类锁，实际是锁类的class对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synClass</span><span class="params">(SynClzAndInst synClzAndInst)</span>&#123;</span><br><span class="line">        SleepTools.second(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synClass going...&quot;</span> + synClzAndInst);</span><br><span class="line">        SleepTools.second(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;synClass end&quot;</span> + synClzAndInst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SynClzAndInst</span> <span class="variable">synClzAndInst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynClzAndInst</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">InstanceSyn</span>(synClzAndInst));</span><br><span class="line">    <span class="type">SynClzAndInst</span> <span class="variable">synClzAndInst2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynClzAndInst</span>();</span><br><span class="line">    <span class="comment">//Thread t2 = new Thread(new Instance2Syn(synClzAndInst));</span></span><br><span class="line">    <span class="comment">//t1.start();</span></span><br><span class="line">    <span class="comment">//t2.start();</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">SynClass</span> <span class="variable">synClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynClass</span>(synClzAndInst);</span><br><span class="line">    synClass.start();</span><br><span class="line">        <span class="type">SynClass</span> <span class="variable">synClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynClass</span>(synClzAndInst2);</span><br><span class="line">        synClass2.start();</span><br><span class="line">        SleepTools.second(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879</span></span><br></pre></td></tr></table></figure><h4 id="synchronized的内存语义和它是如何保证并发三大特性的"><a href="#synchronized的内存语义和它是如何保证并发三大特性的" class="headerlink" title="synchronized的内存语义和它是如何保证并发三大特性的?"></a>synchronized的内存语义和它是如何保证并发三大特性的?</h4><ol><li><p><strong>synchronized实现原子性</strong></p><p>synchronized实现原子性需要多个线程之间使用相同的对象锁。这样临界区里所有的代码可以看做一个原子操作。</p><p>临界区实际是<code>monitorenter</code>和<code>monitorexit</code>中间包裹的代码块，</p></li><li><p><strong>synchronized实现有序性</strong></p><p>synchronized实现的只是禁止“工作内存与主内存同步延迟” ，并不会禁止指令重排序<code>（指令依然会重排序）</code></p><p><code>为什么synchronized不能禁止指令重排序又能保证有序性？</code></p><p>synchronized是通过<code>互斥锁</code>来保证有序性的，同步块里是单线程的，即在单线程下不管怎么重排序，程序的执行结果不能被改变。</p></li><li><p><strong>synchronized实现可见性</strong></p><p>线程解锁前，必须把工作内存中共享变量的最新值刷新到主内存中<br>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值<code>（注意：加锁与解锁需要是同一把锁）</code></p></li></ol><h4 id="synchronized可重入特性"><a href="#synchronized可重入特性" class="headerlink" title="synchronized可重入特性"></a>synchronized可重入特性</h4><p> 在Java内部，同一个线程调用自己类中其他synchronized方法&#x2F;块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，<code>同一个线程可以获取同一把锁多次，也就是可以多次重入</code>。</p><p> synchronized的锁对象中有一个计数器(recursions变量)，会记录线程获得几次锁</p><h4 id="synchronized不可中断特性"><a href="#synchronized不可中断特性" class="headerlink" title="synchronized不可中断特性"></a>synchronized不可中断特性</h4><p> 当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断</p><h4 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h4><ol><li>synchronized是关键字，而Lock是一个接口</li><li>synchronized当代码块走完后，会自动释放锁，而Lock必须在finally中手动释放锁</li><li>synchronized是不可中断的，Lock可以中断也可以不中断</li><li>synchronized可锁住方法和代码块，而Lock只能锁代码块</li><li>Lock可以使用读锁提高多线程效率</li><li>synchronized是非公平锁，而 ReentrantLock 可自己选择是否公平锁</li></ol><h4 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h4><p> JDK早期，synchronized叫重量级锁，因为申请资源必须通过内核（<code>用户态与内核态交互</code>）</p><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j8NEtzoT-1631955925732)(C:\Users\admin\Desktop\笔记\img\锁升级过程.png)]</p><p>当new一个对象时，如果没有延迟3秒，则表示偏向锁未启动（<code>new出来的为普通对象</code>），当有轻度竞争锁时，会升级成轻量级锁，如果有重度竞争，则会升级成重量级锁，相反，如果延迟3秒后创建对象并加锁，则会启用偏向锁，只要有多个线程存在竞争，偏向锁将会直接升级成轻量级锁</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><strong>volatile关键字</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示volatile不能保证其原子性，非线程安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileUnsafe</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileVar</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">a = a++;</span><br><span class="line">System.out.println(threadName+<span class="string">&quot;:======&quot;</span> + a);</span><br><span class="line">SleepTools.ms(<span class="number">100</span>);</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">System.out.println(threadName+<span class="string">&quot;:======&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">VolatileVar</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileVar</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(v);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(v);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(v);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(v);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><h4 id="一、CountDownLatch"><a href="#一、CountDownLatch" class="headerlink" title="一、CountDownLatch"></a>一、CountDownLatch</h4><p> 作用：是一组线程等待其他的线程完成工作以后在执行，加强版join，await用来等待，countDown负责计数器的减一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseCountDownLatch</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程(只有一步，有4个)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InitThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread_&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">        +<span class="string">&quot; ready init work......&quot;</span>);</span><br><span class="line">        latch.countDown();<span class="comment">//初始化线程完成工作了，countDown方法只扣减一次；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread_&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">            +<span class="string">&quot; ........continue do its work&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//业务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusiThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">latch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BusiThread_&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">            +<span class="string">&quot; do business-----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//单独的初始化线程,初始化分为2步，需要扣减两次</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">            +<span class="string">&quot; ready init work step 1st......&quot;</span>);</span><br><span class="line">                latch.countDown();<span class="comment">//每完成一步初始化工作，扣减一次</span></span><br><span class="line">                System.out.println(<span class="string">&quot;begin step 2nd.......&quot;</span>);</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">            +<span class="string">&quot; ready init work step 2nd......&quot;</span>);</span><br><span class="line">                latch.countDown();<span class="comment">//每完成一步初始化工作，扣减一次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BusiThread</span>()).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">InitThread</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main do ites work........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960</span></span><br></pre></td></tr></table></figure><h4 id="二、CyclicBarrier"><a href="#二、CyclicBarrier" class="headerlink" title="二、CyclicBarrier"></a>二、CyclicBarrier</h4><p> 让一组线程达到某个屏障，被阻塞，一直到组内最后一个线程达到屏障时，屏障开放，所有被阻塞的线程会继续运行CyclicBarrier(int parties)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，当屏障开放，barrierAction定义的任务会执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CyclicBarrier示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseCyclicBarrier</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>,<span class="keyword">new</span> <span class="title class_">CollectThread</span>());</span><br><span class="line">    <span class="comment">//存放子线程工作结果的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String,Long&gt; resultMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SubThread</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负责屏障开放以后的工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CollectThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,Long&gt; workResult : resultMap.entrySet())&#123;</span><br><span class="line">            result.append(<span class="string">&quot;[&quot;</span>+workResult.getValue()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; the result = &quot;</span>+ result);</span><br><span class="line">            System.out.println(<span class="string">&quot;do other business........&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();<span class="comment">//线程本身的处理结果</span></span><br><span class="line">            resultMap.put(Thread.currentThread().getId()+<span class="string">&quot;&quot;</span>,id);</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();<span class="comment">//随机决定工作线程的是否睡眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(r.nextBoolean()) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>+id);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span>+id+<span class="string">&quot; ....do something &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(id+<span class="string">&quot;....is await&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>+id);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span>+id+<span class="string">&quot; ....do its business &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354</span></span><br></pre></td></tr></table></figure><h4 id="三、CountDownLatch与CyclicBarrier区别"><a href="#三、CountDownLatch与CyclicBarrier区别" class="headerlink" title="三、CountDownLatch与CyclicBarrier区别"></a>三、CountDownLatch与CyclicBarrier区别</h4><ol><li>countdownlatch放行由第三者控制，CyclicBarrier放行由一组线程本身控制</li><li>countdownlatch放行条件 &gt;&#x3D; 线程数，CyclicBarrier放行条件 &#x3D; 线程数</li></ol><h4 id="四、Semaphore"><a href="#四、Semaphore" class="headerlink" title="四、Semaphore"></a>四、Semaphore</h4><p> 控制同时访问某个特定资源的线程数量，用在流量控制</p><h4 id="五、Exchange"><a href="#五、Exchange" class="headerlink" title="五、Exchange"></a>五、Exchange</h4><p> 两个线程间的数据交换</p><h4 id="六、Callable、Future和FutureTask"><a href="#六、Callable、Future和FutureTask" class="headerlink" title="六、Callable、Future和FutureTask"></a>六、Callable、Future和FutureTask</h4><p> <strong>结构图：</strong></p><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kqhVOvD9-1631955925732)(C:\Users\admin\Desktop\笔记\img\Future.png)]</p><p> <strong>方法：</strong></p><p> isDone，结束，正常还是异常结束，或者自己取消，返回true；</p><p> isCancelled：任务完成前被取消，返回true；</p><p> cancel（boolean）：</p><p> 1、 任务还没开始，返回false</p><p> 2、 任务已经启动，cancel（true），中断正在运行的任务，中断成功，返回true，cancel（false），不会去中断已经运行的任务</p><p> 3、 任务已经结束，返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *类说明：演示Future等的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseFuture</span> &#123;</span><br><span class="line"><span class="comment">/*实现Callable接口，允许有返回值*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> sum;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable子线程开始计算&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable子线程计算完成，结果=&quot;</span> + sum);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">UseCallable</span> <span class="variable">useCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCallable</span>();</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(useCallable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">SleepTools.second(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (r.nextBoolean()) &#123;<span class="comment">//随机决定是获得结果还是终止任务</span></span><br><span class="line">System.out.println(<span class="string">&quot;Get UseCallable result = &quot;</span> + futureTask.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;中断计算&quot;</span>);</span><br><span class="line">futureTask.cancel(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;是否结束：&quot;</span> + futureTask.isDone());</span><br><span class="line">System.out.println(<span class="string">&quot;是否任务完成前中断结束：&quot;</span> + futureTask.isCancelled());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="一、什么是原子操作？如何实现原子操作？"><a href="#一、什么是原子操作？如何实现原子操作？" class="headerlink" title="一、什么是原子操作？如何实现原子操作？"></a><strong>一、什么是原子操作？如何实现原子操作？</strong></h4><p>syn基于阻塞的锁的机制，会带来如下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 被阻塞的线程优先级很高</span><br><span class="line">2. 拿到锁的线程一直不释放锁怎么办？</span><br><span class="line">12</span><br></pre></td></tr></table></figure><ol><li>大量的竞争，消耗Cpu，同时带来死锁或者其他安全。</li></ol><ul><li><strong>CAS的原理</strong>：<strong>指令级别保证这是一个原子操作</strong></li></ul><p> 三个运算符： 一个内存地址V，一个期望的值A，一个新值B</p><p> 基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做更新且在</p><p>死循环（自旋）里不断的进行CAS操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AtomicInteger类   如果期望值一致，返回并更新，否则死循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseAtomicInt</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(ai.getAndIncrement());<span class="comment">//10---&gt;11 先获取再自增1</span></span><br><span class="line">System.out.println(ai.incrementAndGet());<span class="comment">//11---&gt;12先自增1再获取</span></span><br><span class="line">System.out.println(ai.get());</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="number">10</span>  <span class="number">12</span>  <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><ul><li><strong>CAS的问题</strong><ol><li>ABA问题</li><li>开销问题，CAS操作长期不成功，cpu不断的循环</li><li>只能保证一个共享变量的原子操作</li></ol></li></ul><h4 id="二、Jdk中相关原子操作类的使用"><a href="#二、Jdk中相关原子操作类的使用" class="headerlink" title="二、Jdk中相关原子操作类的使用"></a>二、Jdk中相关原子操作类的使用</h4><p><strong>更新基本类型类</strong>：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference<br><strong>更新数组类</strong>：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray<br><strong>更新引用类型</strong>：AtomicReference，AtomicMarkableReference，AtomicStampedReference<br><strong>原子更新字段类</strong>： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：演示带版本戳的原子操作类</span></span><br><span class="line"><span class="comment"> * 第一个线程修改值后，版本号自增，第二个线程用老版本号无法进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseAtomicStampedReference</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;dw&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldStamp</span> <span class="operator">=</span> asr.getStamp();<span class="comment">//拿初始的版本号</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">oldReferenc</span> <span class="operator">=</span> asr.getReference();</span><br><span class="line"></span><br><span class="line">System.out.println(oldReferenc + <span class="string">&quot;===========&quot;</span> + oldStamp);</span><br><span class="line">        </span><br><span class="line"><span class="type">Thread</span> <span class="variable">rightStampThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;当前变量值：&quot;</span> + oldReferenc + <span class="string">&quot;当前版本戳：&quot;</span> + oldStamp + <span class="string">&quot;-&quot;</span></span><br><span class="line">+ asr.compareAndSet(oldReferenc, oldReferenc + <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">oldStamp, oldStamp + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">errorStampThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">reference</span> <span class="operator">=</span> asr.getReference();</span><br><span class="line">System.out.println(Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;当前变量值：&quot;</span> + reference + <span class="string">&quot;当前版本戳：&quot;</span> + asr.getStamp() + <span class="string">&quot;-&quot;</span></span><br><span class="line">+ asr.compareAndSet(reference, reference + <span class="string">&quot;C&quot;</span>,</span><br><span class="line">oldStamp, oldStamp + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rightStampThread.start();</span><br><span class="line">rightStampThread.join();</span><br><span class="line">errorStampThread.start();</span><br><span class="line">errorStampThread.join();</span><br><span class="line">System.out.println(asr.getReference() + <span class="string">&quot;===========&quot;</span> + asr.getStamp());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span></span><br></pre></td></tr></table></figure><h3 id="显示锁Lock"><a href="#显示锁Lock" class="headerlink" title="显示锁Lock"></a><strong>显示锁Lock</strong></h3><h4 id="一、Lock接口和核心方法："><a href="#一、Lock接口和核心方法：" class="headerlink" title="一、Lock接口和核心方法："></a>一、Lock接口和核心方法：</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5PBxxHjm-1631955925733)(C:\Users\admin\Desktop\笔记\img\Lock.png)]</p><h4 id="二、Lock接口和synchronized的比较"><a href="#二、Lock接口和synchronized的比较" class="headerlink" title="二、Lock接口和synchronized的比较"></a>二、Lock接口和synchronized的比较</h4><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VlxkVzr5-1631955925734)(C:\Users\admin\Desktop\笔记\img\Lock与Sync区别.png)]</p><p> Lock应用场景：获取锁可以被中断，超时获取锁，尝试获取锁</p><h4 id="三、可重入锁ReentrantLock、所谓锁的公平和非公平"><a href="#三、可重入锁ReentrantLock、所谓锁的公平和非公平" class="headerlink" title="三、可重入锁ReentrantLock、所谓锁的公平和非公平"></a>三、可重入锁ReentrantLock、所谓锁的公平和非公平</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**ReentrantLock是Lock接口的一个实现类** </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> <strong>可重入：</strong>一个线程在持有一个锁的时候，它内部能否再次（多次）申请该锁。如果一个线程已经获得了锁，其内部还可以多次申请该锁成功。那么我们就称该锁为可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁示例</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    methodB();</span><br><span class="line">    lock.unlock() <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">// 其他业务</span></span><br><span class="line">    lock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p> 可重入锁可以理解为锁的一个标识。该标识具备计数器功能。标识的初始值为0，表示当前锁没有被任何线程持有。每次线程获得一个可重入锁的时候，该锁的计数器就被加1。每次一个线程释放该所的时候，该锁的计数器就减1。前提是：当前线程已经获得了该锁，是在线程的内部出现再次获取锁的场景</p><p> 参考： <a href="https://www.cnblogs.com/1013wang/p/11820373.html">https://www.cnblogs.com/1013wang/p/11820373.html</a></p><p> <strong>公平和非公平：</strong>如果在时间上，先对锁进行获取的请求，一定先被满足，这个锁就是公平的，不满足，就是非公平的，非公平的效率一般来讲更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用显示锁的范式,释放锁unlock必须在finally代码块中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increament</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h4 id="四、ReadWriteLock接口和读写锁ReentrantReadWriteLock"><a href="#四、ReadWriteLock接口和读写锁ReentrantReadWriteLock" class="headerlink" title="四、ReadWriteLock接口和读写锁ReentrantReadWriteLock"></a>四、ReadWriteLock接口和读写锁ReentrantReadWriteLock</h4><p> ReentrantLock和synchronized关键字，都是排他锁</p><p> <strong>读写锁：</strong>同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例  用synchronized与ReadWriteLock展示读写的性能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：商品的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> totalMoney;<span class="comment">//总销售额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> storeNumber;<span class="comment">//库存数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodsInfo</span><span class="params">(String name, <span class="type">int</span> totalMoney, <span class="type">int</span> storeNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.totalMoney = totalMoney;</span><br><span class="line">        <span class="built_in">this</span>.storeNumber = storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStoreNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeNumber</span><span class="params">(<span class="type">int</span> sellNumber)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.totalMoney += sellNumber*<span class="number">25</span>;</span><br><span class="line">        <span class="built_in">this</span>.storeNumber -= sellNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：商品的服务的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span>;<span class="comment">//获得商品的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span>;<span class="comment">//设置商品的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：用synchronized内置锁来实现商品服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseSyn</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> GoodsInfo goodsInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UseSyn</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">SleepTools.ms(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.goodsInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">SleepTools.ms(<span class="number">5</span>);</span><br><span class="line">goodsInfo.changeNumber(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  类说明：用读写锁来实现商品服务接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseRwLock</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GoodsInfo goodsInfo;<span class="comment">//商品实体</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();<span class="comment">//读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">getLock</span> <span class="operator">=</span> lock.readLock();<span class="comment">//内部获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">setLock</span> <span class="operator">=</span> lock.writeLock();<span class="comment">//内部获取写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseRwLock</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">getLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SleepTools.ms(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.goodsInfo;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">getLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">setLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SleepTools.ms(<span class="number">5</span>);</span><br><span class="line">goodsInfo.changeNumber(number);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">setLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *类说明：测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusiApp</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">readWriteRatio</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//读写线程的比例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">minthreadCount</span> <span class="operator">=</span> <span class="number">3</span>;<span class="comment">//最少线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义读操作的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GetThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GetThread</span><span class="params">(GoodsService goodsService)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.goodsService = goodsService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;<span class="comment">//操作100次</span></span><br><span class="line">                goodsService.getNum();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取商品数据耗时：&quot;</span></span><br><span class="line">             +(System.currentTimeMillis()-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    定义写操作的线程</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SetThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SetThread</span><span class="params">(GoodsService goodsService)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.goodsService = goodsService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;<span class="comment">//操作10次</span></span><br><span class="line">            SleepTools.ms(<span class="number">50</span>);</span><br><span class="line">                goodsService.setNum(r.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">            +<span class="string">&quot;写商品数据耗时：&quot;</span>+(System.currentTimeMillis()-start)+<span class="string">&quot;ms---------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GoodsInfo</span> <span class="variable">goodsInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;Cup&quot;</span>, <span class="number">100000</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//用synchronized与读写锁测试</span></span><br><span class="line">        <span class="type">GoodsService</span> <span class="variable">goodsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseRwLock</span>(goodsInfo);<span class="comment">/*new UseSyn(goodsInfo);*/</span></span><br><span class="line">        <span class="comment">//用三组线程来演示</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; minthreadCount; i++)&#123;</span><br><span class="line">            <span class="comment">//每组读写线程的比例为1:10   总共为三组线程，读线程30个，写线程3个</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">setT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SetThread</span>(goodsService));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt; readWriteRatio; j++) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">getT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">GetThread</span>(goodsService));</span><br><span class="line">                getT.start(); <span class="comment">//让读线程先启动          </span></span><br><span class="line">            &#125;</span><br><span class="line">            SleepTools.ms(<span class="number">100</span>);</span><br><span class="line">            setT.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169</span></span><br></pre></td></tr></table></figure><h4 id="五、Lock中Condition"><a href="#五、Lock中Condition" class="headerlink" title="五、Lock中Condition"></a>五、Lock中Condition</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的这些方法是和同步锁捆绑使用的；而Condition是需要与互斥锁/共享锁捆绑使用的。</span><br><span class="line">2. Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p><strong>用Lock和Condition实现等待通知</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *类说明：用Lock和Condition实现等待通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressCond</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CITY</span> <span class="operator">=</span> <span class="string">&quot;ShangHai&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> km;<span class="comment">/*快递运输里程数*/</span></span><br><span class="line">    <span class="keyword">private</span> String site;<span class="comment">/*快递到达地点*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">kmCond</span> <span class="operator">=</span> lock.newCondition();  <span class="comment">//里程数Condition条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">siteCond</span> <span class="operator">=</span> lock.newCondition();   <span class="comment">//地点Condition条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExpressCond</span><span class="params">(<span class="type">int</span> km, String site)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.km = km;</span><br><span class="line">        <span class="built_in">this</span>.site = site;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeKm</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.km = <span class="number">101</span>;</span><br><span class="line">            kmCond.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理*/</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">changeSite</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.site = <span class="string">&quot;BeiJing&quot;</span>;</span><br><span class="line">        siteCond.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*当快递的里程数大于100时更新数据库*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitKm</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.km&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                    kmCond.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;check km thread[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">    +<span class="string">&quot;] is be notifed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;the Km is &quot;</span>+<span class="built_in">this</span>.km+<span class="string">&quot;,I will change db&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*当快递到达目的地时通知用户*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitSite</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(CITY.equals(<span class="built_in">this</span>.site)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        siteCond.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;check site[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">                                       +<span class="string">&quot;]is be notifed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;the site is &quot;</span>+<span class="built_in">this</span>.site+<span class="string">&quot;,I will call user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：测试Lock和Condition实现等待通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCond</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExpressCond</span> <span class="variable">express</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressCond</span>(<span class="number">0</span>,ExpressCond.CITY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查里程数变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckKm</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        express.waitKm();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查地点变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckSite</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        express.waitSite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CheckSite</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CheckKm</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        express.changeKm();<span class="comment">//快递里程变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113</span></span><br></pre></td></tr></table></figure><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="一、什么是线程池？为什么要用线程池？"><a href="#一、什么是线程池？为什么要用线程池？" class="headerlink" title="一、什么是线程池？为什么要用线程池？"></a>一、什么是线程池？为什么要用线程池？</h4><h4 id="二、线程池执行流程"><a href="#二、线程池执行流程" class="headerlink" title="二、线程池执行流程"></a>二、线程池执行流程</h4><ol><li>当放入线程池中的线程小于corePoolSize时，线程池内部会启动线程去执行，</li><li>当不小于coolPoolSize时，且小于maximumPool时，线程往阻塞队列里面存，</li><li>当队列存放失败时，且小于最大线程数maximumPool时，会尝试开启新的线程去执行</li><li>当上述三条都不满足时，会调用reject方法，执行拒绝策略</li></ol><h4 id="三、线程池提交任务"><a href="#三、线程池提交任务" class="headerlink" title="三、线程池提交任务"></a>三、线程池提交任务</h4><p> execute：不需要返回</p><p> submit： 需要返回</p><h4 id="四、各个参数含义"><a href="#四、各个参数含义" class="headerlink" title="四、各个参数含义"></a>四、各个参数含义</h4><p><strong>int</strong> corePoolSize ：线程池中核心线程数，&lt; corePoolSize ，就会创建新线程，&#x3D; corePoolSize ，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize 个数的线程。</p><p><strong>int</strong> maximumPoolSize,：允许的最大线程数，BlockingQueue也满了，&lt; maximumPoolSize时候就会再次创建新的线程</p><p><strong>long</strong> keepAliveTime：线程空闲下来后，存活的时间，这个参数只在 &gt; corePoolSize才有用</p><p>TimeUnit unit,：存活时间的单位值</p><p>BlockingQueue workQueue：保存任务的阻塞队列</p><p>ThreadFactory threadFactory,：创建线程的工厂，给新建的线程赋予名字</p><p>RejectedExecutionHandler handler ：饱和策略</p><p> AbortPolicy ：直接抛出异常，默认；</p><p> CallerRunsPolicy：用调用者所在的线程来执行任务</p><p> DiscardOldestPolicy：丢弃阻塞队列里最老的任务，队列里最靠前的任务</p><p> DiscardPolicy ：当前任务直接丢弃</p><p>实现自己的饱和策略，实现RejectedExecutionHandler接口即可</p><h4 id="五、预定义的线程池"><a href="#五、预定义的线程池" class="headerlink" title="五、预定义的线程池"></a>五、预定义的线程池</h4><p><strong>FixedThreadPoo：</strong></p><p>创建固定线程数量的，适用于负载较重的服务器，使用了无界队列</p><p><strong>SingleThreadExecutor：</strong></p><p>创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列</p><p><strong>CachedThreadPool：</strong></p><p>会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了SynchronousQueue</p><p><strong>ScheduledThreadPoolExecutor：</strong></p><p>需要定期执行周期任务，Timer不建议使用了。</p><h4 id="六、合理配置线程池"><a href="#六、合理配置线程池" class="headerlink" title="六、合理配置线程池"></a>六、合理配置线程池</h4><p>根据任务的性质来：计算密集型（CPU），IO密集型，混合型</p><p>计算密集型：机器的Cpu核心数+1，为什么+1，防止页缺失</p><p>IO密集型：读取文件，数据库连接，网络通讯, 线程数适当大一点，机器的Cpu核心数 * 2</p><p>混合型：尽量拆分，范围在IO密集型~计算密集型之间</p><h1 id="十一、Mysql"><a href="#十一、Mysql" class="headerlink" title="十一、Mysql"></a>十一、Mysql</h1><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="一、Mysql体系架构"><a href="#一、Mysql体系架构" class="headerlink" title="一、Mysql体系架构"></a>一、Mysql体系架构</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hztTgb2M-1631955925740)(C:\Users\admin\Desktop\笔记\img\mysql体系架构.png)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看出 MySQL 最上层是连接组件。下面服务器是由**连接池**、**管理工具和服务**、**SQL 接口**、**解析器**、**优化器**、**缓存**、**存储引擎**、**文件系统**组成。 </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> <strong>连接池</strong>：由于每次建立建立需要消耗很多时间，连接池的作用就是将这些连 接缓存下来，下次可以直接用已经建立好的连接，提升服务器性能。 管理工具和服务：系统管理和控制工具，例如备份恢复、Mysql 复制、集群 等</p><p> <strong>SQL 接口</strong>：接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**解析器**: SQL 命令传递到解析器的时候会被解析器验证和解析。解析器主要功能： </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> a . 将 SQL 语句分解成数据结构，并将这个结构传递到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的</p><p> b. 如果在分解构成中遇到错误，那么就说明这个 sql 语句是不合理的</p><p> <strong>优化器</strong>：查询优化器，SQL 语句在查询之前会使用查询优化器对查询进行优化。</p><p> <strong>缓存器</strong>： 查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等。</p><p> <strong>存储引擎</strong> ：目前用的最多的就是InnoDB（支持事务）、MyISAM（不支持事务）</p><p> <strong>文件系统</strong>：数据库存储的数据最终都会落地到本地磁盘中</p><h4 id="二、MySQL逻辑架构-连接层、Server层和存储引擎"><a href="#二、MySQL逻辑架构-连接层、Server层和存储引擎" class="headerlink" title="二、MySQL逻辑架构 - 连接层、Server层和存储引擎"></a>二、MySQL逻辑架构 - 连接层、Server层和存储引擎</h4><p> <strong>连接层：</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9DCKPyUy-1631955925741)(C:\Users\admin\Desktop\笔记\img\mysql连接层.png)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当 MySQL 启动（MySQL 服务器就是一个进程） ， 等待客户端连接， 每一个客户端连接请求， 服务器都会新建一个线程处理（如果是线程池的话， 则是分配一个空的线程） ， 每个线程独立， 拥有各自的内存处理空间 </span><br><span class="line"></span><br><span class="line"> 查看数据库最大连接数 ：show VARIABLES like &#x27;%max_connections%&#x27; </span><br><span class="line">123</span><br></pre></td></tr></table></figure><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ls2J2EOX-1631955925741)(C:\Users\admin\Desktop\笔记\img\mysql连接验证.png)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">连接到服务器， 服务器需要对其进行验证， 也就是用户名、 IP、 密码验证，一旦连接成功， 还要验证是否具有执行某个特定查询的权限（例如， 是否允许客户端对某个数据库某个表的某个操作）  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> <strong>Service层：</strong></p><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LcciNO5E-1631955925742)(C:\Users\admin\Desktop\笔记\img\service层.png)]</p><p>这一层主要功能有： SQL 语句的解析、 优化， 缓存的查询， MySQL 内置函数的实现， 跨存储引擎功能（所谓跨存储引擎就是说每个引擎都需提供的功能（引擎需对外提供接口）） ， 例如： 存储过程、 触发器、 视图等。</p><p>1.如果是查询语句（select 语句） ， 首先会查询缓存是否已有相应结果， 有则返回结果， 无则进行下一步（如果不是查询语句， 同样调到下一步）</p><p>2.解析查询， 创建一个内部数据结构（解析树） ， 这个解析树主要用来 SQL语句的语义与语法解析；</p><p>3.优化 SQL 语句， 例如重写查询， 决定表的读取顺序， 以及选择需要的索引等。 这一阶段用户是可以查询的， 查询服务器优化器是如何进行优化的，便于用户重构查询和修改相关配置， 达到最优化。 这一阶段还涉及到存储引擎，优化器会询问存储引擎， 比如某个操作的开销信息、 是否对特定索引有查询优化等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从 8.0 开始， MySQL 不再使用查询缓存，因为无法预测其性能，且会导致大量的互斥锁争用</span><br></pre></td></tr></table></figure><h4 id="三、MySQL-官方引擎"><a href="#三、MySQL-官方引擎" class="headerlink" title="三、MySQL 官方引擎"></a>三、MySQL 官方引擎</h4><p><code>InnoDB</code>：InnoDB 是 MySQL 的默认事务型引擎， 也是最重要、 使用最广泛的存储引擎。</p><p><code>MylSAM</code>： 在 MySQL 5.1 及之前的版本， MyISAM 是默认的存储引擎。 MyISAM 提供了大量的特性， 包括全文索引、 压缩、 空间函数（GIS） 等， 但 MyISAM 不支持事务和行级锁， 而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看mysql提供的引擎：show engines;</span><br><span class="line">查看mysql默认的存储引擎：show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h4 id="四、MyISAM-和-InnoDB-比较"><a href="#四、MyISAM-和-InnoDB-比较" class="headerlink" title="四、MyISAM 和 InnoDB 比较"></a>四、MyISAM 和 InnoDB 比较</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GfrO2jUx-1631955925742)(C:\Users\admin\Desktop\笔记\img\引擎比较.png)]</p><h4 id="五、MySQL-中的数据目录"><a href="#五、MySQL-中的数据目录" class="headerlink" title="五、MySQL 中的数据目录"></a>五、MySQL 中的数据目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看mysql中的数据目录：show variables like &#x27;datadir&#x27;;  --这个目录可以通过配置文件进行修改</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对于 InnoDB 数据会以<code>xxx.frm(存放元数据)</code>与<code>xxx.idb(存表数据和索引)</code>格式存放</p><p>对于 MyISAM 数据和索引是分开存放的 ，以<code>xxx.frm(存放元数据)</code>、<code>xxx.MYI(存放索引)</code>、<code>xxx.MYD(存表数据)</code>格式存放</p><h4 id="六、日志文件"><a href="#六、日志文件" class="headerlink" title="六、日志文件"></a>六、日志文件</h4><p> 常见的日志文件有： 错误日志（error log） 、 慢查询日志（slow query log） 、查询日志（query log） 、 二进制文件（bin log） 。</p><p><code>错误日志</code>： 错误日志文件对 MySQL 的启动、 运行、 关闭过程进行了记录。 遇到问题时应该首先查看该文件以便定位问题。 该文件不仅记录了所有的错误信息， 也记录一些警告信息或正确的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看错误日志文件的位置：show variables like &#x27;log_error&#x27;;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><code>查询日志</code>： 查询日志记录了所有对 MySQL 数据库请求的信息， 无论这些请求是否得到了正确的执行。默认文件名： 主机名.log</p><p><code>二进制日志(binlog)</code>： 二进制日志记录了对 MySQL 数据库执行更改的所有操作， 若操作本身没有导致数据库发生变化， 该操作可能也会写入二进制文件。 但是不包括 select 和show 这类操作（因为这些操作对数据本身不会进行修改）</p><h3 id="MySQL-中的系统库"><a href="#MySQL-中的系统库" class="headerlink" title="MySQL 中的系统库"></a>MySQL 中的系统库</h3><h4 id="系统库简介"><a href="#系统库简介" class="headerlink" title="系统库简介"></a>系统库简介</h4><p><code>performance_schema</code>： 这个数据库里主要保存 MySQL 服务器运行过程中的一些状态信息， 算是对MySQL 服务器的一个性能监控。 包括统计最近执行了哪些语句， 在执行过程的每个阶段都花费了多长时间， 内存的使用情况等等信息。</p><p><code>information_schema</code>： 这个数据库保存着 MySQL 服务器维护的所有其他数据库的信息， 比如有哪些表、 哪些视图、 哪些触发器、 哪些列、 哪些索引。 这些信息并不是真实的用户数据， 而是一些描述性信息， 有时候也称之为元数据。</p><p><code>sys</code>： 这个数据库主要是通过视图的形式把 information_schema 和performance_schema 结合起来， 让程序员可以更方便的了解 MySQL 服务器的一些性能信息。</p><p><code>mysql</code>： 这个数据库核心， 它存储了 MySQL 的用户账户和权限信息， 一些存储过程、事件的定义信息， 一些运行过程中产生的日志信息， 一些帮助信息以及时区信息等。</p><h3 id="Mysql中的事务"><a href="#Mysql中的事务" class="headerlink" title="Mysql中的事务"></a>Mysql中的事务</h3><p> 事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事务），要不全部成功，要不全部不成功。</p><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p> 事务应该具有 4 个属性： 原子性、 一致性、 隔离性、 持久性。 这四个属性通常称为 ACID 特性。</p><p> <code>原子性（atomicity）</code></p><p> <code>一致性（consistency）</code></p><p> <code>隔离性（isolation）</code></p><p> <code>持久性（durability）</code></p><h4 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务必须被视为一个不可分割的最小单元， 整个事务中的所有操作要么全部提交成功， 要么全部失败， 对于一个事务来说， 不能只执行其中的一部分操作。   </span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一致性是指事务将数据库从一种一致性转换到另外一种一致性状态， 在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p> 例子：A账户给B账户转账1000元</p><p> 1.A工资卡扣除 1000 元</p><p> 2.B工资卡增加 1000</p><p>扣除的钱（-1000） 与增加的钱（1000） 相加应该为 0， 或者说 A和B账户的钱加起来， 前后应该不变。</p><h4 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h4><p> 一旦事务提交，所做的修改就会永久保存到数据库中。 此时即使系统崩溃， 已经提交的修改数据也不会丢失。</p><h4 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h4><p> 一个事务的执行不能被其他事务干扰。 即一个事务内部的操作及使用的数据对并发的其他事务是隔离的， 并发执行的各个事务之间不能互相干扰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果隔离性不能保证， 会导致什么问题？</span><br></pre></td></tr></table></figure><p>例：A给B转账两次， 每次都是 500， A卡里开始有 1200， B卡里开始有 300， 从理论上转完后， A卡里有 200， B卡里应该有 1300。<br>我们将同时进行的两次转账操作分别称为 T1 和 T2， 在现实世界中 T1 和 T2 是应该没有关系的， 可以先执行完 T1， 再执行 T2， 或者先执行完 T2， 再执行 T1， 结果都是一样的。 但是很不幸， 真实的数据库中 T1 和T2 的操作可能交替执行的， 执行顺序就有可能是：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gb5rZQnI-1631955925743)(C:\Users\admin\Desktop\笔记\img\隔离性.png)]</p><p> 对数据库操作来说， 不仅要保证这些操作以原子性的方式执行完成， 而且要保证其它的状态转换不会影响到本次状态转换， 这个规则被称之为隔离性。</p><h3 id="事务并发引发的问题"><a href="#事务并发引发的问题" class="headerlink" title="事务并发引发的问题"></a>事务并发引发的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>当一个事务读取到了另外一个事务修改但未提交的数据， 被称为脏读</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ko0eEq9u-1631955925743)(C:\Users\admin\Desktop\笔记\img\脏读.png)]</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>当事务内相同的记录被检索两次， 且两次得到的结果不同时， 此现象称为不可重复读</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VKzo8BYQ-1631955925744)(C:\Users\admin\Desktop\笔记\img\不可重复读.png)]</p><p>事务 2 对记录做了修改并提交成功， 这意味着修改的记录对其他事务是可见的，因此事务 1 两次读取的 money 值不同</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>在事务执行过程中， 另一个事务将新记录添加到正在读取的事务中时， 会发生幻读。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gJfU8rgC-1631955925744)(C:\Users\admin\Desktop\笔记\img\幻读.png)]</p><p>如果事务 2 中是删除了符合的记录而不是插入新记录，那事务 1 中之后再根据条件读取的记录变少了， 这种现象算不算幻读呢？ 明确说一下， 在 MySQL 中这种现象不属于幻读， 幻读强调的是一个事务按照某个相同条件多次读取记录时， 后读取时读到了之前没有读到的记录。</p><h4 id="SQL-标准中的四种隔离级别"><a href="#SQL-标准中的四种隔离级别" class="headerlink" title="SQL 标准中的四种隔离级别"></a>SQL 标准中的四种隔离级别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure><p>隔离级别越低， 越严重的问题就越可能发生(<code>未提交读级别最低</code>)</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-v0s7lwIH-1631955925745)(C:\Users\admin\Desktop\笔记\img\sql隔离级别.png)]</p><h4 id="MySQL-中的隔离级别"><a href="#MySQL-中的隔离级别" class="headerlink" title="MySQL 中的隔离级别"></a>MySQL 中的隔离级别</h4><p> 不同的数据库厂商对 SQL 标准中规定的四种隔离级别支持不一样， 比方说Oracle 就只支持 READ COMMITTED 和 SERIALIZABLE 隔离级别。 MySQL 虽然支持 4 种隔离级别， 但与 SQL 标准中所规定的各级隔离级别允许发<br>生的问题却有些出入， MySQL 在 REPEATABLE READ 隔离级别下， 是可以禁止幻读问题的发生的。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-16oZwUtF-1631955925745)(C:\Users\admin\Desktop\笔记\img\mysql隔离级别.png)]</p><p>MySQL 的默认隔离级别为 <code>REPEATABLE READ</code>， 我们可以手动修改事务的隔离级别。</p><h4 id="设置事务的隔离级别"><a href="#设置事务的隔离级别" class="headerlink" title="设置事务的隔离级别"></a>设置事务的隔离级别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>使用 GLOBAL 关键字（在全局范围影响）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">只对执行完该语句之后产生的会话起作用。 当前已经存在的会话无效。</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>使用 SESSION 关键字（在会话范围影响）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">对当前会话的所有后续的事务有效,该语句可以在已经开启的事务中间执行， 但不会影响当前正在执行的事务。如果在事务之间执行， 则对后续的事务有效。</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>上述两个关键字都不用（只对执行语句后的下一个事务产生影响） ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如：SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">只对当前会话中下一个即将开启的事务有效。下一个事务执行完后，后续事务将恢复到之前的隔离级别。 </span><br><span class="line">该语句不能在已经开启的事务中间执行，会报错的。</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>如果我们在服务器启动时想改变事务的默认隔离级别， 可以修改启动参数transaction-isolation 的值， 比方说我们在启动服务器时指定了 –transaction-isolation&#x3D;SERIALIZABLE， 那么事务的默认隔离级别就从原来的可重复读REPEATABLE READ 变成了 SERIALIZABLE。</p><p>想要查看当前会话默认的隔离级别可以通过查看系统变量 <code>transaction_isolation</code>的值来确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="高性能索引"><a href="#高性能索引" class="headerlink" title="高性能索引"></a>高性能索引</h3><p>索引： 索引（Index） 是帮助 MySQL 高效获取数据的数据结构。</p><p>索引的本质： 索引是数据结构</p><p>索引的作用：高效获取数据（<code>尽可能的多让数据顺序读写,少让数据随机读写,减少IO消耗</code>）</p><p>InnoDB 存储引擎支持以下几种常见的索引： B+树索引、 全文索引、 哈希索引， 其中比较关键的是 B+树索引</p><h4 id="HashMap-适合做数据库索引吗？"><a href="#HashMap-适合做数据库索引吗？" class="headerlink" title="HashMap 适合做数据库索引吗？"></a>HashMap 适合做数据库索引吗？</h4><ol><li>hash 表只能匹配是否相等， 不能实现范围查找；</li><li>当需要按照索引进行 order by 时， hash 值没办法支持排序；</li><li>组合索引可以支持部分索引查询， 如(a,b,c)的组合索引， 查询中只用到了a和 b 也可以查询的， 如果使用 hash 表， 组合索引会将几个字段合并 hash， 没办法支持部分索引；</li><li>当数据量很大时， hash 冲突的概率也会非常大。</li></ol><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p> B+树索引就是传统意义上的索引， 这是目前关系型数据库系统中查找最常用和最为有效的索引。 B+树索引的构造类似于二叉树， 根据键值（Key Value） 快速找到数据。 注意 B+树中的 B 不是代表二叉(binary)， 而是代表平衡(balance)， 因为 B+树是从最早的平衡二叉树、B树演化而来， 但是 B+树不是一个二叉树。</p><p> B+树是 B 树的一种变形形式， B+树上的叶子结点存储关键字以及相应记录的地址， 叶子结点以上各层作为索引使用，一棵 m 阶的 B+树定义如下:</p><ul><li>每个节点最多可以有 m 个元素；</li><li>除了根节点外， 每个节点最少有 (m&#x2F;2) 个元素；</li><li>如果根节点不是叶子节点， 那么它最少有 2 个孩子节点；</li><li>所有的叶子节点都在同一层；</li><li>一个有 k 个孩子节点的非叶子节点有 (k-1) 个元素， 按升序排列；</li><li>某个元素的左子树中的元素都比它小， 右子树的元素都大于或等于它；</li><li>非叶子节点只存放关键字和指向下一个孩子节点的索引， 记录只存放在叶子节点中；</li><li>相邻的叶子节点之间用指针相连。</li></ul><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hubk8tX4-1631955925746)(C:\Users\admin\Desktop\笔记\img\B+树.png)]</p><p>B+树的几个特征 ：</p><ul><li>相同节点数量的情况下， B+树高度远低于平衡二叉树；</li><li>非叶子节点只保存索引信息和下一层节点的指针信息， 不保存实际数据记录；</li><li>每个叶子页（LeafPage） 存储了实际的数据， 比如上图中每个叶子页就存放了 3 条数据记录， 当然可以更多， 叶子节点由小到大（有序） 串联在一起，叶子页中的数据也是排好序的；</li><li>索引节点指示该节点的左子树比这个索引值小， 而右子树大于等于这个索引值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引列的值在内部由小到大排好了序，根据索引的最左匹配列依次排序</span><br></pre></td></tr></table></figure><h4 id="聚集索引-x2F-聚簇索引"><a href="#聚集索引-x2F-聚簇索引" class="headerlink" title="聚集索引&#x2F;聚簇索引"></a>聚集索引&#x2F;聚簇索引</h4><p> InnoDB 中使用了聚集索引， 就是将表的主键用来构造一棵 B+树， 并且将整张表的行记录数据存放在该 B+树的叶子节点中。 也就是所谓的索引即数据， 数据即索引。 由于聚集索引是利用表的主键构建的， 所以每张表只能拥有一个聚集索引。</p><p> <strong>优点 ：</strong> 通过聚集索引能获取完整的整行数据。对于主键的排序查找和范围查找速度非常快。</p><p> 如果我们没有定义主键， MySQL 会使用唯一性索引， 没有唯一性索引，MySQL 也会创建一个隐含列 RowID 来做主键， 然后用这个主键来建立聚集索引。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0E8ltmJW-1631955925746)(C:\Users\admin\Desktop\笔记\img\聚集索引.png)]</p><h4 id="辅助索引-x2F-二级索引"><a href="#辅助索引-x2F-二级索引" class="headerlink" title="辅助索引&#x2F;二级索引"></a>辅助索引&#x2F;二级索引</h4><p> 所谓辅助索引（也称二级索引、 非聚集索引），就是非主键索引，用普通的列创建的索引</p><p> 对于辅助索引， 叶子节点并不包含行记录的全部数据。而是包含键值及主键，比如辅助索引列为note</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BaCq4gDi-1631955925746)(C:\Users\admin\Desktop\笔记\img\辅助索引.png)]</p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p> <code>要查询的列在辅助索引中不存在，必须通过辅助索引找到主键，再用主键找聚集索引获取全部的列数据</code></p><p> 辅助索引的存在并不影响数据在聚集索引中的组织， 因此每张表上可以有多个辅助索引。 当通过辅助索引来寻找数据时， InnoDB 存储引擎会遍历辅助索引，并通过叶级别的指针获得指向主键索引的主键， 然后再通过主键索引来找到一个完整的行记录。 这个过程也被称为回表。 也就是根据辅助索引的值查询一条完整的用户记录需要使用到 2 棵 B+树—-一次辅助索引， 一次聚集索引。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qKaJOa64-1631955925747)(C:\Users\admin\Desktop\笔记\img\回表.png)]</p><h4 id="组合索引-x2F-联合索引-x2F-复合索引"><a href="#组合索引-x2F-联合索引-x2F-复合索引" class="headerlink" title="组合索引&#x2F;联合索引&#x2F;复合索引"></a>组合索引&#x2F;联合索引&#x2F;复合索引</h4><p> 构建索引有多个字段组成，我们称之为组合索引、联合索引或者复合索引， 比如 index(a,b)就是将 a,b 两个<br>列组合起来构成一个索引。</p><p>千万要注意一点， 建立联合索引只会建立 1 棵 B+树， 多个列分别建立索引，会分别以每个列建立 B+树， 有几个索引就有几个 B+树， 比如， index(note)、index(b)， 就分别对 note,b 两个列各构建了一个索引。</p><p> index(note, b)在索引构建上， 包含了两个意思：</p><ul><li>先把各个记录按照 note 列进行排序。</li><li>在记录的 note 列相同的情况下， 采用 b 列进行排序</li></ul><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e4oV5HFM-1631955925747)(C:\Users\admin\Desktop\笔记\img\组合索引.png)]</p><h4 id="覆盖索引-x2F-索引覆盖"><a href="#覆盖索引-x2F-索引覆盖" class="headerlink" title="覆盖索引&#x2F;索引覆盖"></a>覆盖索引&#x2F;索引覆盖</h4><p> InnoDB 存储引擎支持覆盖索引(covering index， 或称索引覆盖)， 即从辅助索引中就可以得到查询的记录， 而不需要回表操作。 使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息， 故其大小要远小于聚集索引， 因此可以减少大量的 IO 操作。 覆盖索引是一种概念，并不是索引类型的一种。</p><blockquote><p>如图针对note、b列建立组合索引，而select语句中只查询b，在组合索引中已经包含了b，此时只查一次组合索引就可以得到数据，不需要回表，就称之为覆盖索引</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0z3QyjbM-1631955925748)(C:\Users\admin\Desktop\笔记\img\覆盖索引.png)]</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p> InnoDB 存储引擎除了我们前面所说的各种索引， 还有一种自适应哈希索引，我们知道 B+树的查找次数,取决于 B+树的高度,在生产环境中,B+树的高度一般为 3<del>4 层,故需要 3</del>4 次的 IO 查询。<br> 所以在 InnoDB 存储引擎内部自己去监控索引表， 如果监控到某个索引经常用， 那么就认为是热数据， 然后内部自己创建一个 hash 索引， 称之为自适应哈希索引( Adaptive Hash Index,AHI)， 创建以后， 如果下次又查询到这个索引，那么直接通过 hash 算法推导出记录的地址， 直接一次就能查到数据， 比重复去B+tree 索引中查询三四次节点的效率高了不少。</p><blockquote><p>对于自适应哈希索引仅是数据库自身创建并使用的， 我们并不能对其进行干预。 通过命令 :</p><p><strong>show engine innodb status\G</strong> 可以看到当前自适应哈希索引的使用状况，</p></blockquote><h4 id="全文检索之倒排索引"><a href="#全文检索之倒排索引" class="headerlink" title="全文检索之倒排索引"></a>全文检索之倒排索引</h4><p> 什么是全文检索（Full-Text Search） ？ 它是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。 它可以根据需要获得全文中有关章、节、段、 句、词等信息， 也可以进行各种统计和分析。 我们比较熟知的 Elasticsearch、Solr 等就是全文检索引擎， 底层都是基于 Apache Lucene 的。</p><p><strong>全文检索中倒排索引解释见Elasticsearch章节</strong></p><h4 id="深入思考索引在查询中的使用"><a href="#深入思考索引在查询中的使用" class="headerlink" title="深入思考索引在查询中的使用"></a>深入思考索引在查询中的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引在查询中的作用到底是什么？ 在我们的查询中发挥着什么样的作用呢？请记住：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>一个索引就是一个 B+树， 索引让我们的查询可以快速定位扫描到我们需要的数据记录上， 加快查询的速度。</li><li>一个 select 查询语句在执行过程中一般最多能使用一个二级索引， 即使在 where 条件中用了多个二级索引。</li></ul><h4 id="扫描区间"><a href="#扫描区间" class="headerlink" title="扫描区间"></a>扫描区间</h4><p> 所谓扫描区间就是根据索引已经排好的顺序，在where条件中只过滤一个范围再进行查找。 由于 B+树叶子节点中的记录是按照索引列值由小到大的顺序排序的， 所以即使只扫描某个区间或者某些区间中的记录也可以明显减<br>少需要扫描的记录数量。 比如下面这个查询语句：</p><blockquote><p>SELECT * FROM order_exp WHERE id &gt;&#x3D; 3 AND id&lt;&#x3D; 99;</p></blockquote><p>这个语句其实是想查找 id 值在[3,99]区间中的所有聚簇索引记录。 我们定位到 id 值为 3 的那条聚簇索引记录， 然后沿着记录所在的单向链表向后扫描,直到某条聚簇索引记录的 id 值不在[3,99]区间中为止。 与全表扫描相比， 扫描 id 值在[3,99]区间中的记录已经很大程度地减少了需要扫描的记录数量， 所以提升了查询效率。</p><p>再看下面这个查询语句:</p><blockquote><p>SELECT * FROM order_exp WHERE id in(3,9) OR (id&gt;&#x3D;23 AND id&lt;&#x3D; 99);</p></blockquote><p> 这里有几个扫描区间？ 三个， 两个单独扫描区间[3,3]、 [9,9]， 一个范围扫描区间[23,99]。</p><p>再看下面这个查询语句以及索引列信息:</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AaRdWtJ3-1631955925748)(C:\Users\admin\Desktop\笔记\img\扫描区间索引.png)]</p><blockquote><p>SELECT * FROM order_exp WHERE order_no &lt; ‘DD00_10S’ AND expire_time &gt;<br>‘2021-03-22 18:28:28’ AND order_note &gt; ‘7 排’;</p></blockquote><ul><li>这个语句里， order_no 和 expire_time 都有索引， order_note 没有索引， 一个 Select 查询语句在执行过程中一般最多能使用一个二级索引。 那么也就是说：</li><li>如果用order_no列的索引执行查询， 那扫描区间就是[第一条记录， ‘DD00_10S’]，expire_time&gt; ‘2021-03-22 18:28:28’ AND order_note &gt; ‘7 排’只能成为普通的搜索或者说判定条件。</li><li>如果说用 idx_expire_time 执行查询， 那扫描区间就是[‘2021-03-22 18:28:28’，最后一条记录]，order_no &lt;‘DD00_10S’ AND order_note &gt; ‘7 排’ 只能成为普通的搜索或者说判定条件。无论用哪个索引执行查询， 都需要获取到索引中的记录后， 进行回表， 获取到完整的用户记录后再根据判定条件判断这条记录是否满足 SQL 语句的要求</li></ul><h4 id="范围区间扫描"><a href="#范围区间扫描" class="headerlink" title="范围区间扫描"></a>范围区间扫描</h4><p> 其实对于 B+树索引来说， 只要索引列和常数使用&#x3D;、 &lt;&#x3D;&gt;、 IN、 NOT IN、 IS NULL、IS NOT NULL、 &gt;、 &lt;、 &gt;&#x3D;、 &lt;&#x3D;、 BETWEEN、 !&#x3D;（不等于也可以写成&lt;&gt;） 或者 LIKE操作符连接起来， 就可以产生一个区间。</p><p>1、 IN 操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的， 也就是说会产生多个单点区间， 比如下边这两个语句的效果是一样的：</p><blockquote><p>SELECT * FROM order_exp WHERE insert_time IN (2021-03-22 18:23:42, yyyy);</p><p>SELECT * FROM order_exp WHERE insert_time&#x3D; 2021-03-22 18:23:42 OR insert_time &#x3D; yyyy;</p></blockquote><p>2、 !&#x3D;产生的扫描区间呢？ 比如</p><blockquote><p>SELECT * FROM order_exp WHERE order_ no !&#x3D; ‘DD00_9S’</p></blockquote><p> 此时使用 idx_expire_time 执行查询时对应的扫描区间就是<code>[第一条记录 ,&#39;DD00_9S&#39;]</code>和<code>[ &#39;DD00_9S&#39;,最后一条记录]</code>。</p><p>3、 LIKE 操作符比较特殊， 只有在匹配完整的字符串或者匹配字符串前缀时才产生合适的扫描区间。</p><p>对于某个索引列来说， 字符串前缀相同的记录在由记录组成的单向链表中肯定是相邻的。 比如我们有一个搜索条件是 <code>note LIKE&#39; b%&#39;</code>， 对于二级索引 <code>idx_note</code>来说， 所有字符串前缀为’b’的二级索引记录肯定是相邻的。 这也就意味着我们只要定位到 <code>idx_note</code> 值的字符串前缀为<code>&#39;b&#39;</code>的第一条记录， 就可以沿着记录所在的单向链表向后扫描， 直到某条二级索引记录的字符串前缀不为 <code>b</code> 为止。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-226CrlvH-1631955925749)(C:\Users\admin\Desktop\笔记\img\范围区间扫描.png)]</p><p>很显然， <code>note LIKE&#39; b%&#39;</code>形成的扫描区间相当于<code>[&#39;b&#39;, &#39;c&#39;)</code>。</p><h4 id="范围扫描索引破坏"><a href="#范围扫描索引破坏" class="headerlink" title="范围扫描索引破坏"></a>范围扫描索引破坏</h4><ol><li>使用and的情况：</li></ol><blockquote><p>SELECT * FROM order_exp WHERE expire_time&gt; ‘2021-03-22 18:35:09’ AND order_note &#x3D; ‘abc’;</p></blockquote><p> 请注意， 这个查询语句中能利用的索引只有 <code>idx_expire_time</code> 一个， 在使用二级索引 <code>idx_expire_time</code> 定位记录的阶段用不到 <code>order_note = &#39;abc&#39;</code>这个条件，这个条件是在回表获取了完整的用户记录后才使用的， 所以在确定范围区间的时候不需要考虑 <code>order_note = &#39;abc&#39;</code>这个条件。<br>最终范围区间就是：<code>(&#39;2021-03-2218:35:09&#39;, 最后一条记录)</code>。</p><ol><li>使用 OR 的情况：</li></ol><blockquote><p>SELECT * FROM order_exp WHERE expire_time&gt; ‘2021-03-22 18:35:09’ OR order_note &#x3D; ‘abc’;</p></blockquote><p> 这条语句在搜索时可以化简为：<code>SELECT * FROM order_exp ;</code></p><p> 这也就说如果我们使用 idx_expire_time 执行查询的话， 对应的范围区间就是[第一条记录,最后一条记录]， 也就是需要将全部二级索引的记录进行回表， 这个代价肯定比直接全表扫描都大了，所以mysql在内部优化选择时，宁愿不走索引改为走全表扫描</p><p> 也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用 OR 连接起来后是无法使用该索引的。为什么？ 道理很简单，<code>idx_expire_time</code> 这个二级索引的记录中不包含 <code>order_note</code> 这个字段， 那就是说， 即使二级索引 <code>idx_expire_time</code> 中找到了满足 <code>expire_time&gt; &#39;2021-03-2218:35:09&#39;</code>的记录， 是无法判定 <code>order_note</code> 是否满足 <code>order_note = &#39;abc&#39;</code>的， 又因为是 OR 条件， 所以必须要在主键索引中从第一条记录到最后一条记录逐条判定order_note 是否等于 ‘abc’</p><h4 id="MyISAM-中的索引"><a href="#MyISAM-中的索引" class="headerlink" title="MyISAM 中的索引"></a>MyISAM 中的索引</h4><p> 1、MyISAM 的索引方案虽然也使用树形结构， 但是却将索引和数据分开存储的。</p><p> 2、MyISAM 将表中的记录按照记录的插入顺序单独存储在一个文件中， 称之为数据文件。 这个文件并不划分为若干个数据页， 有多少记录就往这个文件中塞多少记录。 我们可以通过行号而快速访问到一条记录。</p><p> 3、由于在插入数据的时候并没有刻意按照主键大小排序， 所以我们并不能在这些数据上使用二分法进行查找</p><p> 4、使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。 MyISAM 会单独为表的<code>主键创建一个索引</code>， 只不过在索引的叶子节点中存储的不是完整的用户记录， 而是<code>主键值＋行号的组合</code>。 也就是先通过索引找到对应的行号， 再通过行号去找对应的记录!</p><p> 5、这一点和 InnoDB 是完全不相同的， 在 InnoDB 存储引擎中， 我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录， 而在 MyISAM 中却需要进行一次回表操作<code>（用主键索引找行号，用行号查需要的数据）</code>， 意味着 MyISAM 中建立的索引相当于<code>全部都是二级索引</code>!</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fde0S3tW-1631955925749)(C:\Users\admin\Desktop\笔记\img\MyISAM文件结构.png)]</p><p>上图中，<code>.frm</code>存放元数据，<code>.MYD</code>存放表数据，<code>.MYI</code>存放MyISAM表的索引信息</p><h4 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h4><p><code>空间上的代价：</code> 每建立一个索引都要为它建立一棵 B+树， 每一棵 B+树的每一个节点都是一个数据页， 一个页默认会占用 16KB 的存储空间， 一棵很大的 B+树由许多数据页组成会占据很多的存储空间。</p><p><code>时间上的代价：</code> 每次对表中的数据进行增、 删、 改操作时， 都需要去修改各个 B+树索引， 所以存储引擎需要<br>额外的时间进行一些记录移位， 页面分裂、 页面回收的操作来维护好节点和记录的排序。 如果我们建了许多索引， 每个索引对应的 B+树都要进行相关的维护操作， 这必然会对性能造成影响</p><h3 id="高性能的索引创建策略"><a href="#高性能的索引创建策略" class="headerlink" title="高性能的索引创建策略"></a>高性能的索引创建策略</h3><p>1、索引列的类型尽量小</p><p>2、索引选择性和前缀索引，创建索引应该选择选择性&#x2F;离散性高的列。 索引的选择性&#x2F;离散性是指， 不重<br>复的索引值</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FUyjBfsu-1631955925750)(C:\Users\admin\Desktop\笔记\img\离散型.png)]</p><p>哪列做为索引字段最好？ 当然是姓名字段， 因为里面的数据没有任何重复，、性别字段是最不适合做索引的， 因为数据的重复度非常高。</p><p>3、前缀索引</p><p>4、只为用于搜索、排序或分组的列创建索引</p><p>5、多列索引</p><p>6、设计三星索引</p><h3 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h3><ul><li><strong>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录， 再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？</strong></li></ul><ol><li>如果表的类型是 MyISAM，那么是 18</li></ol><p> 因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大 ID 也不会丢失</p><ol><li>如果表的类型是 InnoDB，那么是 15</li></ol><p> InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行 OPTIMIZE 操作，都会导致最大 ID 丢失</p><ol><li><p>optimize table 表名; 进行操作后，就相当对表进行碎片处理，使表的空间大大的减少了</p><p>只对MyISAM, BDB和InnoDB引擎表起作用，且在优化中时会锁定表</p></li></ol><ul><li><p><strong>与 Oracle 相比，Mysql 有什么优势？</strong></p><p>Mysql 是开源软件，随时可用，无需付费。</p><p>Mysql 是便携式的</p><p>带有命令提示符的 GUI。</p><p>使用 Mysql 查询浏览器支持管理</p></li><li><p><strong>如何区分 FLOAT 和 DOUBLE？</strong></p><p>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。</p><p>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。</p></li><li><p><strong>Mysql 中 InnoDB 支持的四种事务隔离级别， 以及逐级之间的区别？</strong></p><ol><li><strong>Read Uncommitted</strong>（读取未提交内容）： 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称 之为脏读（Dirty Read）。</li><li><strong>Read Committed</strong>（读取提交内容）：这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一 个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</li><li><strong>Repeatable Read</strong>（可重读）：这是 MySQL 的默认事务隔离级 别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现 有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制 （MVCC，Multiversion Concurrency Control 间隙锁）机制解决了 该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也 就是它这里所谓的并发控制）才解决了幻读问题。</li><li><strong>Serializable</strong>（可串行化）： 这是最高的隔离级别，它通过强制事务 排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li></ol></li><li><p><strong>事务四个特征</strong></p><ol><li><strong>原子性（atomicity)</strong> ： 一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性</li><li><strong>一致性（consistency)</strong> ： 事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</li><li><strong>隔离性（isolation）</strong>：事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。</li><li><strong>持久性（durability）</strong> ： 一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中</li></ol></li><li><p><strong>mysql支持哪些存储引擎？</strong></p></li></ul><p>mysql5.6支持的存储引擎包括</p><p> InnoDB、MyISAM、MEMORY等</p><p> InnoDB支持事务，MyISAM不支持事务， MEMORY将数据存在内存 ，默认使用hash索引</p><ul><li><p><strong>Mysql 的默认存储引擎</strong></p><p>Mysql在V5.1之前默认存储引擎是<strong>MyISAM</strong>；在此之后默认存储引擎是<strong>InnoDB</strong></p></li><li><p><strong>主键和候选键有什么区别？</strong></p><p>表格的每一行都有主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p></li><li><p><strong>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</strong></p><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p></li><li><p><strong>LIKE 声明中的％和 _ 是什么意思？</strong></p><p>％对应于 0 个或更多字符，_ 只是 LIKE 语句中的一个字符。</p></li><li><p><strong>BLOB 和 TEXT 有什么区别？</strong></p><p>BLOB 是一个二进制对象，可以容纳可变数量的数据</p><p>BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。</p></li><li><p><strong>MyISAM 表格将在哪里存储，并且还提供其存储格式？</strong></p><p>每个 MyISAM 表格以三种格式存储在磁盘上：</p></li></ul><ol><li>“.frm”文件存储表定义 元数据</li><li>数据文件具有“.MYD”（MYData）</li><li>索引文件具有“.MYI”（MYIndex）</li></ol><ul><li><p><strong>可以使用多少列创建索引</strong>？</p><p>任何标准表最多可以创建 16 个索引列 ，实际中建议不超过五个</p></li><li><p><strong>NOW（）和 CURRENT_DATE（）有什么区别？</strong></p><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p></li><li><p><strong>MYSQL 数据表在什么情况下容易损坏？</strong></p></li></ul><p>服务器突然断电导致数据文件损坏。</p><p>强制关机，没有先关闭 mysql 服务等</p><ul><li><p><strong>Mysql 中有哪几种锁</strong></p><p>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p></li><li><p><strong>常用的索引有哪些种类?</strong></p></li></ul><ol><li>普通索引: 即针对数据库表某列创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL 数据库索引列的值 必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的 时候同时创建主键索引</li><li>组合索引: 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。 即将数据库表中的多个字段联合起来作为一个组合索引。</li></ol><ul><li><strong>mysql 数据库中索引的工作机制是什么？</strong></li></ul><p>数据库索引，是数据库管理系统中一个排序的数据结构，减少io消耗，以协助快速查询。</p><p>索引的实现通常使用 B+树</p><ul><li><p><strong>MySQL 中 InnoDB 引擎的行锁是通过什么实现的？</strong></p><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p></li><li><p><strong>[SELECT *] 和 [SELECT 全部字段] 的 2 种写法有何优缺点?</strong></p><ol><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ol></li><li><p><strong>HAVNG 子句 和 WHERE 的异同点?</strong></p></li></ul><ol><li>语法上：where 用表中列名，having 用 select 结果别名</li><li>影响结果范围：where 从表读出数据的行数，having 返回客户端的行 数</li><li>索引：where 可以使用索引，having 不能使用索引，只能在临时结果 集操作</li><li>where 后面不能使用聚集函数，having 是专门使用聚集函数的。</li></ol><ul><li><strong>为什么 MySQL 的索引要使用 B+树而不是 B 树？</strong><br>B 树和 B+树的最大区别就是， B 树不管叶子节点还是非叶子节点， 都会保存数据， 这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出） ， 指针少的情况下要保存大量数据， 只能增加树的高度， 导致 IO 操作变多，查询性能变低。</li></ul><h1 id="十二、分库分表"><a href="#十二、分库分表" class="headerlink" title="十二、分库分表"></a>十二、分库分表</h1><h3 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h3><h1 id="十三、Nginx"><a href="#十三、Nginx" class="headerlink" title="十三、Nginx"></a>十三、Nginx</h1><h3 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>请解释一下什么是 Nginx?</strong></p><p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</p></li><li><p><strong>请列举 Nginx 的一些特性 ？</strong></p><ol><li>反向代理</li><li>负载均衡器</li><li>高可用性和伸缩性</li><li>动静分离</li></ol></li><li><p><strong>请列举 Nginx 和 Apache 之间的不同点</strong></p></li></ul><p>Nginx 是轻量级web服务器，Nginx 比 Apache 占用更少的内存及资源</p><p>Nginx 处理请求是异步非阻塞的，抗并发性比较好，而 Apache 则是阻塞型的，</p><p>在高并发下 Nginx 能保持低资源低消耗高性能。</p><p>Nginx 对所有的请求都有一个线程处理，Apache 单个线程处理单个请求</p><p>核心的区别在于 Apache 是同步多进程模型，一个连接对应一个进程；Nginx 是异步的，多个连接（万级别）可以对应一个进程。</p><ul><li><strong>请解释 Nginx 如何处理 HTTP 请求。</strong></li></ul><p>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket</p><p>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</p><p>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。</p><p>此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</p><p>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</p><p>最后，Nginx 或客户端来主动关掉连接</p><ul><li><p><strong>使用“反向代理服务器”的优点是什么?</strong></p><p>反向代理服务器可以隐藏源服务器的存在和特征。使用安全</p><p>提高访问速度</p><p>防火墙作用 ：由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息</p><p>通过代理服务器访问不能访问的目标站点：通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可直接访问外网。</p></li><li><p><strong>请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</strong></p></li></ul><p>Master 进程：读取及评估配置和维持</p><p>Worker 进程：处理请求</p><ul><li><p><strong>如何通过不同于 80 的端口开启 Nginx?</strong></p><p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sitesenabled&#x2F;，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口： Like server { listen 81; }</p></li><li><p><strong>请陈述 stub_status 和 sub_filter 指令的作用是什么?</strong></p><p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p><p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p></li><li><p><strong>Nginx负载均衡的5种策略及原理</strong></p><ol><li><p><strong>轮询（默认）</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p></li><li><p><strong>指定权重</strong></p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p></li><li><p><strong>IP绑定 ip_hash</strong></p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p></li><li><p><strong>fair（第三方）</strong><br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p></li><li><p><strong>url_hash（第三方）</strong><br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p></li></ol></li></ul><h1 id="十四、ES"><a href="#十四、ES" class="headerlink" title="十四、ES"></a>十四、ES</h1><h3 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>RESTful 指的是一组架构约束条件和原则，就是用来规范我们的 Http 接口API 的一种约束</p><h4 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h4><p>1.架构里， 每一个 URI 代表一种资源；<br>2.客户端和服务器之间， 传递这种资源的某种表现层；<br>3.客户端通过四个 HTTP 动词（get、post、 put、 delete） 对服务器端资源进行操作， 实现” 表现层状态转化”<br>注意： REST 架构风格并不是绑定在 HTTP 上， 只不过目前 HTTP 是唯一与 REST相关的实例。 所以我们这里描述的 REST 也是通过 HTTP 实现的 REST。</p><h1 id="十五、Linux"><a href="#十五、Linux" class="headerlink" title="十五、Linux"></a>十五、Linux</h1><h3 id="常用密令"><a href="#常用密令" class="headerlink" title="常用密令"></a>常用密令</h3><p>ls命令 查看文件信息</p><p>cat 命令 查看文件内容</p><p>cd密令，进入目录</p><p>pwd 密令用于查看当前工作目录路径。</p><p>mkdir命令 创建目录’</p><p>rm -f 密令删除</p><p>vi、vim 文件名 进入文件修改， wq ：保存修改 q：不保存修改</p><p>echo 打印命令。</p><h1 id="十六、设计模式"><a href="#十六、设计模式" class="headerlink" title="十六、设计模式"></a>十六、设计模式</h1><h3 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h4><p> 单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个 特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。</p><h4 id="使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h4><p> 工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</p><p>排序和比较时区分大小写，对 TEXT 值不区分大小写。</p><ul><li><p><strong>MyISAM 表格将在哪里存储，并且还提供其存储格式？</strong></p><p>每个 MyISAM 表格以三种格式存储在磁盘上：</p></li></ul><ol><li>“.frm”文件存储表定义 元数据</li><li>数据文件具有“.MYD”（MYData）</li><li>索引文件具有“.MYI”（MYIndex）</li></ol><ul><li><p><strong>可以使用多少列创建索引</strong>？</p><p>任何标准表最多可以创建 16 个索引列 ，实际中建议不超过五个</p></li><li><p><strong>NOW（）和 CURRENT_DATE（）有什么区别？</strong></p><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p></li><li><p><strong>MYSQL 数据表在什么情况下容易损坏？</strong></p></li></ul><p>服务器突然断电导致数据文件损坏。</p><p>强制关机，没有先关闭 mysql 服务等</p><ul><li><p><strong>Mysql 中有哪几种锁</strong></p><p>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p></li><li><p><strong>常用的索引有哪些种类?</strong></p></li></ul><ol><li>普通索引: 即针对数据库表某列创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL 数据库索引列的值 必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的 时候同时创建主键索引</li><li>组合索引: 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。 即将数据库表中的多个字段联合起来作为一个组合索引。</li></ol><ul><li><strong>mysql 数据库中索引的工作机制是什么？</strong></li></ul><p>数据库索引，是数据库管理系统中一个排序的数据结构，减少io消耗，以协助快速查询。</p><p>索引的实现通常使用 B+树</p><ul><li><p><strong>MySQL 中 InnoDB 引擎的行锁是通过什么实现的？</strong></p><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p></li><li><p><strong>[SELECT *] 和 [SELECT 全部字段] 的 2 种写法有何优缺点?</strong></p><ol><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ol></li><li><p><strong>HAVNG 子句 和 WHERE 的异同点?</strong></p></li></ul><ol><li>语法上：where 用表中列名，having 用 select 结果别名</li><li>影响结果范围：where 从表读出数据的行数，having 返回客户端的行 数</li><li>索引：where 可以使用索引，having 不能使用索引，只能在临时结果 集操作</li><li>where 后面不能使用聚集函数，having 是专门使用聚集函数的。</li></ol><ul><li><strong>为什么 MySQL 的索引要使用 B+树而不是 B 树？</strong><br>B 树和 B+树的最大区别就是， B 树不管叶子节点还是非叶子节点， 都会保存数据， 这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出） ， 指针少的情况下要保存大量数据， 只能增加树的高度， 导致 IO 操作变多，查询性能变低。</li></ul><h1 id="十二、分库分表-1"><a href="#十二、分库分表-1" class="headerlink" title="十二、分库分表"></a>十二、分库分表</h1><h3 id="基础知识-5"><a href="#基础知识-5" class="headerlink" title="基础知识"></a>基础知识</h3><h1 id="十三、Nginx-1"><a href="#十三、Nginx-1" class="headerlink" title="十三、Nginx"></a>十三、Nginx</h1><h3 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p><strong>请解释一下什么是 Nginx?</strong></p><p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</p></li><li><p><strong>请列举 Nginx 的一些特性 ？</strong></p><ol><li>反向代理</li><li>负载均衡器</li><li>高可用性和伸缩性</li><li>动静分离</li></ol></li><li><p><strong>请列举 Nginx 和 Apache 之间的不同点</strong></p></li></ul><p>Nginx 是轻量级web服务器，Nginx 比 Apache 占用更少的内存及资源</p><p>Nginx 处理请求是异步非阻塞的，抗并发性比较好，而 Apache 则是阻塞型的，</p><p>在高并发下 Nginx 能保持低资源低消耗高性能。</p><p>Nginx 对所有的请求都有一个线程处理，Apache 单个线程处理单个请求</p><p>核心的区别在于 Apache 是同步多进程模型，一个连接对应一个进程；Nginx 是异步的，多个连接（万级别）可以对应一个进程。</p><ul><li><strong>请解释 Nginx 如何处理 HTTP 请求。</strong></li></ul><p>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket</p><p>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</p><p>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。</p><p>此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</p><p>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</p><p>最后，Nginx 或客户端来主动关掉连接</p><ul><li><p><strong>使用“反向代理服务器”的优点是什么?</strong></p><p>反向代理服务器可以隐藏源服务器的存在和特征。使用安全</p><p>提高访问速度</p><p>防火墙作用 ：由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息</p><p>通过代理服务器访问不能访问的目标站点：通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可直接访问外网。</p></li><li><p><strong>请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</strong></p></li></ul><p>Master 进程：读取及评估配置和维持</p><p>Worker 进程：处理请求</p><ul><li><p><strong>如何通过不同于 80 的端口开启 Nginx?</strong></p><p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sitesenabled&#x2F;，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口： Like server { listen 81; }</p></li><li><p><strong>请陈述 stub_status 和 sub_filter 指令的作用是什么?</strong></p><p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p><p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p></li><li><p><strong>Nginx负载均衡的5种策略及原理</strong></p><ol><li><p><strong>轮询（默认）</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p></li><li><p><strong>指定权重</strong></p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p></li><li><p><strong>IP绑定 ip_hash</strong></p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p></li><li><p><strong>fair（第三方）</strong><br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p></li><li><p><strong>url_hash（第三方）</strong><br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p></li></ol></li></ul><h1 id="十四、ES-1"><a href="#十四、ES-1" class="headerlink" title="十四、ES"></a>十四、ES</h1><h3 id="基础知识-6"><a href="#基础知识-6" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="REST-1"><a href="#REST-1" class="headerlink" title="REST"></a>REST</h4><p>RESTful 指的是一组架构约束条件和原则，就是用来规范我们的 Http 接口API 的一种约束</p><h4 id="RESTful-架构-1"><a href="#RESTful-架构-1" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h4><p>1.架构里， 每一个 URI 代表一种资源；<br>2.客户端和服务器之间， 传递这种资源的某种表现层；<br>3.客户端通过四个 HTTP 动词（get、post、 put、 delete） 对服务器端资源进行操作， 实现” 表现层状态转化”<br>注意： REST 架构风格并不是绑定在 HTTP 上， 只不过目前 HTTP 是唯一与 REST相关的实例。 所以我们这里描述的 REST 也是通过 HTTP 实现的 REST。</p><h1 id="十五、Linux-1"><a href="#十五、Linux-1" class="headerlink" title="十五、Linux"></a>十五、Linux</h1><h3 id="常用密令-1"><a href="#常用密令-1" class="headerlink" title="常用密令"></a>常用密令</h3><p>ls命令 查看文件信息</p><p>cat 命令 查看文件内容</p><p>cd密令，进入目录</p><p>pwd 密令用于查看当前工作目录路径。</p><p>mkdir命令 创建目录’</p><p>rm -f 密令删除</p><p>vi、vim 文件名 进入文件修改， wq ：保存修改 q：不保存修改</p><p>echo 打印命令。</p><h1 id="十六、设计模式-1"><a href="#十六、设计模式-1" class="headerlink" title="十六、设计模式"></a>十六、设计模式</h1><h3 id="面试题-9"><a href="#面试题-9" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式-1"><a href="#Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式-1" class="headerlink" title="Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h4><p> 单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个 特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。</p><h4 id="使用工厂模式最主要的好处是什么？在哪里使用？-1"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？-1" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h4><p> 工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小胡子的第二篇blog</title>
    <link href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/"/>
    <url>/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/</url>
    
    <content type="html"><![CDATA[<p>000000000000000000</p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>On Java 8</title>
    <link href="/2023/01/09/On%20Java%208/"/>
    <url>/2023/01/09/On%20Java%208/</url>
    
    <content type="html"><![CDATA[<h1 id="On-Java-8"><a href="#On-Java-8" class="headerlink" title="On Java 8"></a>On Java 8</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>信息的重要性是分层次结构的。</p><p>绝大多数情况下，我们没必要弄清问题的所有本质。好比编程语言中的某些特性和实现细节，95% 的程序员都不需要去知道。这些细节除了会加重你的学习成本，还让你更觉得这门语言好复杂。如果你非要考虑这些细节，那么它还会迷惑该代码的阅读者&#x2F;维护者，所以我主张选择简单的方法解决问题。</p><p>新手程序员并没有经历过“语言为何采用某种方式实现”的争议过程。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​“语言观决定世界观。” ——路德维希·维特根斯坦（<em>Wittgenstein</em>）</p><p>​<strong>java是强类型语言！！！！</strong></p><p>​Java 最核心的变化就是加入了<strong>“虚拟机”</strong>和<strong>“垃圾回收机制”</strong>，这两个概念在之后的章节会有详细描述。 此外，Java 还在其他方面推动了行业发展。例如，现在绝大多数编程语言都支持文档注释语法和 HTML 文档生成工具。</p><p>这无关 Java 是一种好语言或者坏语言，一旦你了解了该语言的缺陷和局限性，你就能够：</p><ol><li>明白有些功能特性为什么会被“废弃”。</li><li>熟悉语言边界，更好地设计和编码。</li></ol><h2 id="第一章-对象的概念"><a href="#第一章-对象的概念" class="headerlink" title="第一章 对象的概念"></a>第一章 对象的概念</h2><p>​计算机革命的起源来自机器。编程语言就像是那台机器。它不仅是我们思维放大的工具与另一种表达媒介，更像是我们思想的一部分。语言的灵感来自其他形式的表达，如写作，绘画，雕塑，动画和电影制作。编程语言就是创建应用程序的思想结构。</p><p>面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>​所有编程语言都提供抽象机制。从某种程度上来说，问题的复杂度直接取决于抽象的类型和质量。这里的“类型”意思是：抽象的内容是什么？汇编语言是对底层机器的轻微抽象。接着出现的“命令式”语言（如 FORTRAN，BASIC 和 C）是对汇编语言的抽象。与汇编相比，这类语言已有了长足的改进，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非问题本身的结构。</p><p>​程序员必须要在&#x3D;&#x3D;机器模型（“解决方案空间”）&#x3D;&#x3D;和实际解决的&#x3D;&#x3D;问题模型（“问题空间”）&#x3D;&#x3D;之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。这使得程序代码很难编写，维护代价高昂。同时还造就了一个副产业“编程方法”学科。</p><p>​面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将&#x3D;&#x3D;问题空间中的元素以及它们在解决方案空间的表示称作“对象”（<strong>Object</strong>）。&#x3D;&#x3D;当然，还有一些在问题空间没有对应的对象体。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。</p><p>​&#x3D;&#x3D;OOP 允许我们根据问题来描述问题，而不是根据运行解决方案的计算机。&#x3D;&#x3D;</p><p>​然而，它仍然与计算机有联系，每个对象都类似一台小计算机：它们有自己的状态并且可以进行特定的操作。这与现实世界的“对象”或者“物体”相似：&#x3D;&#x3D;它们都有自己的特征和行为。&#x3D;&#x3D;</p><p>​<strong>理解“纯粹”的面向对象程序设计方法是什么样的：以下5点</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>万物皆对象。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>程序是一组对象，通过消息传递来告知彼此该做什么。要请求调用一个对象的方法，你需要向该对象发送消息。<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span>每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span>同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（<span class="hljs-keyword">Circle</span>）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给”形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。<br></code></pre></td></tr></table></figure><p>​<em>Grady Booch</em> 提供了对对象更简洁的描述：一&#x3D;&#x3D;个对象具有自己的状态，行为和标识。&#x3D;&#x3D;这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>​创建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。事实上，当我们进行面向对象的程序设计时，面临的最大一项挑战是：&#x3D;&#x3D;如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系。&#x3D;&#x3D;</p><p>​我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。&#x3D;&#x3D;“类型”与“接口”的对应关系是面向对象程序设计的基础。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Light</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();<br>lt.on();<br></code></pre></td></tr></table></figure><img src="D:\2 ASK-Ability,Skills and Knowledge\9 笔记\12 第二阶段笔记-202221103\On Java 8.assets\image-20221114222458676.png" alt="image-20221114222458676" style="zoom: 50%;" /><p>​在这个例子中，类型／类的名称是 <strong>Light</strong>，可向 <strong>Light</strong> 对象发出的请求包括打开 <code>on</code>、关闭 <code>off</code>、变得更明亮 <code>brighten</code> 或者变得更暗淡 <code>dim</code>。通过声明一个引用，如 <code>lt</code> 和 <code>new</code> 关键字，我们创建了一个 <strong>Light</strong> 类型的对象，再用等号将其赋给引用。</p><p>​为了向对象发送消息，我们使用句点符号 <code>.</code> 将 <code>lt</code> 和消息名称 <code>on</code> 连接起来。可以看出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单直观的。</p><h3 id="服务提供"><a href="#服务提供" class="headerlink" title="服务提供"></a>服务提供</h3><p>​在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。你的程序本身将为用户提供服务，并且它能通过调用其他对象提供的服务来实现这一点。&#x3D;&#x3D;我们的最终目标是开发或调用工具库中已有的一些对象，提供理想的服务来解决问题。&#x3D;&#x3D;</p><p>​软件设计的基本原则是&#x3D;&#x3D;高内聚&#x3D;&#x3D;：每个组件的内部作用明确，功能紧密相关。</p><p>​这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。只有让人知道你提供什么服务，别人才能更好地将其应用到其他模块或程序中。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​我们可以把编程的侧重领域划分为&#x3D;&#x3D;研发&#x3D;&#x3D;和&#x3D;&#x3D;应用&#x3D;&#x3D;。&#x3D;&#x3D;应用程序员调用研发程序员构建的基础工具类来做快速开发&#x3D;&#x3D;。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。</p><p>因此，使用访问控制的原因有以下两点：</p><ol><li>&#x3D;&#x3D;让应用程序员不要触摸他们不应该触摸的部分&#x3D;&#x3D;。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）；</li><li>使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如&#x3D;&#x3D;工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。&#x3D;&#x3D;</li></ol><p>​        Java 有三个显式关键字来设置&#x3D;&#x3D;类&#x3D;&#x3D;中的访问权限：<code>public</code>（公开），<code>private</code>（私有）和<code>protected</code>（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。</p><ol><li><code>public</code>（公开）表示任何人都可以访问和使用该元素；</li><li><code>private</code>（私有）除了&#x3D;&#x3D;类本身和类内部的方法&#x3D;&#x3D;，外界无法直接访问该元素。<code>private</code> 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</li><li><code>protected</code>（受保护）类似于 <code>private</code>，区别是&#x3D;&#x3D;子类（下一节就会引入继承的概念）可以访问 <code>protected</code> 的成员&#x3D;&#x3D;，但不能访问 <code>private</code> 成员；</li><li><code>default</code>（默认）如果你不使用前面的三者，默认就是 <code>default</code> 访问权限。<code>default</code> 被称为&#x3D;&#x3D;包访问&#x3D;&#x3D;，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</li></ol><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>​一个类经创建和测试后，理应是可复用的。然而很多时候，由于程序员没有足够的编程经验和远见，我们的代码复用性并不强。</p><p>​代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用性。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。这里涉及到“组合”和“聚合”的概念：</p><ul><li><p><strong>组合</strong>（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。</p></li><li><p><strong>聚合</strong>（Aggregation）动态的<strong>组合</strong>。</p><p>聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。）</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​通过使用 <code>class</code> 关键字，这些概念形成了编程语言中的基本单元。遗憾的是，这么做还是有很多麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。</p><p>​在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。</p><img src="https://www.jishuchi.com/uploads/projects/onjava8/docs/images/1545764724202.png" alt="img" style="zoom:67%;" /><p>​尽管继承有时意味着你要在&#x3D;&#x3D;接口中添加新方法&#x3D;&#x3D;（尤其是在以 <strong>extends</strong> 关键字表示继承的 Java 中），但并非总需如此。第二种也是更重要的区分派生类和基类的方法是改变现有基类方法的行为，这被称为覆盖 (overriding)。&#x3D;&#x3D;要想覆盖一个方法，只需要在派生类中重新定义这个方法即可。&#x3D;&#x3D;</p><h4 id="“是一个”与”像是一个”的关系"><a href="#“是一个”与”像是一个”的关系" class="headerlink" title="“是一个”与”像是一个”的关系"></a>“是一个”与”像是一个”的关系</h4><p><strong>&#x3D;&#x3D;is-a：子类和父类具有相同的方法，子类没有新方法也没有重写父类方法，子类完全替代父类。&#x3D;&#x3D;</strong></p><p>​我们经常把这种基类和派生类的关系称为是一个（is-a）关系，因为可以说”圆是一个形状”。判断是否继承，就看在你的类之间有无这种 is-a 关系。</p><p><strong>&#x3D;&#x3D;is-like-a：子类有新方法，或者子类重写了父类方法。&#x3D;&#x3D;</strong></p><p>​有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>​发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。编译器和运行时系统会负责对所有细节的控制；我们只需知道要做什么，以及如何利用多态性来更好地设计程序。</p><p><strong>实现多态有三个前提条件</strong></p><p><em>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。</em></p><p><em>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。</em></p><p><em>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 多态的实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义一个父类的引用变量</span><br>        <span class="hljs-type">PeoPle</span> <span class="hljs-variable">peoPle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 指向子类的对象，Man是people的子类</span><br>        peoPle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        peoPle.say();<br>        <span class="hljs-comment">// 指向子类的对象</span><br>        peoPle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        peoPle.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单继承结构"><a href="#单继承结构" class="headerlink" title="单继承结构"></a>单继承结构</h3><p>​自从 C++ 引入以来，一个 OOP 问题变得尤为突出：是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有OOP语言中也是这样）。在 Java 中，这个最终基类的名字就是 <code>Object</code>。</p><p>​单继承的结构使得垃圾收集器的实现更为容易。这也是 Java 在 C++ 基础上的根本改进之一。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>​在面向对象的设计中，问题的解决方案有些过于轻率：创建一个新类型的对象来引用、容纳其他的对象。当然，我们也可以使用多数编程语言都支持的“数组”（array）。&#x3D;&#x3D;在 Java 中“集合”（Collection）的使用率更高。（也可称之为“容器”，但“集合”这个称呼更通用。）&#x3D;&#x3D;</p><p>​“集合”这种类型的对象&#x3D;&#x3D;可以存储任意类型、数量的其他对象&#x3D;&#x3D;。它能根据需要自动扩容，我们不用关心过程是如何实现的。</p><p>​常见的&#x3D;&#x3D;有 List，常用于保存序列&#x3D;&#x3D;；&#x3D;&#x3D;Map，也称为关联数组&#x3D;&#x3D;，常用于将对象与其他对象关联；&#x3D;&#x3D;Set，只能保存非重复的值&#x3D;&#x3D;；其他还包括如队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。</p><p>​从设计的角度来看，我们真正想要的是一个能够解决某个问题的集合。如果一种集合就满足所有需求，那么我们就不需要剩下的了。之所以选择集合有以下两个原因：</p><ol><li>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供的解决方案可能比其他灵活得多。</li><li>&#x3D;&#x3D;不同的集合对某些操作有不同的效率&#x3D;&#x3D;。例如，List 的两种基本类型：ArrayList 和 LinkedList。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。&#x3D;&#x3D;在 ArrayList 中随机查找元素是很高效的&#x3D;&#x3D;，而 LinkedList 随机查找效率低下。反之，在 LinkedList 中插入元素的效率要比在 ArrayList 中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</li></ol><p>​         在 Java 5 泛型出来之前，集合中保存的是通用类型 <code>Object</code>。Java 单继承的结构意味着所有元素都基于 <code>Object</code> 类，所以在集合中可以保存任何类型的数据，易于重用。要使用这样的集合，我们先要往集合添加元素。由于 Java 5 版本前的集合只保存 <code>Object</code>，&#x3D;&#x3D;当我们往集合中添加元素时，元素便向上转型成了 <code>Object</code>，从而丢失自己原有的类型特性。&#x3D;&#x3D;这时我们再从集合中取出该元素时，元素的类型变成了 <code>Object</code>。那么我们该怎么将其转回原先具体的类型呢？</p><p>​这里，我们使用了&#x3D;&#x3D;强制类型转换&#x3D;&#x3D;将其转为更具体的类型，这个过程称为对象的“&#x3D;&#x3D;向下转型&#x3D;&#x3D;”。通过“向上转型”，我们知道“圆形”也是一种“形状”，这个过程是安全的。可是我们不能从“Object”看出其就是“圆形”或“形状”，所以除非我们能确定元素的具体类型信息，否则“向下转型”就是不安全的。</p><p>​向上转型：圆是一种形状，安全的</p><p>​向下转型：形状不一定是什么，可能是圆&#x2F;三角形。不安全的</p><p>​<strong>参数化类型应运而生！！！</strong></p><p>​每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。&#x3D;&#x3D;以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误&#x3D;&#x3D;难道不好吗？这种解决方案就是：&#x3D;&#x3D;参数化类型机制（Parameterized Type Mechanism）。&#x3D;&#x3D;</p><p>​<strong>泛型！！！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Shape&gt; shapes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h3 id="对象创建与生命周期"><a href="#对象创建与生命周期" class="headerlink" title="对象创建与生命周期"></a>对象创建与生命周期</h3><p>我们在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。</p><p>对象的数据在哪？它的生命周期是怎么被控制的？ &#x3D;&#x3D;在 C++ 设计中采用的观点是效率第一&#x3D;&#x3D;，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。这种控制在某些情况下非常有用。</p><p>&#x3D;&#x3D;第二种方法是在堆内存（Heap）中动态地创建对象&#x3D;&#x3D;。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。</p><p>&#x3D;&#x3D;Java 使用动态内存分配&#x3D;&#x3D;。每次创建对象时，使用 <code>new</code> 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在 C++ 中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。&#x3D;&#x3D;Java 的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。垃圾收集器的存在带来了极大的便利，它减少了我们之前必须要跟踪的问题和编写相关代码的数量。&#x3D;&#x3D;因此，垃圾收集器提供了更高级别的保险，以防止潜在的内存泄漏问题，这个问题使得许多 C++ 项目没落。</p><p>Java 的垃圾收集器被设计用来解决内存释放的问题（虽然这不包括对象清理的其他方面）。垃圾收集器知道对象什么时候不再被使用并且自动释放内存。结合单继承和仅可在堆中创建对象的机制，Java 的编码过程比用 C++ 要简单得多。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。这让我们的编码更简单：不用再反复检查错误了。另外，异常不像方法返回的错误值和方法设置用来表示发生错误的标志位那样可以被忽略。异常的发生是不会被忽略的，它终究会在某一时刻被处理。</p><p>​&#x3D;&#x3D;Java 的异常处理机制在编程语言中脱颖而出。&#x3D;&#x3D;Java 从一开始就内置了异常处理，因此你不得不使用它。这是 Java 语言唯一接受的错误报告方法。</p><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>​面向对象编程的一个优点是：设计良好的 Java 程序代码更容易被人阅读理解。由于 Java 类库的复用性，通常程序要写的代码也会少得多。</p><h2 id="第二章-安装Java和本书用例"><a href="#第二章-安装Java和本书用例" class="headerlink" title="第二章 安装Java和本书用例"></a>第二章 安装Java和本书用例</h2><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>​相比一些重量级的 IDE（Integrated Development Environments，集成开发环境），如 Eclipse、NetBeans 和 &#x3D;&#x3D;IntelliJ IDEA (译者注：做项目强烈推荐IDEA)&#x3D;&#x3D;，编辑器是一种更纯粹的文本编辑器</p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>​如果你之前没有接触过编程，那么有可能对 &#x3D;&#x3D;Shell（命令行窗口）&#x3D;&#x3D; 不太熟悉。shell 的历史可以追溯到早期的计算时代，当时在计算机上的操作是都通过输入命令进行的，计算机通过回显响应。所有的操作都是基于文本的。</p><p><strong>目录</strong></p><p>​目录是 Shell 的基础元素之一。目录用来保存文件和其他目录。目录就好比树的分支。如果书籍是你系统上的一个目录，并且它有两个其他目录作为分支，例如数学和艺术，那么我们就可以说你有一个书籍目录，它包含数学和艺术两个子目录。注意：Windows 使用 <code>\</code> 而不是 <code>/</code> 来分隔路径。</p><p><strong>Shell基本操作</strong></p><p>我在这展示的 Shell 操作和系统中大体相同。出于本书的原因，下面列举一些在 Shell 中的基本操作：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs stata">更改目录： <span class="hljs-keyword">cd</span> &lt;路径&gt; <br>          <span class="hljs-keyword">cd</span> .. 移动到上级目录 <br>          pushd &lt;路径&gt; 记住来源的同时移动到其他目录，popd 返回来源<br>目录列举： <span class="hljs-keyword">ls</span> 列举出当前目录下所有的文件和子目录名（不包含隐藏文件），<br>             可以选择使用通配符 * 来缩小搜索范围。<br>             示例(1)： 列举所有以“.java”结尾的文件，输入 <span class="hljs-keyword">ls</span> *.java (Windows: <span class="hljs-keyword">dir</span> *.java)<br>             示例(2)： 列举所有以“F”开头，“.java”结尾的文件，输入<span class="hljs-keyword">ls</span> F*.java (Windows: <span class="hljs-keyword">dir</span> F*.java)<br>创建目录： <br>    <span class="hljs-keyword">Mac</span>/Linux 系统：<span class="hljs-keyword">mkdir</span>  <br>              示例：<span class="hljs-keyword">mkdir</span> books <br>    Windows   系统：md <br>              示例：md books<br>移除文件： <br>    <span class="hljs-keyword">Mac</span>/Linux 系统：<span class="hljs-keyword">rm</span><br>              示例：<span class="hljs-keyword">rm</span> somefile.java<br>    Windows   系统：del <br>              示例：del somefile.java<br>移除目录： <br>    <span class="hljs-keyword">Mac</span>/Linux 系统：<span class="hljs-keyword">rm</span> -r<br>              示例：<span class="hljs-keyword">rm</span> -r books<br>    Windows   系统：deltree <br>              示例：deltree books<br>重复命令： !!  重复上条命令<br>              示例：!<span class="hljs-keyword">n</span> 重复倒数第<span class="hljs-keyword">n</span>条命令<br>命令历史：     <br>    <span class="hljs-keyword">Mac</span>/Linux 系统：history<br>    Windows   系统：按 F7 键<br>文件解压：<br>    Linux/<span class="hljs-keyword">Mac</span> 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。<br>    图形界面下（Windows 资源管理器，<span class="hljs-keyword">Mac</span> Finder，Linux Nautilus 或其他等效软件）右键单击该文件，<br>    在 <span class="hljs-keyword">Mac</span> 上选择“<span class="hljs-keyword">open</span>”，在 Linux 上选择“extract here”，或在 Windows 上选择“extract all…”。<br>    要了解关于 <span class="hljs-keyword">shell</span> 的更多信息，请在维基百科中搜索 Windows <span class="hljs-keyword">shell</span>，<span class="hljs-keyword">Mac</span>/Linux用户可搜索 bash <span class="hljs-keyword">shell</span>。<br></code></pre></td></tr></table></figure><h3 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h3><p>​为了编译和运行代码示例，首先你必须安装 JDK（Java Development Kit，JAVA 软件开发工具包）。本书中采用的是 JDK 8。</p><p><strong>Windows</strong></p><ol><li>以下为 Chocolatey 的<a href="https://chocolatey.org/">安装说明</a>。</li><li>在命令行提示符下输入下面的命令，等待片刻，结束后 Java 安装完成并自动完成环境变量设置。</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">choco <span class="hljs-keyword">install</span> jdk8<br></code></pre></td></tr></table></figure><h3 id="校验安装"><a href="#校验安装" class="headerlink" title="校验安装"></a>校验安装</h3><p>打开新的命令行输入：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>正常情况下 你应该看到以下类似信息(版本号信息可能不一样）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>version <span class="hljs-string">&quot;1.8.0_112&quot;</span><br><span class="hljs-keyword">Java(TM) </span>SE Runtime Environment (<span class="hljs-keyword">build </span><span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_112-<span class="hljs-keyword">b15)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Java </span>HotSpot(TM) <span class="hljs-number">64</span>-<span class="hljs-keyword">Bit </span>Server VM (<span class="hljs-keyword">build </span><span class="hljs-number">25</span>.<span class="hljs-number">112</span>-<span class="hljs-keyword">b15, </span>mixed mode)<br></code></pre></td></tr></table></figure><p>如果提示命令找不到或者无法被识别，请根据安装说明重试</p><h2 id="第三章-万物皆对象"><a href="#第三章-万物皆对象" class="headerlink" title="第三章 万物皆对象"></a>第三章 万物皆对象</h2><h3 id="对象操纵"><a href="#对象操纵" class="headerlink" title="对象操纵"></a>对象操纵</h3><p>​“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳”。（引用自 莎士比亚，《罗密欧与朱丽叶》）。</p><p>​Java 利用万物皆对象的思想和单一一致的语法方式来简化问题。&#x3D;&#x3D;虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用”&#x3D;&#x3D; [^1]。举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s;<br></code></pre></td></tr></table></figure><p>​这里我们只是&#x3D;&#x3D;创建了一个 <strong>String</strong> 对象的引用，而非对象&#x3D;&#x3D;。直接拿来使用会出现错误：&#x3D;&#x3D;因为此时你并没有给变量 <code>s</code> 赋值—指向任何对象&#x3D;&#x3D;。通常更安全的做法是：创建一个引用的同时进行初始化。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asdf&quot;</span>;<br></code></pre></td></tr></table></figure><p>​Java 语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>​“引用”用来关联“对象”。在 Java 中，通常我们使用<code>new</code>操作符来创建一个新对象。<code>new</code> 关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;asdf&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>​那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：</p><ol><li><strong>寄存器</strong>（Registers）最快的存储区域，位于 CPU 内部 <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jishuchi.com/read/onjava8/大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。">[2]</span></a></sup>。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C&#x2F;C++ 允许开发者向编译器建议寄存器的分配）。</li><li><strong>栈内存</strong>（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。&#x3D;&#x3D;<strong>因此，虽然在栈内存上存在一些 Java 数据（如对象引用）</strong>，<strong>但 Java 对象本身的数据却是保存在堆内存的。</strong>&#x3D;&#x3D;</li><li><strong>堆内存</strong>（Heap）这是一种通用的内存池（也在 RAM 区域），&#x3D;&#x3D;<strong>所有 Java 对象都存在于其中</strong>&#x3D;&#x3D;。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。&#x3D;&#x3D;创建一个对象时，只需用 <code>new</code> 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。&#x3D;&#x3D;这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。</li><li><strong>常量存储</strong>（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们&#x3D;&#x3D;置于只读存储器 ROM&#x3D;&#x3D; （只读存储器，Read Only Memory）中 <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jishuchi.com/read/onjava8/一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。">[3]</span></a></sup>。</li><li><strong>非 RAM 存储</strong>（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）&#x3D;&#x3D;序列化对象：对象被转换为字节流，通常被发送到另一台机器；&#x3D;&#x3D;（2）&#x3D;&#x3D;持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在&#x3D;&#x3D;。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。</li></ol><h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>​有一组类型在 &#x3D;&#x3D;Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。&#x3D;&#x3D;之所以这么说，是因为它们的&#x3D;&#x3D;创建并不是通过 <code>new</code> 关键字来产生&#x3D;&#x3D;。通常 &#x3D;&#x3D;<code>new</code> 出来的对象都是保存在堆内存中的&#x3D;&#x3D;，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C&#x2F;C++ 一样的策略。也就是说，不是使用 <code>new</code> 创建变量，而是使用一个“自动”变量。 这个变量直接存储”值”，并置于栈内存中，因此更加高效。</p><table><thead><tr><th align="center">基本类型</th><th align="center">大小</th><th align="center">最小值</th><th align="center">最大值</th><th align="center">包装类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">—</td><td align="center">—</td><td align="center">—</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">16 bits</td><td align="center">Unicode 0</td><td align="center">Unicode 216 -1</td><td align="center">Character</td></tr><tr><td align="center">byte</td><td align="center">8 bits</td><td align="center">-128</td><td align="center">+127</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">16 bits</td><td align="center">- 2<sup>15</sup></td><td align="center">+ 2<sup>15</sup> -1</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">32 bits</td><td align="center">- 2<sup>31</sup></td><td align="center">+ 2<sup>31</sup> -1</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">64 bits</td><td align="center">- 2<sup>63</sup></td><td align="center">+ 2<sup>63</sup> -1</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">32 bits</td><td align="center">IEEE754</td><td align="center">IEEE754</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">64 bits</td><td align="center">IEEE754</td><td align="center">IEEE754</td><td align="center">Double</td></tr><tr><td align="center">void</td><td align="center">—</td><td align="center">—</td><td align="center">—</td><td align="center">Void</td></tr></tbody></table><p>​基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;x&#x27;</span>;<br><span class="hljs-type">Character</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c);<br></code></pre></td></tr></table></figure><p>​基本类型自动转换成包装类型（自动装箱）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Character</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;x&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​相对的，包装类型转化为基本类型（自动拆箱）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ch;<br></code></pre></td></tr></table></figure><h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p><strong>BigInteger  &amp;  BigDecimal</strong></p><p>​在 Java 中有两种类型的数据可用于高精度的计算。它们是 <code>BigInteger</code> 和 <code>BigDecimal</code>。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。<br>​在 BigInteger 和 BigDecimal 这里也同样可以，只&#x3D;&#x3D;不过必须要通过调用它们的方法来实现而非运算符&#x3D;&#x3D;。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，&#x3D;&#x3D;我们牺牲了速度，但换来了精度&#x3D;&#x3D;。</p><p>​BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。</p><h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>​Java 的设计主要目标之一是安全性。</p><p>​在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。</p><p>​当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 <strong>null</strong> 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 <strong>null</strong> 的引用，则会在运行时报错。</p><p>​&#x3D;&#x3D;我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。&#x3D;&#x3D;</p><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>单行注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这是单行注释<br></code></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">/* 这是<br><span class="hljs-bullet">* </span>跨越多行的<br><span class="hljs-bullet">* </span>注释<br>*/<br></code></pre></td></tr></table></figure><h3 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h3><p>——————————————————————————————————————————————————————————</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>​大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在 C、 C++ 和 Java 中，作用域是由大括号 <code>&#123;&#125;</code> 的位置决定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-comment">// 仅 x 变量可用</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-number">96</span>;<br>        <span class="hljs-comment">// x 和 q 变量皆可用</span><br>    &#125;<br>    <span class="hljs-comment">// 仅 x 变量可用</span><br>    <span class="hljs-comment">// 变量 q 不在作用域内</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​Java 的变量只有在其作用域内才可用。缩进使得 Java 代码更易于阅读。由于 Java 是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">96</span>; <span class="hljs-comment">// Illegal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​Java 编译器会在提示变量 x 已经被定义过了。</p><h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>​Java 对象与基本类型具有不同的生命周期。当我们使用 <code>new</code> 关键字来创建 Java 对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a string&quot;</span>);<br>&#125; <br><span class="hljs-comment">// 作用域终点</span><br></code></pre></td></tr></table></figure><p>​上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。</p><p>​只要你需要，<code>new</code> 出来的对象就会一直存活下去。</p><p>​&#x3D;&#x3D;那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 <code>new</code> 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。&#x3D;&#x3D;</p><h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>​如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到 <code>type</code> 关键字。但是，事实上大多数面向对象的语言都使用 <code>class</code> 关键字类来描述一种新的对象。 通常在 <code>class</code> 关键字的后面的紧跟类的的名称。如下代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ATypeName</span> &#123;<br> <span class="hljs-comment">// 这里是类的内部</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​在上例中，我们引入了一个新的类型，尽管这个类里只有一行注释。但是我们一样可以通过 <code>new</code> 关键字来创建一个这种类型的对象。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ATypeName</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ATypeName</span>();<br></code></pre></td></tr></table></figure><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>​当我们创建好一个类之后，&#x3D;&#x3D;我们可以往类里存放两种类型的元素：方法（method）和字段（field）。&#x3D;&#x3D;类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过之前介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。下面是一个具有某些字段的类的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataOnly</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">boolean</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们必须通过这个对象的引用来指定字段值。格式：对象名称.方法名称或字段名称。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataOnly</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOnly</span>();<br>data.i = <span class="hljs-number">47</span>;<br>data.d = <span class="hljs-number">1.1</span>;<br>data.b = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h4><p>​基本类型在类中会被初始化，在方法中不会初始化，方法中需要手动初始化！！！</p><p>​&#x3D;&#x3D;这些默认值仅在 Java 初始化类的时候才会被赋予。&#x3D;&#x3D;</p><table><thead><tr><th align="center">基本类型</th><th align="center">初始值</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">char</td><td align="center">\u0000 (null)</td></tr><tr><td align="center">byte</td><td align="center">(byte) 0</td></tr><tr><td align="center">short</td><td align="center">(short) 0</td></tr><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">0.0d</td></tr></tbody></table><p>​这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 因此，若在方法中定义的基本类型数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> x;<br></code></pre></td></tr></table></figure><p>​这里的变量 x 不会自动初始化为0，因而在使用变量 x 之前，程序员有责任主动地为其赋值（和 C 、C++ 一致）。如果我们忘记了这一步， Java 将会提示我们“编译时错误，该变量可能尚未被初始化”。</p><h4 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h4><p>​在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[返回类型] [方法名](<span class="hljs-comment">/*参数列表*/</span>)&#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><p>​方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为<strong>方法签名</strong>（signature of the method）。签名作为方法的唯一标识。</p><p>​Java 中的方法只能作为类的一部分创建。它只能被对象所调用 <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jishuchi.com/read/onjava8/静态方法，我们很快就能接触到，它可以在没有对象的情况下直接被类调用。">[4]</span></a></sup>，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[对象引用].[方法名](参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, 参数<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>​&#x3D;&#x3D;方法参数列表指定了传递给方法的信息。&#x3D;&#x3D;</p><p>​参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用 [^5] 。但是引用的类型必须是正确的。如果方法需要 String 参数，则必须传入 String，否则编译器将报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">storage</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.length() * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​当返回类型为 <strong>void</strong> 时， <strong>return</strong> 关键字仅用于退出方法，因此在方法结束处的 <strong>return</strong> 可被省略。我们可以随时从方法中返回，但若方法返回类型为非 <code>void</code>，则编译器会强制我们返回相应类型的值。</p><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>——————————————————————————————————————————————————————</p><h5 id="命名可见性（反向-URL-）"><a href="#命名可见性（反向-URL-）" class="headerlink" title="命名可见性（反向 URL ）"></a>命名可见性（反向 URL ）</h5><p>​使用反向 URL 是一种新的命名空间方法，在此之前尚未有其他语言这么做过。Java 中有许多这些“创造性”地解决问题的方法。</p><h5 id="使用其他组件"><a href="#使用其他组件" class="headerlink" title="使用其他组件"></a>使用其他组件</h5><p>​ <strong>import</strong> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br></code></pre></td></tr></table></figure><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><p>​<strong>创建与类无关的方法！！！！！</strong></p><p>​类是对象的外观及行为方式的描述。通常只有在使用 <code>new</code> 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。</p><ol><li><p>有时你只想为特定字段（注：也称为属性、域）分&#x3D;&#x3D;配一个共享存储空间&#x3D;&#x3D;，而不去考虑究竟要创建多少对象，&#x3D;&#x3D;甚至根本就不创建对象&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。&#x3D;&#x3D;</p><p>当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。</p></li></ol><p>​      一些面向对象的语言使用类数据（class data）和类方法（class method），表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。</p><p>​我们可以在类的字段或方法前添加 <code>static</code> 关键字来表示这是一个静态字段或静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">47</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​相比非静态的对象，<code>static</code> 属性改变了数据创建的方式。同样，当 <code>static</code> 关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。正如我们所知，<code>static</code> 关键字的这些特性对于应用程序入口点的 <code>main()</code> 方法尤为重要。</p><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h5 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h5><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>​驼峰命名法！！</p><p>​Java 编程语言编码规范（Code Conventions for the Java Programming Language）[^10] 要求类名的首字母大写。 如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AllTheColorsOfTheRainbow</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-运算符"><a href="#第四章-运算符" class="headerlink" title="第四章 运算符"></a>第四章 运算符</h2><p>​运算符操纵数据。</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>​几乎所有运算符都&#x3D;&#x3D;只能操作基本类型（Primitives&#x3D;&#x3D;）。唯一的例外是 <code>=</code>、<code>==</code> 和 <code>!=</code>，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，&#x3D;&#x3D;<strong>String</strong> 类支持 <code>+</code> 和 <code>+=</code>。&#x3D;&#x3D;</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>​应该用括号明确规定运算顺序</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>​运算符的赋值是由符号 <code>=</code> 完成的。它代表着获取 <code>=</code> 右边的值并赋给左边的变量。&#x3D;&#x3D;右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。&#x3D;&#x3D;</p><p>​也就是说，必须要有一个物理的空间来存放右边的值。举个例子来说，可将一个常数赋给一个变量（A &#x3D; 4），但不可将任何东西赋给一个常数（比如不能 4 &#x3D; A）。</p><p>​如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。代码示例：</p><h4 id="方法调用中的别名现象"><a href="#方法调用中的别名现象" class="headerlink" title="方法调用中的别名现象"></a>方法调用中的别名现象</h4><p>————————————————————————————————————————————————————————</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>​Java 的基本算术运算符与其他大多编程语言是相同的。其中包括加号 <code>+</code>、减号 <code>-</code>、除号 <code>/</code>、乘号 <code>*</code> 以及取模 <code>%</code>（从整数除法中获得余数）。&#x3D;&#x3D;整数除法会直接砍掉小数，而不是进位。&#x3D;&#x3D;</p><p>​可用 x +&#x3D; 4 来表示：将 x 的值加上4的结果再赋值给 x。</p><p>​不带参数的 <strong>Random</strong> 对象会利用当前的时间用作随机数生成器的“种子”（seed），从而为程序的每次执行生成不同的输出</p><p>​我们通过在创建 <strong>Random</strong> 对象时提供种子（随机数生成器的初始化值，其始终为特定种子值产生相同的序列），让程序每次执行都生成相同的随机数，该对象通过调用方法 <code>nextInt()</code> 和 <code>nextFloat()</code>（还可以调用 <code>nextLong()</code> 或 <code>nextDouble()</code>），使用 <strong>Random</strong> 对象生成许多不同类型的随机数。</p><h4 id="一元加减运算符"><a href="#一元加减运算符" class="headerlink" title="一元加减运算符"></a>一元加减运算符</h4><p>——————————————————————————————————————————————————————————</p><h3 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h3><p>​对于前递增和前递减（如 <code>++a</code> 或 <code>--a</code>），会先执行递增&#x2F;减运算，再返回值。而对于后递增和后递减（如 <code>a++</code> 或 <code>a--</code>），会先返回值，再执行递增&#x2F;减运算。</p><p>在早期的 Java 演讲中，<em>Bill Joy</em>（Java 作者之一）说“<strong>Java &#x3D; C++ —</strong>”（C++ 减减），意味着 Java 在 C++ 的基础上减少了许多不必要的东西，因此语言更简单。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h4 id="测试对象等价"><a href="#测试对象等价" class="headerlink" title="测试对象等价"></a>测试对象等价</h4><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​&#x3D;&#x3D;将 int 作为布尔处理不是合法的 Java 写法&#x3D;&#x3D;</p><h4 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h4><p>​&amp;&amp;     ||</p><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>​通常，当我们向程序中插入一个字面值常量（<strong>Literal</strong>）时，编译器会确切地识别它的类型。当类型不明确时，&#x3D;&#x3D;必须辅以字面值常量关联来帮助编译器识别。&#x3D;&#x3D;代码示例：</p><p>​对于 <strong>Long</strong> 型数值，结尾使用大写 <code>L</code> 或小写 <code>l</code> 皆可（不推荐使用 <code>l</code>，因为容易与阿拉伯数值 1 混淆）。大写 <code>F</code> 或小写 <code>f</code> 表示 <strong>float</strong> 浮点数。大写 <code>D</code> 或小写 <code>d</code> 表示 <strong>double</strong> 双精度。</p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><h4 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h4><ol><li><p><code>// &quot;e&quot; 表示 10 的几次幂</code></p><p>在科学与工程学领域，<strong>e</strong> 代表自然对数的基数，约等于 2.718 （Java 里用一种更精确的 <strong>double</strong> 值 <strong>Math.E</strong> 来表示自然对数）。指数表达式 “1.39 x e-43”，意味着 “1.39 × 2.718 的 -43 次方”。</p><p>&#x3D;&#x3D;所以倘若习惯 e 作为自然对数的基数使用，那么在 Java 中看到类似“1.39e-43f”这样的表达式时，请转换你的思维，从程序设计的角度思考它；它真正的含义是 “1.39 × 10 的 -43 次方”。&#x3D;&#x3D;</p></li></ol><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>————————————————————————————————————————————————</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>————————————————————————————————————————————————</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>​布尔表达式 ? 值 1 : 值 2</p><p>​三元运算符的引入多半就是为了高效编程，但假若我们打算频繁使用它的话，还是先多作一些思量： 它易于产生可读性差的代码。&#x3D;&#x3D;与 <strong>if-else</strong> 不同的是，三元运算符是有返回结果的。&#x3D;&#x3D;</p><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>​我们注意到运用 <code>String +</code> 时有一些有趣的现象。&#x3D;&#x3D;若表达式以一个 <strong>String</strong> 类型开头（编译器会自动将双引号 <code>&quot;&quot;</code> 标注的的字符序列转换为字符串），那么后续所有运算对象都必须是字符串。&#x3D;&#x3D;</p><h3 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h3><p>——————————————————————————————————————————————</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>​“类型转换”（Casting）的作用是“与一个模型匹配”。在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为 <strong>float</strong> 变量赋值一个整数值，计算机会将 <strong>int</strong> 自动转换成 <strong>float</strong>。我们可以在程序未自动转换时显式、强制地使此类型发生转换。</p><p>​在 Java 里，类型转换则是一种比较安全的操作。但是，若将数据类型进行“向下转换”（<strong>Narrowing Conversion</strong>）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型，好比在提醒我们：该操作可能危险，若你坚持让我这么做，那么对不起，请明确需要转换的类型。 对于“向上转换”（<strong>Widening conversion</strong>），则不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。</p><p>​除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。</p><h4 id="截断和舍入"><a href="#截断和舍入" class="headerlink" title="截断和舍入"></a>截断和舍入</h4><p>​从 <strong>float</strong> 和 <strong>double</strong> 转换为整数值时，小数位将被截断。&#x3D;&#x3D;退一法！！！！！！&#x3D;&#x3D;</p><p>​若你想对结果进行四舍五入，可以使用 <code>java.lang.Math</code> 的 <code>round()</code> 方法：</p><h4 id="x3D-x3D-类型提升-x3D-x3D"><a href="#x3D-x3D-类型提升-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;类型提升&#x3D;&#x3D;"></a>&#x3D;&#x3D;类型提升&#x3D;&#x3D;</h4><p>​你会发现，如果我们对小于 <strong>int</strong> 的基本数据类型（即 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 <strong>int</strong>，并且结果值的类型为 <strong>int</strong>。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。&#x3D;&#x3D;通常，表达式中最大的数据类型是决定表达式结果的数据类型。&#x3D;&#x3D;<strong>float</strong> 型和 <strong>double</strong> 型相乘，结果是 <strong>double</strong> 型的；<strong>int</strong> 和 <strong>long</strong> 相加，结果是 <strong>long</strong> 型。</p><h3 id="Java没有sizeof"><a href="#Java没有sizeof" class="headerlink" title="Java没有sizeof"></a>Java没有sizeof</h3><p>​Java 不需要 <code>sizeof()</code> 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</p><h3 id="运算符总结"><a href="#运算符总结" class="headerlink" title="运算符总结"></a>运算符总结</h3><p>​<strong>注意</strong> ：<strong>boolean</strong> 类型的运算是受限的。你能为其赋值 <code>true</code> 或 <code>false</code>，也可测试它的值是否是 <code>true</code> 或 <code>false</code>。但你不能对其作加减等其他运算。</p><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><p>​我在 <em>Pomona College</em> 大学读过两年本科，在那里 47 被称之为“魔法数字”（<em>magic number</em>），详见 <a href="https://en.wikipedia.org/wiki/47_(number)">维基百科</a> 。</p><h2 id="第五章-控制流"><a href="#第五章-控制流" class="headerlink" title="第五章 控制流"></a>第五章 控制流</h2><p>​程序必须在执行过程中控制它的世界并做出选择。 在 Java 中，你需要执行控制语句来做出选择。</p><h3 id="true和false"><a href="#true和false" class="headerlink" title="true和false"></a>true和false</h3><p>​&#x3D;&#x3D;所有的条件语句都利用条件表达式的“真”或“假”来决定执行路径。&#x3D;&#x3D;</p><p>​任何关系运算符都可以产生条件语句</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>else if</code> 并非新关键字，它仅是 <code>else</code> 后紧跟的一条新 <code>if</code> 语句。</p><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>​<strong>while</strong>，<strong>do-while</strong> 和 <strong>for</strong> 用来控制循环语句（有时也称迭代语句）。只有控制循环的布尔表达式计算结果为 <code>false</code>，循环语句才会停止。</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h4 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h4><p>​<strong>while</strong> 和 <strong>do-while</strong> 之间的唯一区别是：即使条件表达式返回结果为 <code>false</code>， &#x3D;&#x3D;<strong>do-while</strong> 语句也至少会执行一次&#x3D;&#x3D;。 在 <strong>while</strong> 循环体中，如布尔表达式首次返回的结果就为 <code>false</code>，那么循环体内的语句不会被执行。实际应用中，<strong>while</strong> 形式比 <strong>do-while</strong> 更为常用。</p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>​<strong>for</strong> 循环可能是最常用的迭代形式。 该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。<strong>for</strong> 循环的形式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(initialization; Boolean-expression; step)<br>  statement<br></code></pre></td></tr></table></figure><p>​初始化 (initialization) 表达式、布尔表达式 (Boolean-expression) ，或者步进 (step) 运算，都可以为空。每次迭代之前都会判断布尔表达式的结果是否成立。一旦计算结果为 <code>false</code>，则跳出 <strong>for</strong> 循环体并继续执行后面代码。 每次循环结束时，都会执行一次步进。</p><h5 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h5><p>​在 Java 中逗号运算符（这里并非指我们平常用于分隔定义和方法参数的逗号分隔符）仅有一种用法：在 <strong>for</strong> 循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。<strong>注意</strong>：要求定义的变量类型相同。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// control/CommaOperator.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommaOperator</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = i + <span class="hljs-number">10</span>; i &lt; <span class="hljs-number">5</span>; i++, j = i * <span class="hljs-number">2</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-in-语法"><a href="#for-in-语法" class="headerlink" title="for-in 语法"></a>for-in 语法</h3><p>​Java 5 引入了更为简洁的“增强版 <strong>for</strong> 循环”语法来操纵数组和集合。</p><p>​这条语句定义了一个 <strong>float</strong> 类型的变量 <code>x</code>，继而将每一个 <code>f</code> 的元素赋值给它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> x : f) &#123;&#125;<br></code></pre></td></tr></table></figure><p>​<strong>for-in</strong> 无需你去创建 <strong>int</strong> 变量和步进来控制循环计数。 下面我们来遍历获取 <strong>float</strong> 数组中的元素。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// control/ForInFloat.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForInFloat</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>);<br>    <span class="hljs-type">float</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>      f[i] = rand.nextFloat();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> x : f)<br>      System.out.println(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​任何一个返回数组的方法都可以使用 <strong>for-in</strong> 循环语法来遍历元素。例如 <strong>String</strong> 类有一个方法 <code>toCharArray()</code>，返回值类型为 <strong>char</strong> 数组，我们可以很容易地在 <strong>for-in</strong> 循环中遍历它。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// control/ForInString.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForInString</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-string">&quot;An African Swallow&quot;</span>.toCharArray())<br>      System.out.print(c + <span class="hljs-string">&quot; &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<em>for-in</em> 语法可以节省我们编写代码的时间。 更重要的是，它提高了代码可读性以及更好地描述代码意图（获取数组的每个元素）而不是详细说明这操作细节（创建索引，并用它来选择数组元素） &#x3D;&#x3D;本书推荐使用 <em>for-in</em> 语法&#x3D;&#x3D;。</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>​<strong>return</strong> 关键字有两方面的作用：1.指定一个方法返回值 (在方法返回类型非 <strong>void</strong> 的情况下)；2.退出当前方法。</p><p>​如果在方法签名中定义了返回值类型为 <strong>void</strong>，那么在代码执行结束时会有一个隐式的 <strong>return</strong>。 也就是说我们不用在总是在方法中显式地包含 <strong>return</strong> 语句。 <strong>注意</strong>：如果你的方法声明的返回值类型为非 <strong>void</strong> 类型，那么则必须确保每个代码路径都返回一个值。</p><h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>​在任何迭代语句的主体内，都可以使用 <strong>break</strong> 和 <strong>continue</strong> 来控制循环的流程。 其中，<strong>break</strong> 表示跳出当前循环体。而 <strong>continue</strong> 表示停止本次循环，开始下一次循环。</p><h3 id="臭名昭著的-goto"><a href="#臭名昭著的-goto" class="headerlink" title="臭名昭著的 goto"></a>臭名昭著的 goto</h3><p>—————————————————————————————————————————————————————————————</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>​<strong>switch</strong> 有时也被划归为一种选择语句。根据整数表达式的值，<strong>switch</strong> 语句可以从一系列代码中选出一段去执行。</p><p>​case后不一定是整数，可以是char String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(integral-selector) &#123;<br>    <span class="hljs-keyword">case</span> integral-value1 : statement; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> integral-value2 : statement;    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> integral-value3 : statement;    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> integral-value4 : statement;    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> integral-value5 : statement;    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">default</span>: statement;<br>&#125;<br></code></pre></td></tr></table></figure><p>​一旦理解了 <strong>switch</strong>，你会明白这其实就是一个逻辑扩展的&#x3D;&#x3D;语法糖&#x3D;&#x3D;。新的编码方式能使得结果更清晰，更易于理解和维护。</p><h3 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h3><p><code>Math.random()</code> 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1) 来表示。</p><h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><p>—————————————————————————————————————————————————————————————</p><h2 id="第六章-初始化和清理"><a href="#第六章-初始化和清理" class="headerlink" title="第六章 初始化和清理"></a>第六章 初始化和清理</h2><p>​Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在 Java 中对它们的支持。</p><h3 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h3><p>​你可能想为每个类创建一个 <code>initialize()</code> 方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。</p><p>​ Java 中使用了同样的方式：&#x3D;&#x3D;构造器名称与类名相同&#x3D;&#x3D;。在初始化过程中自动调用构造器方法是有意义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rock</span> &#123;<br>    Rock() &#123; <span class="hljs-comment">// 这是一个构造器</span><br>        System.out.print(<span class="hljs-string">&quot;Rock &quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleConstructor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rock</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p><code>Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock</code></p></blockquote><p>​现在，当创建一个对象时：<code>new Rock()</code> ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。</p><p>​&#x3D;&#x3D;构造器没有返回值&#x3D;&#x3D;，它是一种特殊的方法。但它和返回类型为 <code>void</code> 的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值，却同时也没有给你选择的余地（<code>new</code> 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值（这个返回值没有接收者）。</p><h3 id="方法重载-方法名相同，参数不同"><a href="#方法重载-方法名相同，参数不同" class="headerlink" title="方法重载(方法名相同，参数不同)"></a>方法重载(方法名相同，参数不同)</h3><p>​在 Java (C++) 中，还有一个因素也促使了必须使用方法重载：&#x3D;&#x3D;构造器&#x3D;&#x3D;。因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。</p><p>​因此，方法重载是必要的，它允许方法&#x3D;&#x3D;具有相同的方法名但接收的参数不同（和返回值无关）&#x3D;&#x3D;。尽管方法重载对于构造器是重要的，但是也可以很方便地对其他任何方法进行重载。</p><h4 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h4><h4 id="重载与基本类型"><a href="#重载与基本类型" class="headerlink" title="重载与基本类型"></a>重载与基本类型</h4><h3 id="返回值的重载"><a href="#返回值的重载" class="headerlink" title="返回值的重载"></a>返回值的重载</h3><p>​重载与是否有返回值无关！！！</p><h3 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h3><p>​&#x3D;&#x3D;编译器默认给一个无参构造方法。一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。&#x3D;&#x3D;</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>​<strong>this</strong> 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，<strong>this</strong> 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用该类的其他方法，不要使用 <strong>this</strong>，直接调用即可，<strong>this</strong> 自动地应用于其他方法上了。因此你可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Leaf <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Leaf</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        x.increment().increment().increment().print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结果：<code>i = 3</code></p></blockquote><p>​因为 <code>increment()</code> 通过 <strong>this</strong> 关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。</p><h4 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h4><p>————————————————————————————————————————————————————————————</p><h4 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h4><p>​记住了 <strong>this</strong> 关键字的内容，你会对 <strong>static</strong> 修饰的方法有更加深入的理解：<strong>static</strong> 方法中不会存在 <strong>this</strong>。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以访问其他静态方法和静态属性。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 <strong>this</strong>，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 <strong>static</strong> 方法，就该重新考虑自己的设计了。然而，<strong>static</strong> 的概念很实用，许多时候都要用到它。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title="finalize() 的用途"></a>finalize() 的用途</h4><h4 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h4><h4 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h4><h4 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h4><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><h4 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h4><h3 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h3><h4 id="x3D-x3D-初始化的顺序-x3D-x3D"><a href="#x3D-x3D-初始化的顺序-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;初始化的顺序&#x3D;&#x3D;"></a>&#x3D;&#x3D;初始化的顺序&#x3D;&#x3D;</h4><p>​&#x3D;&#x3D;<strong>类变量——&gt;构造方法——&gt;普通方法</strong>&#x3D;&#x3D;</p><p>​在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// housekeeping/OrderOfInitialization.java</span><br><span class="hljs-comment">// Demonstrates initialization order</span><br><span class="hljs-comment">// When the constructor is called to create a</span><br><span class="hljs-comment">// Window object, you&#x27;ll see a message:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br>    Window(<span class="hljs-type">int</span> marker) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Window(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> &#123;<br>    <span class="hljs-type">Window</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Before constructor</span><br>    House() &#123;<br>        <span class="hljs-comment">// Show that we&#x27;re in the constructor:</span><br>        System.out.println(<span class="hljs-string">&quot;House()&quot;</span>);<br>        w3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-number">33</span>); <span class="hljs-comment">// Reinitialize w3</span><br>    &#125;<br>    <span class="hljs-type">Window</span> <span class="hljs-variable">w2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// After constructor</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f()&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Window</span> <span class="hljs-variable">w3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// At end</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderOfInitialization</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">House</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">House</span>();<br>        h.f(); <span class="hljs-comment">// Shows that construction is done</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><ol><li><code>Window(1)</code></li><li><code>Window(2)</code></li><li><code>Window(3)</code></li><li><code>House()</code></li><li><code>Window(33)</code></li><li><code>f()</code></li></ol></blockquote><p>​在 <strong>House</strong> 类中，故意把几个 <strong>Window</strong> 对象的定义散布在各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，<strong>w3</strong> 在构造器中被再次赋值。</p><p>​由输出可见，引用 <strong>w3</strong> 被初始化了两次：一次在调用构造器前，一次在构造器调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）。这乍一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化 <strong>w3</strong>，同时在定义 <strong>w3</strong> 时没有赋予初值，那会产生怎样的后果呢？</p><h4 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h4><p>​无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p><p>​下面例子显示了静态存储区是何时初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// housekeeping/StaticInitialization.java</span><br><span class="hljs-comment">// Specifying initial values in a class definition</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bowl</span> &#123;<br>    Bowl(<span class="hljs-type">int</span> marker) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bowl(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> marker)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f1(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Table</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Bowl</span> <span class="hljs-variable">bowl1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bowl</span>(<span class="hljs-number">1</span>);<br>    Table() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Table()&quot;</span>);<br>        bowl2.f1(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">int</span> marker)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f2(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Bowl</span> <span class="hljs-variable">bowl2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bowl</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cupboard</span> &#123;<br>    <span class="hljs-type">Bowl</span> <span class="hljs-variable">bowl3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bowl</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Bowl</span> <span class="hljs-variable">bowl4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bowl</span>(<span class="hljs-number">4</span>);<br>    Cupboard() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cupboard()&quot;</span>);<br>        bowl4.f1(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f3</span><span class="hljs-params">(<span class="hljs-type">int</span> marker)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f3(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Bowl</span> <span class="hljs-variable">bowl5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bowl</span>(<span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInitialization</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main creating new Cupboard()&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cupboard</span>();<br>        System.out.println(<span class="hljs-string">&quot;main creating new Cupboard()&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cupboard</span>();<br>        table.f2(<span class="hljs-number">1</span>);<br>        cupboard.f3(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Table</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Cupboard</span> <span class="hljs-variable">cupboard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cupboard</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Bowl</strong> 类展示类的创建，而 <strong>Table</strong> 和 <strong>Cupboard</strong> 在它们的类定义中包含 <strong>Bowl</strong> 类型的静态数据成员。注意，在静态数据成员定义之前，<strong>Cupboard</strong> 类中先定义了一个 <strong>Bowl</strong> 类型的非静态成员 <strong>b3</strong>。</p><p>由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 <strong>Table</strong> 对象，也不引用 <strong>Table.bowl1</strong> 或 <strong>Table.bowl2</strong>，那么静态的 <strong>Bowl</strong> 类对象 <strong>bowl1</strong> 和 <strong>bowl2</strong> 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。</p><p>初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，从输出中可以看出。要执行 <code>main()</code> 方法，必须加载 <strong>StaticInitialization</strong> 类，它的静态属性 <strong>table</strong> 和 <strong>cupboard</strong> 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 <strong>Bowl</strong> 对象，所以 <strong>Bowl</strong> 类也会被加载。因此，在这个特殊的程序中，所有的类都会在 <code>main()</code> 方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过 <strong>static</strong> 联系起来。</p><p>&#x3D;&#x3D;概括一下创建对象的过程，假设有个名为 <strong>Dog</strong> 的类：&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;即使没有显式地使用 <strong>static</strong> 关键字，构造器实际上也是静态方法。所以，当首次创建 <strong>Dog</strong> 类型的对象或是首次访问 <strong>Dog</strong> 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 <strong>Dog.class</strong>。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;当加载完 <strong>Dog.class</strong> 后（后面会学到，这将创建一个 <strong>Class</strong> 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 <strong>Class</strong> 对象时初始化一次。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 <strong>Dog</strong> 对象分配足够的存储空间。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;分配的存储空间首先会被清零，即会将 <strong>Dog</strong> 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 <strong>null</strong>。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;执行所有出现在字段定义处的初始化动作。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。&#x3D;&#x3D;</li></ol><p>——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————</p><h4 id="显式的静态初始化"><a href="#显式的静态初始化" class="headerlink" title="显式的静态初始化"></a>显式的静态初始化</h4><h4 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h4><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><h4 id="动态数组创建"><a href="#动态数组创建" class="headerlink" title="动态数组创建"></a>动态数组创建</h4><h4 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h4><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><h3 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jishuchi.com/read/onjava8/%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E8%8A%AF%E7%89%87%E9%83%BD%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%8C%E4%BD%86%E8%BF%99%E6%98%AF%E6%8C%89%E7%85%A7%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E5%99%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82">https://www.jishuchi.com/read/onjava8/大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.jishuchi.com/read/onjava8/%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%83%BD%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%94%BE%E5%85%A5%E7%89%B9%E6%AE%8A%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E4%B8%AD%E3%80%82">https://www.jishuchi.com/read/onjava8/一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.jishuchi.com/read/onjava8/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BE%88%E5%BF%AB%E5%B0%B1%E8%83%BD%E6%8E%A5%E8%A7%A6%E5%88%B0%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9B%B4%E6%8E%A5%E8%A2%AB%E7%B1%BB%E8%B0%83%E7%94%A8%E3%80%82">https://www.jishuchi.com/read/onjava8/静态方法，我们很快就能接触到，它可以在没有对象的情况下直接被类调用。</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/09/hello-world/"/>
    <url>/2023/01/09/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="【保姆级】利用Github搭建自己的个人博客，看完就会"><a href="#【保姆级】利用Github搭建自己的个人博客，看完就会" class="headerlink" title="     【保姆级】利用Github搭建自己的个人博客，看完就会      "></a><a href="https://www.cnblogs.com/chenlove/p/15058170.html">     【保姆级】利用Github搭建自己的个人博客，看完就会      </a></h1><p><img src="/a6cb8b57-7d6c-4116-b5d9-6d22228fafce.jpg" alt="img"></p><p>大家好，我是辰哥~</p><p>作为一名喜欢技术的爱好者，平时喜欢把自己学习技术的心得或者一些踩坑、易错的过程记录下来，首选的是技术平台(博客)，今天辰哥来教大家如何利用Github来搭建一个自己的个人博客平台。</p><p>相信Github大家都有听过，甚至是经常用，除了可以作为开源源码的交流平台，还提供了搭建博客的功能。目前一些大佬、老师的博客用的就是Github搭建的（辰哥见过很多）</p><blockquote><p>访问地址：</p><p><a href="https://liyunchen.github.io/">https://liyunchen.github.io</a></p></blockquote><p><img src="/8ae440a4-6f5c-4698-b516-4edfe3079e44.png" alt="img"></p><h1 id="01、环境准备"><a href="#01、环境准备" class="headerlink" title="01、环境准备"></a>01、环境准备</h1><p>在搭建Github博客之前，先准备一下环境（安装下方的顺序来安装，别弄混了）</p><blockquote><p>1.安装git</p><p>官方地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p></blockquote><p>1、访问git官方地址，下载对应的安装包，进行安装（简单的点击下一步）。</p><p>2、安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。</p><p>3、输入：git –version</p><p><img src="/f30d04a4-afde-438c-b5fe-21a2ef2490f6.png" alt="img"></p><p>出现这个说明git安装成功。</p><blockquote><p>2.安装node.js</p><p>官方地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p></blockquote><p>1、访问nodejs官方地址，下载对应的安装包，进行安装（简单的点击下一步）。</p><p>2、安装好之后，配置环境变量，并在终端里面输入：node -v</p><p><img src="/59e55c69-d561-4272-a137-1fad1d12b0cd.png" alt="img"></p><p>出现这个说明nodejs安装成功~</p><blockquote><p>3.安装Hexo</p><p>安装命令：npm install hexo -g</p></blockquote><p><img src="/d10fd552-f745-4232-897e-af29940534cc.png" alt="img"></p><p>测试是否安装成功，命令：hexo -v</p><p><img src="/05c52334-15c5-4897-a953-42a1509aa902.png" alt="img"></p><blockquote><p>4.安装hexo依赖</p><p>命令：npm install <code>--</code>save hexo-deployer-git</p></blockquote><p><img src="/afa1850f-59f5-49c0-8322-5b772ac9f57b.png" alt="img"></p><h1 id="02、git配置SSH-key"><a href="#02、git配置SSH-key" class="headerlink" title="02、git配置SSH key"></a>02、git配置SSH key</h1><p>相信看到本文的你应该听过github，并且也注册了自己的github账号，如果现在还没有的可以去github注册一个账号。</p><blockquote><p>为什么要配置SSH key？</p><p>目的：可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。</p></blockquote><p>先看本地是否配置好SSH key（命令：cd ~&#x2F;.ssh）</p><p><img src="/d9c6a37a-0cfd-4216-a245-d4f227ef7c13.png" alt="img"></p><p>这里辰哥之前就配置了，现在删除配置，重新配置一边，方便读者可以跟着进行配置。</p><p>再次查看</p><p><img src="/5470a911-fcc9-4f0c-96c9-98b6d7581c12.png" alt="img"></p><p>可以看到提示：&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh: No such file or directory</p><blockquote><p>备注：</p><p>因为ssh配置好之后是保存到 c:&#x2F;用户&#x2F;Administrator&#x2F;.ssh</p></blockquote><h3 id="1-配置ssh"><a href="#1-配置ssh" class="headerlink" title="1.配置ssh"></a>1.配置ssh</h3><blockquote><p>先生成ssh key</p><p>ssh-keygen -t rsa -C “邮件地址”</p><p>备注：这里的邮件地址是github账号绑定的邮件地址</p></blockquote><p>输入生成命令：ssh-keygen -t rsa -C “邮件地址”后。连续回车三次即可</p><p><img src="/54b53ebb-870c-4375-acf3-70694657d62e.png" alt="img"></p><p>可以看到在用户文件夹下生成了一个ssh文件夹</p><p><img src="/11a32446-2848-4b5b-bff6-9a3d418cca5c.png" alt="img"></p><p>进入到ssh文件夹，复制id_rsa.pub文件里全部内容</p><p><img src="/a3b5e0bb-7263-4537-ac58-61c759c81698.png" alt="img"></p><p>接着打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key</p><p><img src="/f4ca3e16-4532-4f16-a208-ba8804e7dc01.png" alt="img"></p><p>将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。</p><p><img src="/b7f92c34-0452-4125-98a6-907b7e6f8ac9.png" alt="img"></p><p>点击 Add SSH key</p><blockquote><p>测试是否成功：</p><p>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#x6d;</a></p></blockquote><p>输入测试命令后，接着输入yes，出现下面这个提示说明成功</p><p><img src="/ba60eab6-11a9-4d3a-8905-39b5fb181475.png" alt="img"></p><p>配置账号和密码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> user.name <span class="string">&quot;liyunchen&quot;</span> <span class="meta">#你的github用户名</span></span><br><span class="line">$ git config --<span class="keyword">global</span> user.email <span class="string">&quot;xxx@163.com&quot;</span> <span class="meta">#填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><blockquote><p>备注：用户名和邮箱记得改为 自己的</p></blockquote><h1 id="03-搭建个人博客"><a href="#03-搭建个人博客" class="headerlink" title="03 搭建个人博客"></a>03 搭建个人博客</h1><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1.新建博客"></a>1.新建博客</h3><p>开始之前先介绍一下heox的基本命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;postName&quot;</span> <span class="meta">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;pageName&quot;</span> <span class="meta">#新建页面</span></span><br><span class="line">hexo generate <span class="meta">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="meta">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="meta">#部署到GitHub</span></span><br><span class="line">hexo help  <span class="meta"># 查看帮助</span></span><br><span class="line">hexo version  <span class="meta">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><blockquote><p>对应的缩写，比如：</p><p>hexo n &#x3D;&#x3D; hexo new</p><p>hexo g &#x3D;&#x3D; hexo generate</p></blockquote><p>新建一个保存博客的存放目录，比如辰哥的是：D:\公众号\0722</p><blockquote><p>进入到本地博客存放目录</p><p>初始化 个人博客</p><p>命令：hexo init</p></blockquote><p><img src="/1a54f050-706f-4c42-997e-830ba6d2196b.png" alt="img"></p><p>可以看到博客存放目录出现了如下内容：</p><p><img src="/d943b043-2069-4301-bf62-4c51ec8b4744.png" alt="img"></p><blockquote><h1 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h1></blockquote><p>命令：hexo g</p><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><blockquote><p>命令：hexo s</p></blockquote><p><img src="/a279a1e5-a4c8-44b3-9e6c-85016331acd7.png" alt="img"></p><blockquote><p>报错解决：</p><h1 id="问题：hexo-g报错-line-mathALL-is-not-funciton问题解决"><a href="#问题：hexo-g报错-line-mathALL-is-not-funciton问题解决" class="headerlink" title="问题：hexo g报错,line.mathALL is not funciton问题解决"></a>问题：hexo g报错,line.mathALL is not funciton问题解决</h1></blockquote><blockquote><p>原因：nodejs版本低于12</p><p>解决：两种方法</p><p>方法1）请将nodejs升级到高于12.0.0的版本</p><p>方法2）config.xml中的 highlight-&gt;enable的值从true更改为false，这样可以避免异常。</p></blockquote><blockquote><p>在浏览器这访问：</p><p><a href="http://localhost:4000/">http://localhost:4000/</a></p></blockquote><p><img src="/defb69f9-e4a3-4a70-881c-897425ec5726.png" alt="img"></p><p>可以看到访问没问题。</p><p>但这个只是在本地预览，接着将这个博客部署到github。</p><h3 id="2-部署到github"><a href="#2-部署到github" class="headerlink" title="2.部署到github"></a>2.部署到github</h3><p>新建一个github仓库</p><p><img src="/1af3ea81-bbf0-490b-95a1-aebacac1cda0.png" alt="img"></p><p>给仓库起个名称，注意！注意！注意！</p><blockquote><p>仓库名称格式： 用户名.github.io</p></blockquote><p>辰哥的仓库名称为：liyunchen.github.io</p><p>因为这个仓库名称将作为你github博客的访问地址</p><p><img src="/ea97d653-dde7-4509-9499-76ebdce61efc.png" alt="img"></p><p>编辑_config.yml，_config.yml在博客存放目录下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:liyunchen/liyunchen.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>repository仓库地址改为自己的</p><p>branch看自己的github仓库是master还是main，辰哥这里是main，所以就填写main</p><p><img src="/8d9b82b4-16e4-4b1e-bbbe-ce8f66b6f4da.png" alt="img"></p><blockquote><p>发布到github</p><p>命令：hexo d</p></blockquote><p><img src="/0f4fbfdb-d75d-4f1b-9174-9c3d2b59128a.png" alt="img"></p><blockquote><p>在浏览器访问</p><p><a href="https://liyunchen.github.io/">https://liyunchen.github.io/</a></p></blockquote><p><img src="/b56d3741-16ab-407b-a9c9-56c37107dc01.png" alt="img"></p><p>可以看到成功访问</p><blockquote><p>这个博客地址已经是部署到了公网，感兴趣的读者也可以访问</p></blockquote><h1 id="04-编写博客"><a href="#04-编写博客" class="headerlink" title="04 编写博客"></a>04 编写博客</h1><p>搭建好博客之后，日常中肯定是需要编写博客并且同步到github，辰哥来带大家写一篇博客</p><blockquote><p>新建一篇名为：chenge-first-blog的博客</p><p>命令：hexo new ‘chenge-first-blog’</p></blockquote><p><img src="/07e87a30-a27e-4bea-92d0-1165eb70604a.png" alt="img"></p><p>查看对应的文件夹</p><p><img src="/bb66ed2e-9780-4759-8410-bfce47d3341b.png" alt="img"></p><p>可以看到生成了一个chenge-first-blog.md文件，通过这个md文件去写博客</p><p>默认的内容是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">chenge-first-blog</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-07-22 14:08:14</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">这里方开始编写正文</span></span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>开始编写博客内容（markdown格式）</p><p><img src="/b2e84948-2222-4c1c-83eb-0ed711ab4f39.png" alt="img"></p><p>这里辰哥以之前的一篇文章为例</p><p>其中的，作用是在查看文章的时候，点击more的时候再加载全部的文章内容</p><p>编写好之后，开始部署到github</p><blockquote><p>1.生成html文件</p><p>hexo g</p><p>2.上传到github</p><p>hexo d</p></blockquote><p>再次访问：</p><blockquote><p><a href="https://liyunchen.github.io/">https://liyunchen.github.io/</a></p></blockquote><p><img src="/81697626-e70a-4ac5-afb5-3b9d003a00e8.png" alt="img"></p><p>可以看到编写的博客已经同步到github平台，并且的作用也可以看到了：read more</p><h1 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h1><p>本文从0到1搭建了自己的个人博客，过程很详细，并且可能会出现的错误都做出了说明和解决方法。绝对的保姆级教程，看完就会</p><p>希望看到本文的你可以给辰哥一个赞，点个再看就更好了，鼓励原创作者不断前进。最后附上辰哥搭建好的博客地址，所有人都有可以访问。</p><blockquote><p>访问地址：</p><p><a href="https://liyunchen.github.io/">https://liyunchen.github.io</a></p></blockquote><p>​     耐得住寂寞，才能登得顶<br> Gitee码云：<a href="https://gitee.com/lyc96/projects">https://gitee.com/lyc96/projects</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
