<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-小胡子的第二篇blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/" class="article-date">
  <time datetime="2023-01-09T03:40:24.000Z" itemprop="datePublished">2023-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/">小胡子的第二篇blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>123</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/" data-id="clco9b2qx00009gn3fr2q7lko" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%AC%E4%BA%8C%E7%AF%87blog/" rel="tag">第二篇blog</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-小胡子的第一篇blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/" class="article-date">
  <time datetime="2023-01-09T03:19:37.000Z" itemprop="datePublished">2023-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/">小胡子的第一篇blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="On-Java-8"><a href="#On-Java-8" class="headerlink" title="On Java 8"></a>On Java 8</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>信息的重要性是分层次结构的。</p>
<p>绝大多数情况下，我们没必要弄清问题的所有本质。好比编程语言中的某些特性和实现细节，95% 的程序员都不需要去知道。这些细节除了会加重你的学习成本，还让你更觉得这门语言好复杂。如果你非要考虑这些细节，那么它还会迷惑该代码的阅读者/维护者，所以我主张选择简单的方法解决问题。</p>
<p>新手程序员并没有经历过“语言为何采用某种方式实现”的争议过程。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        “语言观决定世界观。” ——路德维希·维特根斯坦（<em>Wittgenstein</em>）</p>
<p>​        <strong>java是强类型语言！！！！</strong></p>
<p>​        Java 最核心的变化就是加入了<strong>“虚拟机”</strong>和<strong>“垃圾回收机制”</strong>，这两个概念在之后的章节会有详细描述。 此外，Java 还在其他方面推动了行业发展。例如，现在绝大多数编程语言都支持文档注释语法和 HTML 文档生成工具。</p>
<p>这无关 Java 是一种好语言或者坏语言，一旦你了解了该语言的缺陷和局限性，你就能够：</p>
<ol>
<li>明白有些功能特性为什么会被“废弃”。</li>
<li>熟悉语言边界，更好地设计和编码。</li>
</ol>
<h2 id="第一章-对象的概念"><a href="#第一章-对象的概念" class="headerlink" title="第一章 对象的概念"></a>第一章 对象的概念</h2><p>​        计算机革命的起源来自机器。编程语言就像是那台机器。它不仅是我们思维放大的工具与另一种表达媒介，更像是我们思想的一部分。语言的灵感来自其他形式的表达，如写作，绘画，雕塑，动画和电影制作。编程语言就是创建应用程序的思想结构。</p>
<p>面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>​        所有编程语言都提供抽象机制。从某种程度上来说，问题的复杂度直接取决于抽象的类型和质量。这里的“类型”意思是：抽象的内容是什么？汇编语言是对底层机器的轻微抽象。接着出现的“命令式”语言（如 FORTRAN，BASIC 和 C）是对汇编语言的抽象。与汇编相比，这类语言已有了长足的改进，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非问题本身的结构。</p>
<p>​        程序员必须要在==机器模型（“解决方案空间”）==和实际解决的==问题模型（“问题空间”）==之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。这使得程序代码很难编写，维护代价高昂。同时还造就了一个副产业“编程方法”学科。</p>
<p>​        面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将==问题空间中的元素以及它们在解决方案空间的表示称作“对象”（<strong>Object</strong>）。==当然，还有一些在问题空间没有对应的对象体。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。</p>
<p>​        ==OOP 允许我们根据问题来描述问题，而不是根据运行解决方案的计算机。==</p>
<p>​        然而，它仍然与计算机有联系，每个对象都类似一台小计算机：它们有自己的状态并且可以进行特定的操作。这与现实世界的“对象”或者“物体”相似：==它们都有自己的特征和行为。==</p>
<p>​        <strong>理解“纯粹”的面向对象程序设计方法是什么样的：以下5点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 万物皆对象。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 程序是一组对象，通过消息传递来告知彼此该做什么。要请求调用一个对象的方法，你需要向该对象发送消息。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给”形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</span><br></pre></td></tr></table></figure>

<p>​        <em>Grady Booch</em> 提供了对对象更简洁的描述：一==个对象具有自己的状态，行为和标识。==这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>​        创建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。事实上，当我们进行面向对象的程序设计时，面临的最大一项挑战是：==如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系。==</p>
<p>​    我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。==“类型”与“接口”的对应关系是面向对象程序设计的基础。==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure>



<img src="D:\2 ASK-Ability,Skills and Knowledge\9 笔记\12 第二阶段笔记-202221103\On Java 8.assets\image-20221114222458676.png" alt="image-20221114222458676" style="zoom: 50%;" />

<p>​        在这个例子中，类型／类的名称是 <strong>Light</strong>，可向 <strong>Light</strong> 对象发出的请求包括打开 <code>on</code>、关闭 <code>off</code>、变得更明亮 <code>brighten</code> 或者变得更暗淡 <code>dim</code>。通过声明一个引用，如 <code>lt</code> 和 <code>new</code> 关键字，我们创建了一个 <strong>Light</strong> 类型的对象，再用等号将其赋给引用。</p>
<p>​        为了向对象发送消息，我们使用句点符号 <code>.</code> 将 <code>lt</code> 和消息名称 <code>on</code> 连接起来。可以看出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单直观的。</p>
<h3 id="服务提供"><a href="#服务提供" class="headerlink" title="服务提供"></a>服务提供</h3><p>​        在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。你的程序本身将为用户提供服务，并且它能通过调用其他对象提供的服务来实现这一点。==我们的最终目标是开发或调用工具库中已有的一些对象，提供理想的服务来解决问题。==</p>
<p>​        软件设计的基本原则是==高内聚==：每个组件的内部作用明确，功能紧密相关。</p>
<p>​        这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。只有让人知道你提供什么服务，别人才能更好地将其应用到其他模块或程序中。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​        我们可以把编程的侧重领域划分为==研发==和==应用==。==应用程序员调用研发程序员构建的基础工具类来做快速开发==。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。</p>
<p>因此，使用访问控制的原因有以下两点：</p>
<ol>
<li>==让应用程序员不要触摸他们不应该触摸的部分==。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）；</li>
<li>使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如==工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。==</li>
</ol>
<p>​        Java 有三个显式关键字来设置==类==中的访问权限：<code>public</code>（公开），<code>private</code>（私有）和<code>protected</code>（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。</p>
<ol>
<li><code>public</code>（公开）表示任何人都可以访问和使用该元素；</li>
<li><code>private</code>（私有）除了==类本身和类内部的方法==，外界无法直接访问该元素。<code>private</code> 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</li>
<li><code>protected</code>（受保护）类似于 <code>private</code>，区别是==子类（下一节就会引入继承的概念）可以访问 <code>protected</code> 的成员==，但不能访问 <code>private</code> 成员；</li>
<li><code>default</code>（默认）如果你不使用前面的三者，默认就是 <code>default</code> 访问权限。<code>default</code> 被称为==包访问==，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</li>
</ol>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>​        一个类经创建和测试后，理应是可复用的。然而很多时候，由于程序员没有足够的编程经验和远见，我们的代码复用性并不强。</p>
<p>​        代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用性。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。这里涉及到“组合”和“聚合”的概念：</p>
<ul>
<li><p><strong>组合</strong>（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。</p>
</li>
<li><p><strong>聚合</strong>（Aggregation）动态的<strong>组合</strong>。</p>
<p>聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。）</p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​        通过使用 <code>class</code> 关键字，这些概念形成了编程语言中的基本单元。遗憾的是，这么做还是有很多麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。</p>
<p>​        在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。</p>
<img src="https://www.jishuchi.com/uploads/projects/onjava8/docs/images/1545764724202.png" alt="img" style="zoom:67%;" />

<p>​        尽管继承有时意味着你要在==接口中添加新方法==（尤其是在以 <strong>extends</strong> 关键字表示继承的 Java 中），但并非总需如此。第二种也是更重要的区分派生类和基类的方法是改变现有基类方法的行为，这被称为覆盖 (overriding)。==要想覆盖一个方法，只需要在派生类中重新定义这个方法即可。==</p>
<h4 id="“是一个”与”像是一个”的关系"><a href="#“是一个”与”像是一个”的关系" class="headerlink" title="“是一个”与”像是一个”的关系"></a>“是一个”与”像是一个”的关系</h4><p><strong>==is-a：子类和父类具有相同的方法，子类没有新方法也没有重写父类方法，子类完全替代父类。==</strong></p>
<p>​        我们经常把这种基类和派生类的关系称为是一个（is-a）关系，因为可以说”圆是一个形状”。判断是否继承，就看在你的类之间有无这种 is-a 关系。</p>
<p><strong>==is-like-a：子类有新方法，或者子类重写了父类方法。==</strong></p>
<p>​        有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>​        发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。编译器和运行时系统会负责对所有细节的控制；我们只需知道要做什么，以及如何利用多态性来更好地设计程序。</p>
<p><strong>实现多态有三个前提条件</strong></p>
<p><em>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。</em></p>
<p><em>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。</em></p>
<p><em>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 多态的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个父类的引用变量</span></span><br><span class="line">        <span class="type">PeoPle</span> <span class="variable">peoPle</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 指向子类的对象，Man是people的子类</span></span><br><span class="line">        peoPle = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        peoPle.say();</span><br><span class="line">        <span class="comment">// 指向子类的对象</span></span><br><span class="line">        peoPle = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">        peoPle.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单继承结构"><a href="#单继承结构" class="headerlink" title="单继承结构"></a>单继承结构</h3><p>​        自从 C++ 引入以来，一个 OOP 问题变得尤为突出：是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有OOP语言中也是这样）。在 Java 中，这个最终基类的名字就是 <code>Object</code>。</p>
<p>​        单继承的结构使得垃圾收集器的实现更为容易。这也是 Java 在 C++ 基础上的根本改进之一。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>​        在面向对象的设计中，问题的解决方案有些过于轻率：创建一个新类型的对象来引用、容纳其他的对象。当然，我们也可以使用多数编程语言都支持的“数组”（array）。==在 Java 中“集合”（Collection）的使用率更高。（也可称之为“容器”，但“集合”这个称呼更通用。）==</p>
<p>​        “集合”这种类型的对象==可以存储任意类型、数量的其他对象==。它能根据需要自动扩容，我们不用关心过程是如何实现的。</p>
<p>​        常见的==有 List，常用于保存序列==；==Map，也称为关联数组==，常用于将对象与其他对象关联；==Set，只能保存非重复的值==；其他还包括如队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。</p>
<p>​        从设计的角度来看，我们真正想要的是一个能够解决某个问题的集合。如果一种集合就满足所有需求，那么我们就不需要剩下的了。之所以选择集合有以下两个原因：</p>
<ol>
<li>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供的解决方案可能比其他灵活得多。</li>
<li>==不同的集合对某些操作有不同的效率==。例如，List 的两种基本类型：ArrayList 和 LinkedList。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。==在 ArrayList 中随机查找元素是很高效的==，而 LinkedList 随机查找效率低下。反之，在 LinkedList 中插入元素的效率要比在 ArrayList 中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</li>
</ol>
<p>​         在 Java 5 泛型出来之前，集合中保存的是通用类型 <code>Object</code>。Java 单继承的结构意味着所有元素都基于 <code>Object</code> 类，所以在集合中可以保存任何类型的数据，易于重用。要使用这样的集合，我们先要往集合添加元素。由于 Java 5 版本前的集合只保存 <code>Object</code>，==当我们往集合中添加元素时，元素便向上转型成了 <code>Object</code>，从而丢失自己原有的类型特性。==这时我们再从集合中取出该元素时，元素的类型变成了 <code>Object</code>。那么我们该怎么将其转回原先具体的类型呢？</p>
<p>​        这里，我们使用了==强制类型转换==将其转为更具体的类型，这个过程称为对象的“==向下转型==”。通过“向上转型”，我们知道“圆形”也是一种“形状”，这个过程是安全的。可是我们不能从“Object”看出其就是“圆形”或“形状”，所以除非我们能确定元素的具体类型信息，否则“向下转型”就是不安全的。</p>
<p>​        向上转型：圆是一种形状，安全的</p>
<p>​        向下转型：形状不一定是什么，可能是圆/三角形。不安全的</p>
<p>​        <strong>参数化类型应运而生！！！</strong></p>
<p>​        每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。==以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误==难道不好吗？这种解决方案就是：==参数化类型机制（Parameterized Type Mechanism）。==</p>
<p>​        <strong>泛型！！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="对象创建与生命周期"><a href="#对象创建与生命周期" class="headerlink" title="对象创建与生命周期"></a>对象创建与生命周期</h3><p>我们在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。</p>
<p>对象的数据在哪？它的生命周期是怎么被控制的？ ==在 C++ 设计中采用的观点是效率第一==，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。这种控制在某些情况下非常有用。</p>
<p>==第二种方法是在堆内存（Heap）中动态地创建对象==。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。</p>
<p>==Java 使用动态内存分配==。每次创建对象时，使用 <code>new</code> 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在 C++ 中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。==Java 的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。垃圾收集器的存在带来了极大的便利，它减少了我们之前必须要跟踪的问题和编写相关代码的数量。==因此，垃圾收集器提供了更高级别的保险，以防止潜在的内存泄漏问题，这个问题使得许多 C++ 项目没落。</p>
<p>Java 的垃圾收集器被设计用来解决内存释放的问题（虽然这不包括对象清理的其他方面）。垃圾收集器知道对象什么时候不再被使用并且自动释放内存。结合单继承和仅可在堆中创建对象的机制，Java 的编码过程比用 C++ 要简单得多。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​        异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。这让我们的编码更简单：不用再反复检查错误了。另外，异常不像方法返回的错误值和方法设置用来表示发生错误的标志位那样可以被忽略。异常的发生是不会被忽略的，它终究会在某一时刻被处理。</p>
<p>​        ==Java 的异常处理机制在编程语言中脱颖而出。==Java 从一开始就内置了异常处理，因此你不得不使用它。这是 Java 语言唯一接受的错误报告方法。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>​        面向对象编程的一个优点是：设计良好的 Java 程序代码更容易被人阅读理解。由于 Java 类库的复用性，通常程序要写的代码也会少得多。</p>
<h2 id="第二章-安装Java和本书用例"><a href="#第二章-安装Java和本书用例" class="headerlink" title="第二章 安装Java和本书用例"></a>第二章 安装Java和本书用例</h2><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>​        相比一些重量级的 IDE（Integrated Development Environments，集成开发环境），如 Eclipse、NetBeans 和 ==IntelliJ IDEA (译者注：做项目强烈推荐IDEA)==，编辑器是一种更纯粹的文本编辑器</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>​        如果你之前没有接触过编程，那么有可能对 ==Shell（命令行窗口）== 不太熟悉。shell 的历史可以追溯到早期的计算时代，当时在计算机上的操作是都通过输入命令进行的，计算机通过回显响应。所有的操作都是基于文本的。</p>
<p><strong>目录</strong></p>
<p>​        目录是 Shell 的基础元素之一。目录用来保存文件和其他目录。目录就好比树的分支。如果书籍是你系统上的一个目录，并且它有两个其他目录作为分支，例如数学和艺术，那么我们就可以说你有一个书籍目录，它包含数学和艺术两个子目录。注意：Windows 使用 <code>\</code> 而不是 <code>/</code> 来分隔路径。</p>
<p><strong>Shell基本操作</strong></p>
<p>我在这展示的 Shell 操作和系统中大体相同。出于本书的原因，下面列举一些在 Shell 中的基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">更改目录： cd &lt;路径&gt; </span><br><span class="line">          cd .. 移动到上级目录 </span><br><span class="line">          pushd &lt;路径&gt; 记住来源的同时移动到其他目录，popd 返回来源</span><br><span class="line">目录列举： ls 列举出当前目录下所有的文件和子目录名（不包含隐藏文件），</span><br><span class="line">             可以选择使用通配符 * 来缩小搜索范围。</span><br><span class="line">             示例(1)： 列举所有以“.java”结尾的文件，输入 ls *.java (Windows: dir *.java)</span><br><span class="line">             示例(2)： 列举所有以“F”开头，“.java”结尾的文件，输入ls F*.java (Windows: dir F*.java)</span><br><span class="line">创建目录： </span><br><span class="line">    Mac/Linux 系统：mkdir  </span><br><span class="line">              示例：mkdir books </span><br><span class="line">    Windows   系统：md </span><br><span class="line">              示例：md books</span><br><span class="line">移除文件： </span><br><span class="line">    Mac/Linux 系统：rm</span><br><span class="line">              示例：rm somefile.java</span><br><span class="line">    Windows   系统：del </span><br><span class="line">              示例：del somefile.java</span><br><span class="line">移除目录： </span><br><span class="line">    Mac/Linux 系统：rm -r</span><br><span class="line">              示例：rm -r books</span><br><span class="line">    Windows   系统：deltree </span><br><span class="line">              示例：deltree books</span><br><span class="line">重复命令： !!  重复上条命令</span><br><span class="line">              示例：!n 重复倒数第n条命令</span><br><span class="line">命令历史：     </span><br><span class="line">    Mac/Linux 系统：history</span><br><span class="line">    Windows   系统：按 F7 键</span><br><span class="line">文件解压：</span><br><span class="line">    Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。</span><br><span class="line">    图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，</span><br><span class="line">    在 Mac 上选择“open”，在 Linux 上选择“extract here”，或在 Windows 上选择“extract all…”。</span><br><span class="line">    要了解关于 shell 的更多信息，请在维基百科中搜索 Windows shell，Mac/Linux用户可搜索 bash shell。</span><br></pre></td></tr></table></figure>

<h3 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h3><p>​        为了编译和运行代码示例，首先你必须安装 JDK（Java Development Kit，JAVA 软件开发工具包）。本书中采用的是 JDK 8。</p>
<p><strong>Windows</strong></p>
<ol>
<li>以下为 Chocolatey 的<a target="_blank" rel="noopener" href="https://chocolatey.org/">安装说明</a>。</li>
<li>在命令行提示符下输入下面的命令，等待片刻，结束后 Java 安装完成并自动完成环境变量设置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install jdk8</span><br></pre></td></tr></table></figure>

<h3 id="校验安装"><a href="#校验安装" class="headerlink" title="校验安装"></a>校验安装</h3><p>打开新的命令行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>正常情况下 你应该看到以下类似信息(版本号信息可能不一样）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_112&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</span><br></pre></td></tr></table></figure>

<p>如果提示命令找不到或者无法被识别，请根据安装说明重试</p>
<h2 id="第三章-万物皆对象"><a href="#第三章-万物皆对象" class="headerlink" title="第三章 万物皆对象"></a>第三章 万物皆对象</h2><h3 id="对象操纵"><a href="#对象操纵" class="headerlink" title="对象操纵"></a>对象操纵</h3><p>​        “名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳”。（引用自 莎士比亚，《罗密欧与朱丽叶》）。</p>
<p>​        Java 利用万物皆对象的思想和单一一致的语法方式来简化问题。==虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用”== [^1]。举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>

<p>​        这里我们只是==创建了一个 <strong>String</strong> 对象的引用，而非对象==。直接拿来使用会出现错误：==因为此时你并没有给变量 <code>s</code> 赋值—指向任何对象==。通常更安全的做法是：创建一个引用的同时进行初始化。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;asdf&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​        Java 语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>​        “引用”用来关联“对象”。在 Java 中，通常我们使用<code>new</code>操作符来创建一个新对象。<code>new</code> 关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>​        那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：</p>
<ol>
<li><strong>寄存器</strong>（Registers）最快的存储区域，位于 CPU 内部 <a target="_blank" rel="noopener" href="https://www.jishuchi.com/read/onjava8/%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E8%8A%AF%E7%89%87%E9%83%BD%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%8C%E4%BD%86%E8%BF%99%E6%98%AF%E6%8C%89%E7%85%A7%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E5%99%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82">^2</a>。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。</li>
<li><strong>栈内存</strong>（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。==<strong>因此，虽然在栈内存上存在一些 Java 数据（如对象引用）</strong>，<strong>但 Java 对象本身的数据却是保存在堆内存的。</strong>==</li>
<li><strong>堆内存</strong>（Heap）这是一种通用的内存池（也在 RAM 区域），==<strong>所有 Java 对象都存在于其中</strong>==。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。==创建一个对象时，只需用 <code>new</code> 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。==这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。</li>
<li><strong>常量存储</strong>（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们==置于只读存储器 ROM== （只读存储器，Read Only Memory）中 <a target="_blank" rel="noopener" href="https://www.jishuchi.com/read/onjava8/%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%83%BD%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%94%BE%E5%85%A5%E7%89%B9%E6%AE%8A%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E4%B8%AD%E3%80%82">^3</a>。</li>
<li><strong>非 RAM 存储</strong>（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）==序列化对象：对象被转换为字节流，通常被发送到另一台机器；==（2）==持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在==。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。</li>
</ol>
<h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>​        有一组类型在 ==Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。==之所以这么说，是因为它们的==创建并不是通过 <code>new</code> 关键字来产生==。通常 ==<code>new</code> 出来的对象都是保存在堆内存中的==，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 <code>new</code> 创建变量，而是使用一个“自动”变量。 这个变量直接存储”值”，并置于栈内存中，因此更加高效。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">大小</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16 bits</td>
<td align="center">Unicode 0</td>
<td align="center">Unicode 216 -1</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8 bits</td>
<td align="center">-128</td>
<td align="center">+127</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16 bits</td>
<td align="center">- 2<sup>15</sup></td>
<td align="center">+ 2<sup>15</sup> -1</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32 bits</td>
<td align="center">- 2<sup>31</sup></td>
<td align="center">+ 2<sup>31</sup> -1</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64 bits</td>
<td align="center">- 2<sup>63</sup></td>
<td align="center">+ 2<sup>63</sup> -1</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">Void</td>
</tr>
</tbody></table>
<p>​        基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br></pre></td></tr></table></figure>

<p>​        基本类型自动转换成包装类型（自动装箱）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​        相对的，包装类型转化为基本类型（自动拆箱）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br></pre></td></tr></table></figure>

<h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p><strong>BigInteger  &amp;  BigDecimal</strong></p>
<p>​        在 Java 中有两种类型的数据可用于高精度的计算。它们是 <code>BigInteger</code> 和 <code>BigDecimal</code>。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。<br>​        在 BigInteger 和 BigDecimal 这里也同样可以，只==不过必须要通过调用它们的方法来实现而非运算符==。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，==我们牺牲了速度，但换来了精度==。</p>
<p>​        BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。</p>
<h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>​        Java 的设计主要目标之一是安全性。</p>
<p>​        在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。</p>
<p>​        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 <strong>null</strong> 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 <strong>null</strong> 的引用，则会在运行时报错。</p>
<p>​        ==我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。==</p>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>单行注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是单行注释</span><br></pre></td></tr></table></figure>

<p>多行注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 这是</span><br><span class="line">* 跨越多行的</span><br><span class="line">* 注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h3><p>——————————————————————————————————————————————————————————</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>​        大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在 C、 C++ 和 Java 中，作用域是由大括号 <code>&#123;&#125;</code> 的位置决定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// 仅 x 变量可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">96</span>;</span><br><span class="line">        <span class="comment">// x 和 q 变量皆可用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅 x 变量可用</span></span><br><span class="line">    <span class="comment">// 变量 q 不在作用域内</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Java 的变量只有在其作用域内才可用。缩进使得 Java 代码更易于阅读。由于 Java 是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">96</span>; <span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Java 编译器会在提示变量 x 已经被定义过了。</p>
<h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>​        Java 对象与基本类型具有不同的生命周期。当我们使用 <code>new</code> 关键字来创建 Java 对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 作用域终点</span></span><br></pre></td></tr></table></figure>

<p>​        上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。</p>
<p>​        只要你需要，<code>new</code> 出来的对象就会一直存活下去。</p>
<p>​        ==那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 <code>new</code> 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。==</p>
<h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>​        如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到 <code>type</code> 关键字。但是，事实上大多数面向对象的语言都使用 <code>class</code> 关键字类来描述一种新的对象。 通常在 <code>class</code> 关键字的后面的紧跟类的的名称。如下代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ATypeName</span> &#123;</span><br><span class="line"> <span class="comment">// 这里是类的内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上例中，我们引入了一个新的类型，尽管这个类里只有一行注释。但是我们一样可以通过 <code>new</code> 关键字来创建一个这种类型的对象。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ATypeName</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ATypeName</span>();</span><br></pre></td></tr></table></figure>

<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>​        当我们创建好一个类之后，==我们可以往类里存放两种类型的元素：方法（method）和字段（field）。==类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过之前介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。下面是一个具有某些字段的类的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataOnly</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须通过这个对象的引用来指定字段值。格式：对象名称.方法名称或字段名称。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOnly</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOnly</span>();</span><br><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h4><p>​            基本类型在类中会被初始化，在方法中不会初始化，方法中需要手动初始化！！！</p>
<p>​            ==这些默认值仅在 Java 初始化类的时候才会被赋予。==</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">\u0000 (null)</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte) 0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short) 0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
</tbody></table>
<p>​    这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 因此，若在方法中定义的基本类型数据，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br></pre></td></tr></table></figure>

<p>​        这里的变量 x 不会自动初始化为0，因而在使用变量 x 之前，程序员有责任主动地为其赋值（和 C 、C++ 一致）。如果我们忘记了这一步， Java 将会提示我们“编译时错误，该变量可能尚未被初始化”。</p>
<h4 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h4><p>​        在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[返回类型] [方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><p>​        方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为<strong>方法签名</strong>（signature of the method）。签名作为方法的唯一标识。</p>
<p>​        Java 中的方法只能作为类的一部分创建。它只能被对象所调用 <a target="_blank" rel="noopener" href="https://www.jishuchi.com/read/onjava8/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BE%88%E5%BF%AB%E5%B0%B1%E8%83%BD%E6%8E%A5%E8%A7%A6%E5%88%B0%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9B%B4%E6%8E%A5%E8%A2%AB%E7%B1%BB%E8%B0%83%E7%94%A8%E3%80%82">^4</a>，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象引用].[方法名](参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>​        ==方法参数列表指定了传递给方法的信息。==</p>
<p>​        参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用 [^5] 。但是引用的类型必须是正确的。如果方法需要 String 参数，则必须传入 String，否则编译器将报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">storage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当返回类型为 <strong>void</strong> 时， <strong>return</strong> 关键字仅用于退出方法，因此在方法结束处的 <strong>return</strong> 可被省略。我们可以随时从方法中返回，但若方法返回类型为非 <code>void</code>，则编译器会强制我们返回相应类型的值。</p>
<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>——————————————————————————————————————————————————————</p>
<h5 id="命名可见性（反向-URL-）"><a href="#命名可见性（反向-URL-）" class="headerlink" title="命名可见性（反向 URL ）"></a>命名可见性（反向 URL ）</h5><p>​        使用反向 URL 是一种新的命名空间方法，在此之前尚未有其他语言这么做过。Java 中有许多这些“创造性”地解决问题的方法。</p>
<h5 id="使用其他组件"><a href="#使用其他组件" class="headerlink" title="使用其他组件"></a>使用其他组件</h5><p>​         <strong>import</strong> 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><p>​        <strong>创建与类无关的方法！！！！！</strong></p>
<p>​        类是对象的外观及行为方式的描述。通常只有在使用 <code>new</code> 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。</p>
<ol>
<li><p>有时你只想为特定字段（注：也称为属性、域）分==配一个共享存储空间==，而不去考虑究竟要创建多少对象，==甚至根本就不创建对象==。</p>
</li>
<li><p>==创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。==</p>
<p>当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。</p>
</li>
</ol>
<p>​      一些面向对象的语言使用类数据（class data）和类方法（class method），表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。</p>
<p>​        我们可以在类的字段或方法前添加 <code>static</code> 关键字来表示这是一个静态字段或静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        相比非静态的对象，<code>static</code> 属性改变了数据创建的方式。同样，当 <code>static</code> 关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。正如我们所知，<code>static</code> 关键字的这些特性对于应用程序入口点的 <code>main()</code> 方法尤为重要。</p>
<h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h5 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h5><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>​        驼峰命名法！！</p>
<p>​        Java 编程语言编码规范（Code Conventions for the Java Programming Language）[^10] 要求类名的首字母大写。 如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllTheColorsOfTheRainbow</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章-运算符"><a href="#第四章-运算符" class="headerlink" title="第四章 运算符"></a>第四章 运算符</h2><p>​        运算符操纵数据。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>​        几乎所有运算符都==只能操作基本类型（Primitives==）。唯一的例外是 <code>=</code>、<code>==</code> 和 <code>!=</code>，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，==<strong>String</strong> 类支持 <code>+</code> 和 <code>+=</code>。==</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>​        应该用括号明确规定运算顺序</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>​        运算符的赋值是由符号 <code>=</code> 完成的。它代表着获取 <code>=</code> 右边的值并赋给左边的变量。==右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。==</p>
<p>​        也就是说，必须要有一个物理的空间来存放右边的值。举个例子来说，可将一个常数赋给一个变量（A = 4），但不可将任何东西赋给一个常数（比如不能 4 = A）。</p>
<p>​        如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。代码示例：</p>
<h4 id="方法调用中的别名现象"><a href="#方法调用中的别名现象" class="headerlink" title="方法调用中的别名现象"></a>方法调用中的别名现象</h4><p>————————————————————————————————————————————————————————</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>​        Java 的基本算术运算符与其他大多编程语言是相同的。其中包括加号 <code>+</code>、减号 <code>-</code>、除号 <code>/</code>、乘号 <code>*</code> 以及取模 <code>%</code>（从整数除法中获得余数）。==整数除法会直接砍掉小数，而不是进位。==</p>
<p>​        可用 x += 4 来表示：将 x 的值加上4的结果再赋值给 x。</p>
<p>​        不带参数的 <strong>Random</strong> 对象会利用当前的时间用作随机数生成器的“种子”（seed），从而为程序的每次执行生成不同的输出</p>
<p>​        我们通过在创建 <strong>Random</strong> 对象时提供种子（随机数生成器的初始化值，其始终为特定种子值产生相同的序列），让程序每次执行都生成相同的随机数，该对象通过调用方法 <code>nextInt()</code> 和 <code>nextFloat()</code>（还可以调用 <code>nextLong()</code> 或 <code>nextDouble()</code>），使用 <strong>Random</strong> 对象生成许多不同类型的随机数。</p>
<h4 id="一元加减运算符"><a href="#一元加减运算符" class="headerlink" title="一元加减运算符"></a>一元加减运算符</h4><p>——————————————————————————————————————————————————————————</p>
<h3 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h3><p>​        对于前递增和前递减（如 <code>++a</code> 或 <code>--a</code>），会先执行递增/减运算，再返回值。而对于后递增和后递减（如 <code>a++</code> 或 <code>a--</code>），会先返回值，再执行递增/减运算。</p>
<p>在早期的 Java 演讲中，<em>Bill Joy</em>（Java 作者之一）说“<strong>Java = C++ —</strong>”（C++ 减减），意味着 Java 在 C++ 的基础上减少了许多不必要的东西，因此语言更简单。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h4 id="测试对象等价"><a href="#测试对象等价" class="headerlink" title="测试对象等价"></a>测试对象等价</h4><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​        ==将 int 作为布尔处理不是合法的 Java 写法==</p>
<h4 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h4><p>​        &amp;&amp;             ||</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>​        通常，当我们向程序中插入一个字面值常量（<strong>Literal</strong>）时，编译器会确切地识别它的类型。当类型不明确时，==必须辅以字面值常量关联来帮助编译器识别。==代码示例：</p>
<p>​        对于 <strong>Long</strong> 型数值，结尾使用大写 <code>L</code> 或小写 <code>l</code> 皆可（不推荐使用 <code>l</code>，因为容易与阿拉伯数值 1 混淆）。大写 <code>F</code> 或小写 <code>f</code> 表示 <strong>float</strong> 浮点数。大写 <code>D</code> 或小写 <code>d</code> 表示 <strong>double</strong> 双精度。</p>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><h4 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h4><ol>
<li><p><code>// &quot;e&quot; 表示 10 的几次幂</code></p>
<p>在科学与工程学领域，<strong>e</strong> 代表自然对数的基数，约等于 2.718 （Java 里用一种更精确的 <strong>double</strong> 值 <strong>Math.E</strong> 来表示自然对数）。指数表达式 “1.39 x e-43”，意味着 “1.39 × 2.718 的 -43 次方”。</p>
<p>==所以倘若习惯 e 作为自然对数的基数使用，那么在 Java 中看到类似“1.39e-43f”这样的表达式时，请转换你的思维，从程序设计的角度思考它；它真正的含义是 “1.39 × 10 的 -43 次方”。==</p>
</li>
</ol>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>————————————————————————————————————————————————</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>————————————————————————————————————————————————</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>​        布尔表达式 ? 值 1 : 值 2</p>
<p>​        三元运算符的引入多半就是为了高效编程，但假若我们打算频繁使用它的话，还是先多作一些思量： 它易于产生可读性差的代码。==与 <strong>if-else</strong> 不同的是，三元运算符是有返回结果的。==</p>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>​        我们注意到运用 <code>String +</code> 时有一些有趣的现象。==若表达式以一个 <strong>String</strong> 类型开头（编译器会自动将双引号 <code>&quot;&quot;</code> 标注的的字符序列转换为字符串），那么后续所有运算对象都必须是字符串。==</p>
<h3 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h3><p>——————————————————————————————————————————————</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>​        “类型转换”（Casting）的作用是“与一个模型匹配”。在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为 <strong>float</strong> 变量赋值一个整数值，计算机会将 <strong>int</strong> 自动转换成 <strong>float</strong>。我们可以在程序未自动转换时显式、强制地使此类型发生转换。</p>
<p>​        在 Java 里，类型转换则是一种比较安全的操作。但是，若将数据类型进行“向下转换”（<strong>Narrowing Conversion</strong>）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型，好比在提醒我们：该操作可能危险，若你坚持让我这么做，那么对不起，请明确需要转换的类型。 对于“向上转换”（<strong>Widening conversion</strong>），则不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。</p>
<p>​        除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。</p>
<h4 id="截断和舍入"><a href="#截断和舍入" class="headerlink" title="截断和舍入"></a>截断和舍入</h4><p>​        从 <strong>float</strong> 和 <strong>double</strong> 转换为整数值时，小数位将被截断。==退一法！！！！！！==</p>
<p>​        若你想对结果进行四舍五入，可以使用 <code>java.lang.Math</code> 的 <code>round()</code> 方法：</p>
<h4 id="类型提升"><a href="#类型提升" class="headerlink" title="==类型提升=="></a>==类型提升==</h4><p>​        你会发现，如果我们对小于 <strong>int</strong> 的基本数据类型（即 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 <strong>int</strong>，并且结果值的类型为 <strong>int</strong>。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。==通常，表达式中最大的数据类型是决定表达式结果的数据类型。==<strong>float</strong> 型和 <strong>double</strong> 型相乘，结果是 <strong>double</strong> 型的；<strong>int</strong> 和 <strong>long</strong> 相加，结果是 <strong>long</strong> 型。</p>
<h3 id="Java没有sizeof"><a href="#Java没有sizeof" class="headerlink" title="Java没有sizeof"></a>Java没有sizeof</h3><p>​        Java 不需要 <code>sizeof()</code> 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</p>
<h3 id="运算符总结"><a href="#运算符总结" class="headerlink" title="运算符总结"></a>运算符总结</h3><p>​        <strong>注意</strong> ：<strong>boolean</strong> 类型的运算是受限的。你能为其赋值 <code>true</code> 或 <code>false</code>，也可测试它的值是否是 <code>true</code> 或 <code>false</code>。但你不能对其作加减等其他运算。</p>
<h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><p>​        我在 <em>Pomona College</em> 大学读过两年本科，在那里 47 被称之为“魔法数字”（<em>magic number</em>），详见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/47_(number)">维基百科</a> 。</p>
<h2 id="第五章-控制流"><a href="#第五章-控制流" class="headerlink" title="第五章 控制流"></a>第五章 控制流</h2><p>​        程序必须在执行过程中控制它的世界并做出选择。 在 Java 中，你需要执行控制语句来做出选择。</p>
<h3 id="true和false"><a href="#true和false" class="headerlink" title="true和false"></a>true和false</h3><p>​        ==所有的条件语句都利用条件表达式的“真”或“假”来决定执行路径。==</p>
<p>​        任何关系运算符都可以产生条件语句</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>                else if</code> 并非新关键字，它仅是 <code>else</code> 后紧跟的一条新 <code>if</code> 语句。</p>
<h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>​        <strong>while</strong>，<strong>do-while</strong> 和 <strong>for</strong> 用来控制循环语句（有时也称迭代语句）。只有控制循环的布尔表达式计算结果为 <code>false</code>，循环语句才会停止。</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h4 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h4><p>​        <strong>while</strong> 和 <strong>do-while</strong> 之间的唯一区别是：即使条件表达式返回结果为 <code>false</code>， ==<strong>do-while</strong> 语句也至少会执行一次==。 在 <strong>while</strong> 循环体中，如布尔表达式首次返回的结果就为 <code>false</code>，那么循环体内的语句不会被执行。实际应用中，<strong>while</strong> 形式比 <strong>do-while</strong> 更为常用。</p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>​        <strong>for</strong> 循环可能是最常用的迭代形式。 该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。<strong>for</strong> 循环的形式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; Boolean-expression; step)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>​        初始化 (initialization) 表达式、布尔表达式 (Boolean-expression) ，或者步进 (step) 运算，都可以为空。每次迭代之前都会判断布尔表达式的结果是否成立。一旦计算结果为 <code>false</code>，则跳出 <strong>for</strong> 循环体并继续执行后面代码。 每次循环结束时，都会执行一次步进。</p>
<h5 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h5><p>​        在 Java 中逗号运算符（这里并非指我们平常用于分隔定义和方法参数的逗号分隔符）仅有一种用法：在 <strong>for</strong> 循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。<strong>注意</strong>：要求定义的变量类型相同。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/CommaOperator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommaOperator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = i + <span class="number">10</span>; i &lt; <span class="number">5</span>; i++, j = i * <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot; j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in-语法"><a href="#for-in-语法" class="headerlink" title="for-in 语法"></a>for-in 语法</h3><p>​        Java 5 引入了更为简洁的“增强版 <strong>for</strong> 循环”语法来操纵数组和集合。</p>
<p>​        这条语句定义了一个 <strong>float</strong> 类型的变量 <code>x</code>，继而将每一个 <code>f</code> 的元素赋值给它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x : f) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>for-in</strong> 无需你去创建 <strong>int</strong> 变量和步进来控制循环计数。 下面我们来遍历获取 <strong>float</strong> 数组中的元素。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ForInFloat.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForInFloat</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="type">float</span>[] f = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      f[i] = rand.nextFloat();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> x : f)</span><br><span class="line">      System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        任何一个返回数组的方法都可以使用 <strong>for-in</strong> 循环语法来遍历元素。例如 <strong>String</strong> 类有一个方法 <code>toCharArray()</code>，返回值类型为 <strong>char</strong> 数组，我们可以很容易地在 <strong>for-in</strong> 循环中遍历它。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ForInString.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForInString</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: <span class="string">&quot;An African Swallow&quot;</span>.toCharArray())</span><br><span class="line">      System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <em>for-in</em> 语法可以节省我们编写代码的时间。 更重要的是，它提高了代码可读性以及更好地描述代码意图（获取数组的每个元素）而不是详细说明这操作细节（创建索引，并用它来选择数组元素） ==本书推荐使用 <em>for-in</em> 语法==。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>​        <strong>return</strong> 关键字有两方面的作用：1.指定一个方法返回值 (在方法返回类型非 <strong>void</strong> 的情况下)；2.退出当前方法。</p>
<p>​        如果在方法签名中定义了返回值类型为 <strong>void</strong>，那么在代码执行结束时会有一个隐式的 <strong>return</strong>。 也就是说我们不用在总是在方法中显式地包含 <strong>return</strong> 语句。 <strong>注意</strong>：如果你的方法声明的返回值类型为非 <strong>void</strong> 类型，那么则必须确保每个代码路径都返回一个值。</p>
<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>​        在任何迭代语句的主体内，都可以使用 <strong>break</strong> 和 <strong>continue</strong> 来控制循环的流程。 其中，<strong>break</strong> 表示跳出当前循环体。而 <strong>continue</strong> 表示停止本次循环，开始下一次循环。</p>
<h3 id="臭名昭著的-goto"><a href="#臭名昭著的-goto" class="headerlink" title="臭名昭著的 goto"></a>臭名昭著的 goto</h3><p>—————————————————————————————————————————————————————————————</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>​        <strong>switch</strong> 有时也被划归为一种选择语句。根据整数表达式的值，<strong>switch</strong> 语句可以从一系列代码中选出一段去执行。</p>
<p>​        case后不一定是整数，可以是char String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value4 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value5 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        一旦理解了 <strong>switch</strong>，你会明白这其实就是一个逻辑扩展的==语法糖==。新的编码方式能使得结果更清晰，更易于理解和维护。</p>
<h3 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h3><p><code>        Math.random()</code> 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1) 来表示。</p>
<h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><p>—————————————————————————————————————————————————————————————</p>
<h2 id="第六章-初始化和清理"><a href="#第六章-初始化和清理" class="headerlink" title="第六章 初始化和清理"></a>第六章 初始化和清理</h2><p>​        Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在 Java 中对它们的支持。</p>
<h3 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h3><p>​        你可能想为每个类创建一个 <code>initialize()</code> 方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。</p>
<p>​         Java 中使用了同样的方式：==构造器名称与类名相同==。在初始化过程中自动调用构造器方法是有意义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rock</span> &#123;</span><br><span class="line">    Rock() &#123; <span class="comment">// 这是一个构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Rock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p><code>Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock</code></p>
</blockquote>
<p>​        现在，当创建一个对象时：<code>new Rock()</code> ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。</p>
<p>​        ==构造器没有返回值==，它是一种特殊的方法。但它和返回类型为 <code>void</code> 的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值，却同时也没有给你选择的余地（<code>new</code> 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值（这个返回值没有接收者）。</p>
<h3 id="方法重载-方法名相同，参数不同"><a href="#方法重载-方法名相同，参数不同" class="headerlink" title="方法重载(方法名相同，参数不同)"></a>方法重载(方法名相同，参数不同)</h3><p>​        在 Java (C++) 中，还有一个因素也促使了必须使用方法重载：==构造器==。因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。</p>
<p>​        因此，方法重载是必要的，它允许方法==具有相同的方法名但接收的参数不同（和返回值无关）==。尽管方法重载对于构造器是重要的，但是也可以很方便地对其他任何方法进行重载。</p>
<h4 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h4><h4 id="重载与基本类型"><a href="#重载与基本类型" class="headerlink" title="重载与基本类型"></a>重载与基本类型</h4><h3 id="返回值的重载"><a href="#返回值的重载" class="headerlink" title="返回值的重载"></a>返回值的重载</h3><p>​        重载与是否有返回值无关！！！</p>
<h3 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h3><p>​        ==编译器默认给一个无参构造方法。一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。==</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>​        <strong>this</strong> 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，<strong>this</strong> 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用该类的其他方法，不要使用 <strong>this</strong>，直接调用即可，<strong>this</strong> 自动地应用于其他方法上了。因此你可以像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Leaf <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：<code>i = 3</code></p>
</blockquote>
<p>​        因为 <code>increment()</code> 通过 <strong>this</strong> 关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。</p>
<h4 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h4><p>————————————————————————————————————————————————————————————</p>
<h4 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h4><p>​        记住了 <strong>this</strong> 关键字的内容，你会对 <strong>static</strong> 修饰的方法有更加深入的理解：<strong>static</strong> 方法中不会存在 <strong>this</strong>。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以访问其他静态方法和静态属性。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 <strong>this</strong>，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 <strong>static</strong> 方法，就该重新考虑自己的设计了。然而，<strong>static</strong> 的概念很实用，许多时候都要用到它。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title="finalize() 的用途"></a>finalize() 的用途</h4><h4 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h4><h4 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h4><h4 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h4><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><h4 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h4><h3 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h3><h4 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="==初始化的顺序=="></a>==初始化的顺序==</h4><p>​        ==<strong>类变量——&gt;构造方法——&gt;普通方法</strong>==</p>
<p>​        在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OrderOfInitialization.java</span></span><br><span class="line"><span class="comment">// Demonstrates initialization order</span></span><br><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you&#x27;ll see a message:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    Window(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line">    House() &#123;</span><br><span class="line">        <span class="comment">// Show that we&#x27;re in the constructor:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderOfInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">House</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<ol>
<li><code>Window(1)</code></li>
<li><code>Window(2)</code></li>
<li><code>Window(3)</code></li>
<li><code>House()</code></li>
<li><code>Window(33)</code></li>
<li><code>f()</code></li>
</ol>
</blockquote>
<p>​        在 <strong>House</strong> 类中，故意把几个 <strong>Window</strong> 对象的定义散布在各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，<strong>w3</strong> 在构造器中被再次赋值。</p>
<p>​        由输出可见，引用 <strong>w3</strong> 被初始化了两次：一次在调用构造器前，一次在构造器调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）。这乍一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化 <strong>w3</strong>，同时在定义 <strong>w3</strong> 时没有赋予初值，那会产生怎样的后果呢？</p>
<h4 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h4><p>​        无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p>
<p>​        下面例子显示了静态存储区是何时初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/StaticInitialization.java</span></span><br><span class="line"><span class="comment">// Specifying initial values in a class definition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">    Bowl(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">    Table() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">        bowl2.f1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">    <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">    Cupboard() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">        bowl4.f1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        table.f2(<span class="number">1</span>);</span><br><span class="line">        cupboard.f3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bowl</strong> 类展示类的创建，而 <strong>Table</strong> 和 <strong>Cupboard</strong> 在它们的类定义中包含 <strong>Bowl</strong> 类型的静态数据成员。注意，在静态数据成员定义之前，<strong>Cupboard</strong> 类中先定义了一个 <strong>Bowl</strong> 类型的非静态成员 <strong>b3</strong>。</p>
<p>由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 <strong>Table</strong> 对象，也不引用 <strong>Table.bowl1</strong> 或 <strong>Table.bowl2</strong>，那么静态的 <strong>Bowl</strong> 类对象 <strong>bowl1</strong> 和 <strong>bowl2</strong> 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。</p>
<p>初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，从输出中可以看出。要执行 <code>main()</code> 方法，必须加载 <strong>StaticInitialization</strong> 类，它的静态属性 <strong>table</strong> 和 <strong>cupboard</strong> 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 <strong>Bowl</strong> 对象，所以 <strong>Bowl</strong> 类也会被加载。因此，在这个特殊的程序中，所有的类都会在 <code>main()</code> 方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过 <strong>static</strong> 联系起来。</p>
<p>==概括一下创建对象的过程，假设有个名为 <strong>Dog</strong> 的类：==</p>
<ol>
<li>==即使没有显式地使用 <strong>static</strong> 关键字，构造器实际上也是静态方法。所以，当首次创建 <strong>Dog</strong> 类型的对象或是首次访问 <strong>Dog</strong> 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 <strong>Dog.class</strong>。==</li>
<li>==当加载完 <strong>Dog.class</strong> 后（后面会学到，这将创建一个 <strong>Class</strong> 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 <strong>Class</strong> 对象时初始化一次。==</li>
<li>==当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 <strong>Dog</strong> 对象分配足够的存储空间。==</li>
<li>==分配的存储空间首先会被清零，即会将 <strong>Dog</strong> 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 <strong>null</strong>。==</li>
<li>==执行所有出现在字段定义处的初始化动作。==</li>
<li>==执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。==</li>
</ol>
<p>——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————</p>
<h4 id="显式的静态初始化"><a href="#显式的静态初始化" class="headerlink" title="显式的静态初始化"></a>显式的静态初始化</h4><h4 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h4><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><h4 id="动态数组创建"><a href="#动态数组创建" class="headerlink" title="动态数组创建"></a>动态数组创建</h4><h4 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h4><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><h3 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/" data-id="clco97ejn0000wwn3fiyhahl6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/hello-world/" class="article-date">
  <time datetime="2023-01-09T02:59:09.030Z" itemprop="datePublished">2023-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/hello-world/" data-id="clco7ut4p0000gon33tlueb8b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%AC%E4%BA%8C%E7%AF%87blog/" rel="tag">第二篇blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E7%AC%AC%E4%BA%8C%E7%AF%87blog/" style="font-size: 10px;">第二篇blog</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87blog/">小胡子的第二篇blog</a>
          </li>
        
          <li>
            <a href="/2023/01/09/%E5%B0%8F%E8%83%A1%E5%AD%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/">小胡子的第一篇blog</a>
          </li>
        
          <li>
            <a href="/2023/01/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>